#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import controller.thrift_api.res_pd_rpc.ttypes

from thrift.transport import TTransport
all_structs = []


class MirrorType_e(object):
    PD_MIRROR_TYPE_NORM = 0
    PD_MIRROR_TYPE_COAL = 1
    PD_MIRROR_TYPE_MAX = 2

    _VALUES_TO_NAMES = {
        0: "PD_MIRROR_TYPE_NORM",
        1: "PD_MIRROR_TYPE_COAL",
        2: "PD_MIRROR_TYPE_MAX",
    }

    _NAMES_TO_VALUES = {
        "PD_MIRROR_TYPE_NORM": 0,
        "PD_MIRROR_TYPE_COAL": 1,
        "PD_MIRROR_TYPE_MAX": 2,
    }


class Direction_e(object):
    PD_DIR_NONE = 0
    PD_DIR_INGRESS = 1
    PD_DIR_EGRESS = 2
    PD_DIR_BOTH = 3

    _VALUES_TO_NAMES = {
        0: "PD_DIR_NONE",
        1: "PD_DIR_INGRESS",
        2: "PD_DIR_EGRESS",
        3: "PD_DIR_BOTH",
    }

    _NAMES_TO_VALUES = {
        "PD_DIR_NONE": 0,
        "PD_DIR_INGRESS": 1,
        "PD_DIR_EGRESS": 2,
        "PD_DIR_BOTH": 3,
    }


class MetaFlag_e(object):
    PD_HASH_CFG = 0
    PD_HASH_CFG_P = 1
    PD_ICOS_CFG = 2
    PD_DOD_CFG = 3
    PD_C2C_CFG = 4
    PD_MC_CFG = 5
    PD_EPIPE_CFG = 6

    _VALUES_TO_NAMES = {
        0: "PD_HASH_CFG",
        1: "PD_HASH_CFG_P",
        2: "PD_ICOS_CFG",
        3: "PD_DOD_CFG",
        4: "PD_C2C_CFG",
        5: "PD_MC_CFG",
        6: "PD_EPIPE_CFG",
    }

    _NAMES_TO_VALUES = {
        "PD_HASH_CFG": 0,
        "PD_HASH_CFG_P": 1,
        "PD_ICOS_CFG": 2,
        "PD_DOD_CFG": 3,
        "PD_C2C_CFG": 4,
        "PD_MC_CFG": 5,
        "PD_EPIPE_CFG": 6,
    }


class InvalidPipeMgrOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidPipeMgrOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidPipeMgrOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MirrorSessionInfo_t(object):
    """
    Attributes:
     - mir_type
     - direction
     - mir_id
     - egr_port
     - egr_port_v
     - egr_port_queue
     - packet_color
     - mcast_grp_a
     - mcast_grp_a_v
     - mcast_grp_b
     - mcast_grp_b_v
     - max_pkt_len
     - level1_mcast_hash
     - level2_mcast_hash
     - mcast_l1_xid
     - mcast_l2_xid
     - mcast_rid
     - cos
     - c2c
     - extract_len
     - timeout_usec
     - int_hdr
     - int_hdr_len

    """


    def __init__(self, mir_type=None, direction=None, mir_id=None, egr_port=None, egr_port_v=None, egr_port_queue=None, packet_color=None, mcast_grp_a=None, mcast_grp_a_v=None, mcast_grp_b=None, mcast_grp_b_v=None, max_pkt_len=None, level1_mcast_hash=None, level2_mcast_hash=None, mcast_l1_xid=None, mcast_l2_xid=None, mcast_rid=None, cos=None, c2c=None, extract_len=None, timeout_usec=None, int_hdr=None, int_hdr_len=None,):
        self.mir_type = mir_type
        self.direction = direction
        self.mir_id = mir_id
        self.egr_port = egr_port
        self.egr_port_v = egr_port_v
        self.egr_port_queue = egr_port_queue
        self.packet_color = packet_color
        self.mcast_grp_a = mcast_grp_a
        self.mcast_grp_a_v = mcast_grp_a_v
        self.mcast_grp_b = mcast_grp_b
        self.mcast_grp_b_v = mcast_grp_b_v
        self.max_pkt_len = max_pkt_len
        self.level1_mcast_hash = level1_mcast_hash
        self.level2_mcast_hash = level2_mcast_hash
        self.mcast_l1_xid = mcast_l1_xid
        self.mcast_l2_xid = mcast_l2_xid
        self.mcast_rid = mcast_rid
        self.cos = cos
        self.c2c = c2c
        self.extract_len = extract_len
        self.timeout_usec = timeout_usec
        self.int_hdr = int_hdr
        self.int_hdr_len = int_hdr_len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mir_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.mir_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.egr_port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.egr_port_v = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I16:
                    self.egr_port_queue = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I16:
                    self.packet_color = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I16:
                    self.mcast_grp_a = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.mcast_grp_a_v = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I16:
                    self.mcast_grp_b = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.mcast_grp_b_v = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I16:
                    self.max_pkt_len = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.level1_mcast_hash = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.level2_mcast_hash = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I16:
                    self.mcast_l1_xid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I16:
                    self.mcast_l2_xid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I16:
                    self.mcast_rid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.BYTE:
                    self.cos = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.c2c = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I16:
                    self.extract_len = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.timeout_usec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.LIST:
                    self.int_hdr = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.int_hdr.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.BYTE:
                    self.int_hdr_len = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MirrorSessionInfo_t')
        if self.mir_type is not None:
            oprot.writeFieldBegin('mir_type', TType.I32, 1)
            oprot.writeI32(self.mir_type)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 2)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.mir_id is not None:
            oprot.writeFieldBegin('mir_id', TType.I16, 3)
            oprot.writeI16(self.mir_id)
            oprot.writeFieldEnd()
        if self.egr_port is not None:
            oprot.writeFieldBegin('egr_port', TType.I16, 4)
            oprot.writeI16(self.egr_port)
            oprot.writeFieldEnd()
        if self.egr_port_v is not None:
            oprot.writeFieldBegin('egr_port_v', TType.BOOL, 5)
            oprot.writeBool(self.egr_port_v)
            oprot.writeFieldEnd()
        if self.egr_port_queue is not None:
            oprot.writeFieldBegin('egr_port_queue', TType.I16, 6)
            oprot.writeI16(self.egr_port_queue)
            oprot.writeFieldEnd()
        if self.packet_color is not None:
            oprot.writeFieldBegin('packet_color', TType.I16, 7)
            oprot.writeI16(self.packet_color)
            oprot.writeFieldEnd()
        if self.mcast_grp_a is not None:
            oprot.writeFieldBegin('mcast_grp_a', TType.I16, 8)
            oprot.writeI16(self.mcast_grp_a)
            oprot.writeFieldEnd()
        if self.mcast_grp_a_v is not None:
            oprot.writeFieldBegin('mcast_grp_a_v', TType.BOOL, 9)
            oprot.writeBool(self.mcast_grp_a_v)
            oprot.writeFieldEnd()
        if self.mcast_grp_b is not None:
            oprot.writeFieldBegin('mcast_grp_b', TType.I16, 10)
            oprot.writeI16(self.mcast_grp_b)
            oprot.writeFieldEnd()
        if self.mcast_grp_b_v is not None:
            oprot.writeFieldBegin('mcast_grp_b_v', TType.BOOL, 11)
            oprot.writeBool(self.mcast_grp_b_v)
            oprot.writeFieldEnd()
        if self.max_pkt_len is not None:
            oprot.writeFieldBegin('max_pkt_len', TType.I16, 12)
            oprot.writeI16(self.max_pkt_len)
            oprot.writeFieldEnd()
        if self.level1_mcast_hash is not None:
            oprot.writeFieldBegin('level1_mcast_hash', TType.I32, 13)
            oprot.writeI32(self.level1_mcast_hash)
            oprot.writeFieldEnd()
        if self.level2_mcast_hash is not None:
            oprot.writeFieldBegin('level2_mcast_hash', TType.I32, 14)
            oprot.writeI32(self.level2_mcast_hash)
            oprot.writeFieldEnd()
        if self.mcast_l1_xid is not None:
            oprot.writeFieldBegin('mcast_l1_xid', TType.I16, 15)
            oprot.writeI16(self.mcast_l1_xid)
            oprot.writeFieldEnd()
        if self.mcast_l2_xid is not None:
            oprot.writeFieldBegin('mcast_l2_xid', TType.I16, 16)
            oprot.writeI16(self.mcast_l2_xid)
            oprot.writeFieldEnd()
        if self.mcast_rid is not None:
            oprot.writeFieldBegin('mcast_rid', TType.I16, 17)
            oprot.writeI16(self.mcast_rid)
            oprot.writeFieldEnd()
        if self.cos is not None:
            oprot.writeFieldBegin('cos', TType.BYTE, 18)
            oprot.writeByte(self.cos)
            oprot.writeFieldEnd()
        if self.c2c is not None:
            oprot.writeFieldBegin('c2c', TType.BOOL, 19)
            oprot.writeBool(self.c2c)
            oprot.writeFieldEnd()
        if self.extract_len is not None:
            oprot.writeFieldBegin('extract_len', TType.I16, 20)
            oprot.writeI16(self.extract_len)
            oprot.writeFieldEnd()
        if self.timeout_usec is not None:
            oprot.writeFieldBegin('timeout_usec', TType.I32, 21)
            oprot.writeI32(self.timeout_usec)
            oprot.writeFieldEnd()
        if self.int_hdr is not None:
            oprot.writeFieldBegin('int_hdr', TType.LIST, 22)
            oprot.writeListBegin(TType.I32, len(self.int_hdr))
            for iter6 in self.int_hdr:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.int_hdr_len is not None:
            oprot.writeFieldBegin('int_hdr_len', TType.BYTE, 23)
            oprot.writeByte(self.int_hdr_len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MirrorSessionGetResult_t(object):
    """
    Attributes:
     - info
     - pipe_id

    """


    def __init__(self, info=None, pipe_id=None,):
        self.info = info
        self.pipe_id = pipe_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.info = MirrorSessionInfo_t()
                    self.info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pipe_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MirrorSessionGetResult_t')
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRUCT, 1)
            self.info.write(oprot)
            oprot.writeFieldEnd()
        if self.pipe_id is not None:
            oprot.writeFieldBegin('pipe_id', TType.I16, 2)
            oprot.writeI16(self.pipe_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(InvalidPipeMgrOperation)
InvalidPipeMgrOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(MirrorSessionInfo_t)
MirrorSessionInfo_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mir_type', None, None, ),  # 1
    (2, TType.I32, 'direction', None, None, ),  # 2
    (3, TType.I16, 'mir_id', None, None, ),  # 3
    (4, TType.I16, 'egr_port', None, None, ),  # 4
    (5, TType.BOOL, 'egr_port_v', None, None, ),  # 5
    (6, TType.I16, 'egr_port_queue', None, None, ),  # 6
    (7, TType.I16, 'packet_color', None, None, ),  # 7
    (8, TType.I16, 'mcast_grp_a', None, None, ),  # 8
    (9, TType.BOOL, 'mcast_grp_a_v', None, None, ),  # 9
    (10, TType.I16, 'mcast_grp_b', None, None, ),  # 10
    (11, TType.BOOL, 'mcast_grp_b_v', None, None, ),  # 11
    (12, TType.I16, 'max_pkt_len', None, None, ),  # 12
    (13, TType.I32, 'level1_mcast_hash', None, None, ),  # 13
    (14, TType.I32, 'level2_mcast_hash', None, None, ),  # 14
    (15, TType.I16, 'mcast_l1_xid', None, None, ),  # 15
    (16, TType.I16, 'mcast_l2_xid', None, None, ),  # 16
    (17, TType.I16, 'mcast_rid', None, None, ),  # 17
    (18, TType.BYTE, 'cos', None, None, ),  # 18
    (19, TType.BOOL, 'c2c', None, None, ),  # 19
    (20, TType.I16, 'extract_len', None, None, ),  # 20
    (21, TType.I32, 'timeout_usec', None, None, ),  # 21
    (22, TType.LIST, 'int_hdr', (TType.I32, None, False), None, ),  # 22
    (23, TType.BYTE, 'int_hdr_len', None, None, ),  # 23
)
all_structs.append(MirrorSessionGetResult_t)
MirrorSessionGetResult_t.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'info', [MirrorSessionInfo_t, None], None, ),  # 1
    (2, TType.I16, 'pipe_id', None, None, ),  # 2
)
fix_spec(all_structs)
del all_structs
