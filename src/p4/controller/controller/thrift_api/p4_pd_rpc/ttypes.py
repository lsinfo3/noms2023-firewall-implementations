#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import controller.thrift_api.res_pd_rpc.ttypes

from thrift.transport import TTransport
all_structs = []


class main_lpf_type(object):
    TYPE_RATE = 0
    TYPE_SAMPLE = 1

    _VALUES_TO_NAMES = {
        0: "TYPE_RATE",
        1: "TYPE_SAMPLE",
    }

    _NAMES_TO_VALUES = {
        "TYPE_RATE": 0,
        "TYPE_SAMPLE": 1,
    }


class main_idle_time_mode(object):
    POLL_MODE = 0
    NOTIFY_MODE = 1
    INVALID_MODE = 2

    _VALUES_TO_NAMES = {
        0: "POLL_MODE",
        1: "NOTIFY_MODE",
        2: "INVALID_MODE",
    }

    _NAMES_TO_VALUES = {
        "POLL_MODE": 0,
        "NOTIFY_MODE": 1,
        "INVALID_MODE": 2,
    }


class main_idle_time_hit_state(object):
    ENTRY_IDLE = 0
    ENTRY_ACTIVE = 1

    _VALUES_TO_NAMES = {
        0: "ENTRY_IDLE",
        1: "ENTRY_ACTIVE",
    }

    _NAMES_TO_VALUES = {
        "ENTRY_IDLE": 0,
        "ENTRY_ACTIVE": 1,
    }


class main_grp_mbr_state(object):
    MBR_ACTIVE = 0
    MBR_INACTIVE = 1

    _VALUES_TO_NAMES = {
        0: "MBR_ACTIVE",
        1: "MBR_INACTIVE",
    }

    _NAMES_TO_VALUES = {
        "MBR_ACTIVE": 0,
        "MBR_INACTIVE": 1,
    }


class tbl_property_t(object):
    TBL_PROP_TBL_ENTRY_SCOPE = 1
    TBL_PROP_TERN_TABLE_ENTRY_PLACEMENT = 2
    TBL_PROP_DUPLICATE_ENTRY_CHECK = 3
    TBL_PROP_IDLETIME_REPEATED_NOTIFICATION = 4

    _VALUES_TO_NAMES = {
        1: "TBL_PROP_TBL_ENTRY_SCOPE",
        2: "TBL_PROP_TERN_TABLE_ENTRY_PLACEMENT",
        3: "TBL_PROP_DUPLICATE_ENTRY_CHECK",
        4: "TBL_PROP_IDLETIME_REPEATED_NOTIFICATION",
    }

    _NAMES_TO_VALUES = {
        "TBL_PROP_TBL_ENTRY_SCOPE": 1,
        "TBL_PROP_TERN_TABLE_ENTRY_PLACEMENT": 2,
        "TBL_PROP_DUPLICATE_ENTRY_CHECK": 3,
        "TBL_PROP_IDLETIME_REPEATED_NOTIFICATION": 4,
    }


class tbl_property_value_t(object):
    ENTRY_SCOPE_ALL_PIPELINES = 0
    ENTRY_SCOPE_SINGLE_PIPELINE = 1
    ENTRY_SCOPE_USER_DEFINED = 2
    TERN_ENTRY_PLACEMENT_DRV_MANAGED = 0
    TERN_ENTRY_PLACEMENT_APP_MANAGED = 1
    DUPLICATE_ENTRY_CHECK_DISABLE = 0
    DUPLICATE_ENTRY_CHECK_ENABLE = 1
    IDLETIME_REPEATED_NOTIFICATION_DISABLE = 0
    IDLETIME_REPEATED_NOTIFICATION_ENABLE = 1

    _VALUES_TO_NAMES = {
        0: "ENTRY_SCOPE_ALL_PIPELINES",
        1: "ENTRY_SCOPE_SINGLE_PIPELINE",
        2: "ENTRY_SCOPE_USER_DEFINED",
        0: "TERN_ENTRY_PLACEMENT_DRV_MANAGED",
        1: "TERN_ENTRY_PLACEMENT_APP_MANAGED",
        0: "DUPLICATE_ENTRY_CHECK_DISABLE",
        1: "DUPLICATE_ENTRY_CHECK_ENABLE",
        0: "IDLETIME_REPEATED_NOTIFICATION_DISABLE",
        1: "IDLETIME_REPEATED_NOTIFICATION_ENABLE",
    }

    _NAMES_TO_VALUES = {
        "ENTRY_SCOPE_ALL_PIPELINES": 0,
        "ENTRY_SCOPE_SINGLE_PIPELINE": 1,
        "ENTRY_SCOPE_USER_DEFINED": 2,
        "TERN_ENTRY_PLACEMENT_DRV_MANAGED": 0,
        "TERN_ENTRY_PLACEMENT_APP_MANAGED": 1,
        "DUPLICATE_ENTRY_CHECK_DISABLE": 0,
        "DUPLICATE_ENTRY_CHECK_ENABLE": 1,
        "IDLETIME_REPEATED_NOTIFICATION_DISABLE": 0,
        "IDLETIME_REPEATED_NOTIFICATION_ENABLE": 1,
    }


class pvs_gress_t(object):
    PVS_GRESS_INGRESS = 0
    PVS_GRESS_EGRESS = 1
    PVS_GRESS_ALL = 255

    _VALUES_TO_NAMES = {
        0: "PVS_GRESS_INGRESS",
        1: "PVS_GRESS_EGRESS",
        255: "PVS_GRESS_ALL",
    }

    _NAMES_TO_VALUES = {
        "PVS_GRESS_INGRESS": 0,
        "PVS_GRESS_EGRESS": 1,
        "PVS_GRESS_ALL": 255,
    }


class pvs_property_t(object):
    PVS_PROP_NONE = 0
    PVS_GRESS_SCOPE = 1
    PVS_PIPE_SCOPE = 2
    PVS_PARSER_SCOPE = 3

    _VALUES_TO_NAMES = {
        0: "PVS_PROP_NONE",
        1: "PVS_GRESS_SCOPE",
        2: "PVS_PIPE_SCOPE",
        3: "PVS_PARSER_SCOPE",
    }

    _NAMES_TO_VALUES = {
        "PVS_PROP_NONE": 0,
        "PVS_GRESS_SCOPE": 1,
        "PVS_PIPE_SCOPE": 2,
        "PVS_PARSER_SCOPE": 3,
    }


class pvs_property_value_t(object):
    PVS_SCOPE_ALL_GRESS = 0
    PVS_SCOPE_SINGLE_GRESS = 1
    PVS_SCOPE_ALL_PIPELINES = 0
    PVS_SCOPE_SINGLE_PIPELINE = 1
    PVS_SCOPE_ALL_PARSERS = 0
    PVS_SCOPE_SINGLE_PARSER = 1

    _VALUES_TO_NAMES = {
        0: "PVS_SCOPE_ALL_GRESS",
        1: "PVS_SCOPE_SINGLE_GRESS",
        0: "PVS_SCOPE_ALL_PIPELINES",
        1: "PVS_SCOPE_SINGLE_PIPELINE",
        0: "PVS_SCOPE_ALL_PARSERS",
        1: "PVS_SCOPE_SINGLE_PARSER",
    }

    _NAMES_TO_VALUES = {
        "PVS_SCOPE_ALL_GRESS": 0,
        "PVS_SCOPE_SINGLE_GRESS": 1,
        "PVS_SCOPE_ALL_PIPELINES": 0,
        "PVS_SCOPE_SINGLE_PIPELINE": 1,
        "PVS_SCOPE_ALL_PARSERS": 0,
        "PVS_SCOPE_SINGLE_PARSER": 1,
    }


class tbl_dbg_counter_type_t(object):
    TBL_DBG_CNTR_DISABLED = 0
    TBL_DBG_CNTR_LOG_TBL_MISS = 1
    TBL_DBG_CNTR_LOG_TBL_HIT = 2
    TBL_DBG_CNTR_GW_TBL_MISS = 3
    TBL_DBG_CNTR_GW_TBL_HIT = 4
    TBL_DBG_CNTR_GW_TBL_INHIBIT = 5
    TBL_DBG_CNTR_MAX = 6

    _VALUES_TO_NAMES = {
        0: "TBL_DBG_CNTR_DISABLED",
        1: "TBL_DBG_CNTR_LOG_TBL_MISS",
        2: "TBL_DBG_CNTR_LOG_TBL_HIT",
        3: "TBL_DBG_CNTR_GW_TBL_MISS",
        4: "TBL_DBG_CNTR_GW_TBL_HIT",
        5: "TBL_DBG_CNTR_GW_TBL_INHIBIT",
        6: "TBL_DBG_CNTR_MAX",
    }

    _NAMES_TO_VALUES = {
        "TBL_DBG_CNTR_DISABLED": 0,
        "TBL_DBG_CNTR_LOG_TBL_MISS": 1,
        "TBL_DBG_CNTR_LOG_TBL_HIT": 2,
        "TBL_DBG_CNTR_GW_TBL_MISS": 3,
        "TBL_DBG_CNTR_GW_TBL_HIT": 4,
        "TBL_DBG_CNTR_GW_TBL_INHIBIT": 5,
        "TBL_DBG_CNTR_MAX": 6,
    }


class main_input_field_attr_type_t(object):
    INPUT_FIELD_ATTR_TYPE_MASK = 0
    INPUT_FIELD_ATTR_TYPE_VALUE = 1

    _VALUES_TO_NAMES = {
        0: "INPUT_FIELD_ATTR_TYPE_MASK",
        1: "INPUT_FIELD_ATTR_TYPE_VALUE",
    }

    _NAMES_TO_VALUES = {
        "INPUT_FIELD_ATTR_TYPE_MASK": 0,
        "INPUT_FIELD_ATTR_TYPE_VALUE": 1,
    }


class main_input_field_attr_value_mask_t(object):
    INPUT_FIELD_EXCLUDED = 0
    INPUT_FIELD_INCLUDED = 1

    _VALUES_TO_NAMES = {
        0: "INPUT_FIELD_EXCLUDED",
        1: "INPUT_FIELD_INCLUDED",
    }

    _NAMES_TO_VALUES = {
        "INPUT_FIELD_EXCLUDED": 0,
        "INPUT_FIELD_INCLUDED": 1,
    }


class main_counter_value_t(object):
    """
    Attributes:
     - packets
     - bytes

    """


    def __init__(self, packets=None, bytes=None,):
        self.packets = packets
        self.bytes = bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.packets = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_counter_value_t')
        if self.packets is not None:
            oprot.writeFieldBegin('packets', TType.I64, 1)
            oprot.writeI64(self.packets)
            oprot.writeFieldEnd()
        if self.bytes is not None:
            oprot.writeFieldBegin('bytes', TType.I64, 2)
            oprot.writeI64(self.bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.packets is None:
            raise TProtocolException(message='Required field packets is unset!')
        if self.bytes is None:
            raise TProtocolException(message='Required field bytes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_packets_meter_spec_t(object):
    """
    Attributes:
     - cir_pps
     - cburst_pkts
     - pir_pps
     - pburst_pkts
     - color_aware
     - is_set

    """


    def __init__(self, cir_pps=None, cburst_pkts=None, pir_pps=None, pburst_pkts=None, color_aware=None, is_set=True,):
        self.cir_pps = cir_pps
        self.cburst_pkts = cburst_pkts
        self.pir_pps = pir_pps
        self.pburst_pkts = pburst_pkts
        self.color_aware = color_aware
        self.is_set = is_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cir_pps = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.cburst_pkts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.pir_pps = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.pburst_pkts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.color_aware = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_set = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_packets_meter_spec_t')
        if self.cir_pps is not None:
            oprot.writeFieldBegin('cir_pps', TType.I64, 1)
            oprot.writeI64(self.cir_pps)
            oprot.writeFieldEnd()
        if self.cburst_pkts is not None:
            oprot.writeFieldBegin('cburst_pkts', TType.I64, 2)
            oprot.writeI64(self.cburst_pkts)
            oprot.writeFieldEnd()
        if self.pir_pps is not None:
            oprot.writeFieldBegin('pir_pps', TType.I64, 3)
            oprot.writeI64(self.pir_pps)
            oprot.writeFieldEnd()
        if self.pburst_pkts is not None:
            oprot.writeFieldBegin('pburst_pkts', TType.I64, 4)
            oprot.writeI64(self.pburst_pkts)
            oprot.writeFieldEnd()
        if self.color_aware is not None:
            oprot.writeFieldBegin('color_aware', TType.BOOL, 5)
            oprot.writeBool(self.color_aware)
            oprot.writeFieldEnd()
        if self.is_set is not None:
            oprot.writeFieldBegin('is_set', TType.BOOL, 6)
            oprot.writeBool(self.is_set)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cir_pps is None:
            raise TProtocolException(message='Required field cir_pps is unset!')
        if self.cburst_pkts is None:
            raise TProtocolException(message='Required field cburst_pkts is unset!')
        if self.pir_pps is None:
            raise TProtocolException(message='Required field pir_pps is unset!')
        if self.pburst_pkts is None:
            raise TProtocolException(message='Required field pburst_pkts is unset!')
        if self.color_aware is None:
            raise TProtocolException(message='Required field color_aware is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_bytes_meter_spec_t(object):
    """
    Attributes:
     - cir_kbps
     - cburst_kbits
     - pir_kbps
     - pburst_kbits
     - color_aware
     - is_set

    """


    def __init__(self, cir_kbps=None, cburst_kbits=None, pir_kbps=None, pburst_kbits=None, color_aware=None, is_set=True,):
        self.cir_kbps = cir_kbps
        self.cburst_kbits = cburst_kbits
        self.pir_kbps = pir_kbps
        self.pburst_kbits = pburst_kbits
        self.color_aware = color_aware
        self.is_set = is_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cir_kbps = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.cburst_kbits = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.pir_kbps = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.pburst_kbits = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.color_aware = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_set = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_bytes_meter_spec_t')
        if self.cir_kbps is not None:
            oprot.writeFieldBegin('cir_kbps', TType.I64, 1)
            oprot.writeI64(self.cir_kbps)
            oprot.writeFieldEnd()
        if self.cburst_kbits is not None:
            oprot.writeFieldBegin('cburst_kbits', TType.I64, 2)
            oprot.writeI64(self.cburst_kbits)
            oprot.writeFieldEnd()
        if self.pir_kbps is not None:
            oprot.writeFieldBegin('pir_kbps', TType.I64, 3)
            oprot.writeI64(self.pir_kbps)
            oprot.writeFieldEnd()
        if self.pburst_kbits is not None:
            oprot.writeFieldBegin('pburst_kbits', TType.I64, 4)
            oprot.writeI64(self.pburst_kbits)
            oprot.writeFieldEnd()
        if self.color_aware is not None:
            oprot.writeFieldBegin('color_aware', TType.BOOL, 5)
            oprot.writeBool(self.color_aware)
            oprot.writeFieldEnd()
        if self.is_set is not None:
            oprot.writeFieldBegin('is_set', TType.BOOL, 6)
            oprot.writeBool(self.is_set)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cir_kbps is None:
            raise TProtocolException(message='Required field cir_kbps is unset!')
        if self.cburst_kbits is None:
            raise TProtocolException(message='Required field cburst_kbits is unset!')
        if self.pir_kbps is None:
            raise TProtocolException(message='Required field pir_kbps is unset!')
        if self.pburst_kbits is None:
            raise TProtocolException(message='Required field pburst_kbits is unset!')
        if self.color_aware is None:
            raise TProtocolException(message='Required field color_aware is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_lpf_spec_t(object):
    """
    Attributes:
     - gain_decay_separate_time_constant
     - gain_time_constant
     - decay_time_constant
     - time_constant
     - output_scale_down_factor
     - lpf_type
     - is_set

    """


    def __init__(self, gain_decay_separate_time_constant=None, gain_time_constant=None, decay_time_constant=None, time_constant=None, output_scale_down_factor=None, lpf_type=None, is_set=True,):
        self.gain_decay_separate_time_constant = gain_decay_separate_time_constant
        self.gain_time_constant = gain_time_constant
        self.decay_time_constant = decay_time_constant
        self.time_constant = time_constant
        self.output_scale_down_factor = output_scale_down_factor
        self.lpf_type = lpf_type
        self.is_set = is_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.gain_decay_separate_time_constant = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.gain_time_constant = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.decay_time_constant = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.time_constant = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.output_scale_down_factor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.lpf_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_set = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_lpf_spec_t')
        if self.gain_decay_separate_time_constant is not None:
            oprot.writeFieldBegin('gain_decay_separate_time_constant', TType.BOOL, 1)
            oprot.writeBool(self.gain_decay_separate_time_constant)
            oprot.writeFieldEnd()
        if self.gain_time_constant is not None:
            oprot.writeFieldBegin('gain_time_constant', TType.DOUBLE, 2)
            oprot.writeDouble(self.gain_time_constant)
            oprot.writeFieldEnd()
        if self.decay_time_constant is not None:
            oprot.writeFieldBegin('decay_time_constant', TType.DOUBLE, 3)
            oprot.writeDouble(self.decay_time_constant)
            oprot.writeFieldEnd()
        if self.time_constant is not None:
            oprot.writeFieldBegin('time_constant', TType.DOUBLE, 4)
            oprot.writeDouble(self.time_constant)
            oprot.writeFieldEnd()
        if self.output_scale_down_factor is not None:
            oprot.writeFieldBegin('output_scale_down_factor', TType.I32, 5)
            oprot.writeI32(self.output_scale_down_factor)
            oprot.writeFieldEnd()
        if self.lpf_type is not None:
            oprot.writeFieldBegin('lpf_type', TType.I32, 6)
            oprot.writeI32(self.lpf_type)
            oprot.writeFieldEnd()
        if self.is_set is not None:
            oprot.writeFieldBegin('is_set', TType.BOOL, 7)
            oprot.writeBool(self.is_set)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.gain_decay_separate_time_constant is None:
            raise TProtocolException(message='Required field gain_decay_separate_time_constant is unset!')
        if self.gain_time_constant is None:
            raise TProtocolException(message='Required field gain_time_constant is unset!')
        if self.decay_time_constant is None:
            raise TProtocolException(message='Required field decay_time_constant is unset!')
        if self.time_constant is None:
            raise TProtocolException(message='Required field time_constant is unset!')
        if self.output_scale_down_factor is None:
            raise TProtocolException(message='Required field output_scale_down_factor is unset!')
        if self.lpf_type is None:
            raise TProtocolException(message='Required field lpf_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_wred_spec_t(object):
    """
    Attributes:
     - time_constant
     - red_min_threshold
     - red_max_threshold
     - max_probability
     - is_set

    """


    def __init__(self, time_constant=None, red_min_threshold=None, red_max_threshold=None, max_probability=None, is_set=True,):
        self.time_constant = time_constant
        self.red_min_threshold = red_min_threshold
        self.red_max_threshold = red_max_threshold
        self.max_probability = max_probability
        self.is_set = is_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.time_constant = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.red_min_threshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.red_max_threshold = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.max_probability = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_set = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_wred_spec_t')
        if self.time_constant is not None:
            oprot.writeFieldBegin('time_constant', TType.DOUBLE, 1)
            oprot.writeDouble(self.time_constant)
            oprot.writeFieldEnd()
        if self.red_min_threshold is not None:
            oprot.writeFieldBegin('red_min_threshold', TType.I32, 2)
            oprot.writeI32(self.red_min_threshold)
            oprot.writeFieldEnd()
        if self.red_max_threshold is not None:
            oprot.writeFieldBegin('red_max_threshold', TType.I32, 3)
            oprot.writeI32(self.red_max_threshold)
            oprot.writeFieldEnd()
        if self.max_probability is not None:
            oprot.writeFieldBegin('max_probability', TType.DOUBLE, 4)
            oprot.writeDouble(self.max_probability)
            oprot.writeFieldEnd()
        if self.is_set is not None:
            oprot.writeFieldBegin('is_set', TType.BOOL, 5)
            oprot.writeBool(self.is_set)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.time_constant is None:
            raise TProtocolException(message='Required field time_constant is unset!')
        if self.red_min_threshold is None:
            raise TProtocolException(message='Required field red_min_threshold is unset!')
        if self.red_max_threshold is None:
            raise TProtocolException(message='Required field red_max_threshold is unset!')
        if self.max_probability is None:
            raise TProtocolException(message='Required field max_probability is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_idle_time_params_t(object):
    """
    Attributes:
     - mode
     - ttl_query_interval
     - max_ttl
     - min_ttl
     - cookie

    """


    def __init__(self, mode=None, ttl_query_interval=None, max_ttl=None, min_ttl=None, cookie=None,):
        self.mode = mode
        self.ttl_query_interval = ttl_query_interval
        self.max_ttl = max_ttl
        self.min_ttl = min_ttl
        self.cookie = cookie

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.ttl_query_interval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max_ttl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.min_ttl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.cookie = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_idle_time_params_t')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.ttl_query_interval is not None:
            oprot.writeFieldBegin('ttl_query_interval', TType.I32, 2)
            oprot.writeI32(self.ttl_query_interval)
            oprot.writeFieldEnd()
        if self.max_ttl is not None:
            oprot.writeFieldBegin('max_ttl', TType.I32, 3)
            oprot.writeI32(self.max_ttl)
            oprot.writeFieldEnd()
        if self.min_ttl is not None:
            oprot.writeFieldBegin('min_ttl', TType.I32, 4)
            oprot.writeI32(self.min_ttl)
            oprot.writeFieldEnd()
        if self.cookie is not None:
            oprot.writeFieldBegin('cookie', TType.I32, 5)
            oprot.writeI32(self.cookie)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.mode is None:
            raise TProtocolException(message='Required field mode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_idle_tmo_expired_t(object):
    """
    Attributes:
     - dev_id
     - entry
     - cookie

    """


    def __init__(self, dev_id=None, entry=None, cookie=None,):
        self.dev_id = dev_id
        self.entry = entry
        self.cookie = cookie

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cookie = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_idle_tmo_expired_t')
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 1)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 2)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        if self.cookie is not None:
            oprot.writeFieldBegin('cookie', TType.I32, 3)
            oprot.writeI32(self.cookie)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.dev_id is None:
            raise TProtocolException(message='Required field dev_id is unset!')
        if self.entry is None:
            raise TProtocolException(message='Required field entry is unset!')
        if self.cookie is None:
            raise TProtocolException(message='Required field cookie is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_sel_update_t(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - cookie
     - grp_hdl
     - mbr_hdl
     - index
     - is_add

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, cookie=None, grp_hdl=None, mbr_hdl=None, index=None, is_add=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.cookie = cookie
        self.grp_hdl = grp_hdl
        self.mbr_hdl = mbr_hdl
        self.index = index
        self.is_add = is_add

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.cookie = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.mbr_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_add = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_sel_update_t')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.cookie is not None:
            oprot.writeFieldBegin('cookie', TType.I32, 3)
            oprot.writeI32(self.cookie)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 4)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        if self.mbr_hdl is not None:
            oprot.writeFieldBegin('mbr_hdl', TType.I32, 5)
            oprot.writeI32(self.mbr_hdl)
            oprot.writeFieldEnd()
        if self.index is not None:
            oprot.writeFieldBegin('index', TType.I32, 6)
            oprot.writeI32(self.index)
            oprot.writeFieldEnd()
        if self.is_add is not None:
            oprot.writeFieldBegin('is_add', TType.BOOL, 7)
            oprot.writeBool(self.is_add)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sess_hdl is None:
            raise TProtocolException(message='Required field sess_hdl is unset!')
        if self.dev_tgt is None:
            raise TProtocolException(message='Required field dev_tgt is unset!')
        if self.cookie is None:
            raise TProtocolException(message='Required field cookie is unset!')
        if self.grp_hdl is None:
            raise TProtocolException(message='Required field grp_hdl is unset!')
        if self.mbr_hdl is None:
            raise TProtocolException(message='Required field mbr_hdl is unset!')
        if self.index is None:
            raise TProtocolException(message='Required field index is unset!')
        if self.is_add is None:
            raise TProtocolException(message='Required field is_add is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class tbl_property_value_args_t(object):
    """
    Attributes:
     - value
     - scope_args

    """


    def __init__(self, value=None, scope_args=None,):
        self.value = value
        self.scope_args = scope_args

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.scope_args = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_property_value_args_t')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 1)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.scope_args is not None:
            oprot.writeFieldBegin('scope_args', TType.I32, 2)
            oprot.writeI32(self.scope_args)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        if self.scope_args is None:
            raise TProtocolException(message='Required field scope_args is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PVSSpec_t(object):
    """
    Attributes:
     - parser_value
     - parser_value_mask

    """


    def __init__(self, parser_value=None, parser_value_mask=None,):
        self.parser_value = parser_value
        self.parser_value_mask = parser_value_mask

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.parser_value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.parser_value_mask = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PVSSpec_t')
        if self.parser_value is not None:
            oprot.writeFieldBegin('parser_value', TType.I32, 1)
            oprot.writeI32(self.parser_value)
            oprot.writeFieldEnd()
        if self.parser_value_mask is not None:
            oprot.writeFieldBegin('parser_value_mask', TType.I32, 2)
            oprot.writeI32(self.parser_value_mask)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.parser_value is None:
            raise TProtocolException(message='Required field parser_value is unset!')
        if self.parser_value_mask is None:
            raise TProtocolException(message='Required field parser_value_mask is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TblCntrInfo_t(object):
    """
    Attributes:
     - type
     - value

    """


    def __init__(self, type=None, value=None,):
        self.type = type
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TblCntrInfo_t')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TblDbgStageInfo_t(object):
    """
    Attributes:
     - num_counters
     - tbl_name
     - type
     - value

    """


    def __init__(self, num_counters=None, tbl_name=None, type=None, value=None,):
        self.num_counters = num_counters
        self.tbl_name = tbl_name
        self.type = type
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_counters = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tbl_name = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tbl_name.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.type = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readI32()
                        self.type.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.value = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readI32()
                        self.value.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TblDbgStageInfo_t')
        if self.num_counters is not None:
            oprot.writeFieldBegin('num_counters', TType.I32, 1)
            oprot.writeI32(self.num_counters)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tbl_name))
            for iter18 in self.tbl_name:
                oprot.writeString(iter18.encode('utf-8') if sys.version_info[0] == 2 else iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.type))
            for iter19 in self.type:
                oprot.writeI32(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.value))
            for iter20 in self.value:
                oprot.writeI32(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_counters is None:
            raise TProtocolException(message='Required field num_counters is unset!')
        if self.tbl_name is None:
            raise TProtocolException(message='Required field tbl_name is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_counter_flags_t(object):
    """
    Attributes:
     - read_hw_sync

    """


    def __init__(self, read_hw_sync=None,):
        self.read_hw_sync = read_hw_sync

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.read_hw_sync = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_counter_flags_t')
        if self.read_hw_sync is not None:
            oprot.writeFieldBegin('read_hw_sync', TType.BOOL, 1)
            oprot.writeBool(self.read_hw_sync)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.read_hw_sync is None:
            raise TProtocolException(message='Required field read_hw_sync is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_register_flags_t(object):
    """
    Attributes:
     - read_hw_sync

    """


    def __init__(self, read_hw_sync=None,):
        self.read_hw_sync = read_hw_sync

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.read_hw_sync = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_register_flags_t')
        if self.read_hw_sync is not None:
            oprot.writeFieldBegin('read_hw_sync', TType.BOOL, 1)
            oprot.writeBool(self.read_hw_sync)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.read_hw_sync is None:
            raise TProtocolException(message='Required field read_hw_sync is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_snapshot_trig_spec_t(object):
    """
    Attributes:
     - field_name
     - field_value
     - field_mask

    """


    def __init__(self, field_name=None, field_value=None, field_mask=None,):
        self.field_name = field_name
        self.field_value = field_value
        self.field_mask = field_mask

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.field_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.field_value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.field_mask = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_snapshot_trig_spec_t')
        if self.field_name is not None:
            oprot.writeFieldBegin('field_name', TType.STRING, 1)
            oprot.writeString(self.field_name.encode('utf-8') if sys.version_info[0] == 2 else self.field_name)
            oprot.writeFieldEnd()
        if self.field_value is not None:
            oprot.writeFieldBegin('field_value', TType.I64, 2)
            oprot.writeI64(self.field_value)
            oprot.writeFieldEnd()
        if self.field_mask is not None:
            oprot.writeFieldBegin('field_mask', TType.I64, 3)
            oprot.writeI64(self.field_mask)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.field_name is None:
            raise TProtocolException(message='Required field field_name is unset!')
        if self.field_value is None:
            raise TProtocolException(message='Required field field_value is unset!')
        if self.field_mask is None:
            raise TProtocolException(message='Required field field_mask is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_snapshot_tbl_data_t(object):
    """
    Attributes:
     - hit
     - inhibited
     - executed
     - hit_entry_handle

    """


    def __init__(self, hit=None, inhibited=None, executed=None, hit_entry_handle=None,):
        self.hit = hit
        self.inhibited = inhibited
        self.executed = executed
        self.hit_entry_handle = hit_entry_handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.hit = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.inhibited = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.executed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.hit_entry_handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_snapshot_tbl_data_t')
        if self.hit is not None:
            oprot.writeFieldBegin('hit', TType.BOOL, 1)
            oprot.writeBool(self.hit)
            oprot.writeFieldEnd()
        if self.inhibited is not None:
            oprot.writeFieldBegin('inhibited', TType.BOOL, 2)
            oprot.writeBool(self.inhibited)
            oprot.writeFieldEnd()
        if self.executed is not None:
            oprot.writeFieldBegin('executed', TType.BOOL, 3)
            oprot.writeBool(self.executed)
            oprot.writeFieldEnd()
        if self.hit_entry_handle is not None:
            oprot.writeFieldBegin('hit_entry_handle', TType.I32, 4)
            oprot.writeI32(self.hit_entry_handle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hit is None:
            raise TProtocolException(message='Required field hit is unset!')
        if self.inhibited is None:
            raise TProtocolException(message='Required field inhibited is unset!')
        if self.executed is None:
            raise TProtocolException(message='Required field executed is unset!')
        if self.hit_entry_handle is None:
            raise TProtocolException(message='Required field hit_entry_handle is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_firewall_table_match_spec_t(object):
    """
    Attributes:
     - ipv4_srcAddr
     - ipv4_dstAddr
     - tcp_udp_srcPort
     - tcp_udp_dstPort

    """


    def __init__(self, ipv4_srcAddr=None, ipv4_dstAddr=None, tcp_udp_srcPort=None, tcp_udp_dstPort=None,):
        self.ipv4_srcAddr = ipv4_srcAddr
        self.ipv4_dstAddr = ipv4_dstAddr
        self.tcp_udp_srcPort = tcp_udp_srcPort
        self.tcp_udp_dstPort = tcp_udp_dstPort

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.ipv4_srcAddr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.ipv4_dstAddr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.tcp_udp_srcPort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.tcp_udp_dstPort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_firewall_table_match_spec_t')
        if self.ipv4_srcAddr is not None:
            oprot.writeFieldBegin('ipv4_srcAddr', TType.I32, 1)
            oprot.writeI32(self.ipv4_srcAddr)
            oprot.writeFieldEnd()
        if self.ipv4_dstAddr is not None:
            oprot.writeFieldBegin('ipv4_dstAddr', TType.I32, 2)
            oprot.writeI32(self.ipv4_dstAddr)
            oprot.writeFieldEnd()
        if self.tcp_udp_srcPort is not None:
            oprot.writeFieldBegin('tcp_udp_srcPort', TType.I16, 3)
            oprot.writeI16(self.tcp_udp_srcPort)
            oprot.writeFieldEnd()
        if self.tcp_udp_dstPort is not None:
            oprot.writeFieldBegin('tcp_udp_dstPort', TType.I16, 4)
            oprot.writeI16(self.tcp_udp_dstPort)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ipv4_srcAddr is None:
            raise TProtocolException(message='Required field ipv4_srcAddr is unset!')
        if self.ipv4_dstAddr is None:
            raise TProtocolException(message='Required field ipv4_dstAddr is unset!')
        if self.tcp_udp_srcPort is None:
            raise TProtocolException(message='Required field tcp_udp_srcPort is unset!')
        if self.tcp_udp_dstPort is None:
            raise TProtocolException(message='Required field tcp_udp_dstPort is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_forward_table_match_spec_t(object):
    """
    Attributes:
     - ig_intr_md_ingress_port

    """


    def __init__(self, ig_intr_md_ingress_port=None,):
        self.ig_intr_md_ingress_port = ig_intr_md_ingress_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.ig_intr_md_ingress_port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_forward_table_match_spec_t')
        if self.ig_intr_md_ingress_port is not None:
            oprot.writeFieldBegin('ig_intr_md_ingress_port', TType.I16, 1)
            oprot.writeI16(self.ig_intr_md_ingress_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ig_intr_md_ingress_port is None:
            raise TProtocolException(message='Required field ig_intr_md_ingress_port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_forward_table_by_dst_ip_match_spec_t(object):
    """
    Attributes:
     - ipv4_dstAddr

    """


    def __init__(self, ipv4_dstAddr=None,):
        self.ipv4_dstAddr = ipv4_dstAddr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.ipv4_dstAddr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_forward_table_by_dst_ip_match_spec_t')
        if self.ipv4_dstAddr is not None:
            oprot.writeFieldBegin('ipv4_dstAddr', TType.I32, 1)
            oprot.writeI32(self.ipv4_dstAddr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ipv4_dstAddr is None:
            raise TProtocolException(message='Required field ipv4_dstAddr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_state_check_table_match_spec_t(object):
    """
    Attributes:
     - ipv4_srcAddr
     - ipv4_dstAddr
     - tcp_udp_srcPort
     - tcp_udp_dstPort
     - tcp_ack
     - tcp_rst
     - tcp_syn
     - tcp_fin

    """


    def __init__(self, ipv4_srcAddr=None, ipv4_dstAddr=None, tcp_udp_srcPort=None, tcp_udp_dstPort=None, tcp_ack=None, tcp_rst=None, tcp_syn=None, tcp_fin=None,):
        self.ipv4_srcAddr = ipv4_srcAddr
        self.ipv4_dstAddr = ipv4_dstAddr
        self.tcp_udp_srcPort = tcp_udp_srcPort
        self.tcp_udp_dstPort = tcp_udp_dstPort
        self.tcp_ack = tcp_ack
        self.tcp_rst = tcp_rst
        self.tcp_syn = tcp_syn
        self.tcp_fin = tcp_fin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.ipv4_srcAddr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.ipv4_dstAddr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.tcp_udp_srcPort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.tcp_udp_dstPort = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BYTE:
                    self.tcp_ack = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.tcp_rst = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BYTE:
                    self.tcp_syn = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BYTE:
                    self.tcp_fin = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_state_check_table_match_spec_t')
        if self.ipv4_srcAddr is not None:
            oprot.writeFieldBegin('ipv4_srcAddr', TType.I32, 1)
            oprot.writeI32(self.ipv4_srcAddr)
            oprot.writeFieldEnd()
        if self.ipv4_dstAddr is not None:
            oprot.writeFieldBegin('ipv4_dstAddr', TType.I32, 2)
            oprot.writeI32(self.ipv4_dstAddr)
            oprot.writeFieldEnd()
        if self.tcp_udp_srcPort is not None:
            oprot.writeFieldBegin('tcp_udp_srcPort', TType.I16, 3)
            oprot.writeI16(self.tcp_udp_srcPort)
            oprot.writeFieldEnd()
        if self.tcp_udp_dstPort is not None:
            oprot.writeFieldBegin('tcp_udp_dstPort', TType.I16, 4)
            oprot.writeI16(self.tcp_udp_dstPort)
            oprot.writeFieldEnd()
        if self.tcp_ack is not None:
            oprot.writeFieldBegin('tcp_ack', TType.BYTE, 5)
            oprot.writeByte(self.tcp_ack)
            oprot.writeFieldEnd()
        if self.tcp_rst is not None:
            oprot.writeFieldBegin('tcp_rst', TType.BYTE, 6)
            oprot.writeByte(self.tcp_rst)
            oprot.writeFieldEnd()
        if self.tcp_syn is not None:
            oprot.writeFieldBegin('tcp_syn', TType.BYTE, 7)
            oprot.writeByte(self.tcp_syn)
            oprot.writeFieldEnd()
        if self.tcp_fin is not None:
            oprot.writeFieldBegin('tcp_fin', TType.BYTE, 8)
            oprot.writeByte(self.tcp_fin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ipv4_srcAddr is None:
            raise TProtocolException(message='Required field ipv4_srcAddr is unset!')
        if self.ipv4_dstAddr is None:
            raise TProtocolException(message='Required field ipv4_dstAddr is unset!')
        if self.tcp_udp_srcPort is None:
            raise TProtocolException(message='Required field tcp_udp_srcPort is unset!')
        if self.tcp_udp_dstPort is None:
            raise TProtocolException(message='Required field tcp_udp_dstPort is unset!')
        if self.tcp_ack is None:
            raise TProtocolException(message='Required field tcp_ack is unset!')
        if self.tcp_rst is None:
            raise TProtocolException(message='Required field tcp_rst is unset!')
        if self.tcp_syn is None:
            raise TProtocolException(message='Required field tcp_syn is unset!')
        if self.tcp_fin is None:
            raise TProtocolException(message='Required field tcp_fin is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_forward_hit_action_spec_t(object):
    """
    Attributes:
     - action_port

    """


    def __init__(self, action_port=None,):
        self.action_port = action_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.action_port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_forward_hit_action_spec_t')
        if self.action_port is not None:
            oprot.writeFieldBegin('action_port', TType.I16, 1)
            oprot.writeI16(self.action_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.action_port is None:
            raise TProtocolException(message='Required field action_port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_forward_ip_hit_action_spec_t(object):
    """
    Attributes:
     - action_port

    """


    def __init__(self, action_port=None,):
        self.action_port = action_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.action_port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_forward_ip_hit_action_spec_t')
        if self.action_port is not None:
            oprot.writeFieldBegin('action_port', TType.I16, 1)
            oprot.writeI16(self.action_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.action_port is None:
            raise TProtocolException(message='Required field action_port is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_action_specs_t(object):
    """
    Attributes:
     - main_forward_hit
     - main_forward_ip_hit

    """


    def __init__(self, main_forward_hit=None, main_forward_ip_hit=None,):
        self.main_forward_hit = main_forward_hit
        self.main_forward_ip_hit = main_forward_ip_hit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.main_forward_hit = main_forward_hit_action_spec_t()
                    self.main_forward_hit.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.main_forward_ip_hit = main_forward_ip_hit_action_spec_t()
                    self.main_forward_ip_hit.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_action_specs_t')
        if self.main_forward_hit is not None:
            oprot.writeFieldBegin('main_forward_hit', TType.STRUCT, 1)
            self.main_forward_hit.write(oprot)
            oprot.writeFieldEnd()
        if self.main_forward_ip_hit is not None:
            oprot.writeFieldBegin('main_forward_ip_hit', TType.STRUCT, 2)
            self.main_forward_ip_hit.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_action_desc_t(object):
    """
    Attributes:
     - name
     - data

    """


    def __init__(self, name=None, data=None,):
        self.name = name
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.data = main_action_specs_t()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_action_desc_t')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRUCT, 2)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.data is None:
            raise TProtocolException(message='Required field data is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_firewall_table_entry_desc_t(object):
    """
    Attributes:
     - match_spec
     - has_mbr_hdl
     - has_grp_hdl
     - selector_grp_hdl
     - action_mbr_hdl
     - action_desc

    """


    def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
        self.match_spec = match_spec
        self.has_mbr_hdl = has_mbr_hdl
        self.has_grp_hdl = has_grp_hdl
        self.selector_grp_hdl = selector_grp_hdl
        self.action_mbr_hdl = action_mbr_hdl
        self.action_desc = action_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_mbr_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.has_grp_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.selector_grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.action_mbr_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.action_desc = main_action_desc_t()
                    self.action_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_firewall_table_entry_desc_t')
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.has_mbr_hdl is not None:
            oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
            oprot.writeBool(self.has_mbr_hdl)
            oprot.writeFieldEnd()
        if self.has_grp_hdl is not None:
            oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
            oprot.writeBool(self.has_grp_hdl)
            oprot.writeFieldEnd()
        if self.selector_grp_hdl is not None:
            oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
            oprot.writeI32(self.selector_grp_hdl)
            oprot.writeFieldEnd()
        if self.action_mbr_hdl is not None:
            oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
            oprot.writeI32(self.action_mbr_hdl)
            oprot.writeFieldEnd()
        if self.action_desc is not None:
            oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
            self.action_desc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.match_spec is None:
            raise TProtocolException(message='Required field match_spec is unset!')
        if self.has_mbr_hdl is None:
            raise TProtocolException(message='Required field has_mbr_hdl is unset!')
        if self.has_grp_hdl is None:
            raise TProtocolException(message='Required field has_grp_hdl is unset!')
        if self.selector_grp_hdl is None:
            raise TProtocolException(message='Required field selector_grp_hdl is unset!')
        if self.action_mbr_hdl is None:
            raise TProtocolException(message='Required field action_mbr_hdl is unset!')
        if self.action_desc is None:
            raise TProtocolException(message='Required field action_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_forward_table_entry_desc_t(object):
    """
    Attributes:
     - match_spec
     - has_mbr_hdl
     - has_grp_hdl
     - selector_grp_hdl
     - action_mbr_hdl
     - action_desc

    """


    def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
        self.match_spec = match_spec
        self.has_mbr_hdl = has_mbr_hdl
        self.has_grp_hdl = has_grp_hdl
        self.selector_grp_hdl = selector_grp_hdl
        self.action_mbr_hdl = action_mbr_hdl
        self.action_desc = action_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_mbr_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.has_grp_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.selector_grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.action_mbr_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.action_desc = main_action_desc_t()
                    self.action_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_forward_table_entry_desc_t')
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.has_mbr_hdl is not None:
            oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
            oprot.writeBool(self.has_mbr_hdl)
            oprot.writeFieldEnd()
        if self.has_grp_hdl is not None:
            oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
            oprot.writeBool(self.has_grp_hdl)
            oprot.writeFieldEnd()
        if self.selector_grp_hdl is not None:
            oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
            oprot.writeI32(self.selector_grp_hdl)
            oprot.writeFieldEnd()
        if self.action_mbr_hdl is not None:
            oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
            oprot.writeI32(self.action_mbr_hdl)
            oprot.writeFieldEnd()
        if self.action_desc is not None:
            oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
            self.action_desc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.match_spec is None:
            raise TProtocolException(message='Required field match_spec is unset!')
        if self.has_mbr_hdl is None:
            raise TProtocolException(message='Required field has_mbr_hdl is unset!')
        if self.has_grp_hdl is None:
            raise TProtocolException(message='Required field has_grp_hdl is unset!')
        if self.selector_grp_hdl is None:
            raise TProtocolException(message='Required field selector_grp_hdl is unset!')
        if self.action_mbr_hdl is None:
            raise TProtocolException(message='Required field action_mbr_hdl is unset!')
        if self.action_desc is None:
            raise TProtocolException(message='Required field action_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_forward_table_by_dst_ip_entry_desc_t(object):
    """
    Attributes:
     - match_spec
     - has_mbr_hdl
     - has_grp_hdl
     - selector_grp_hdl
     - action_mbr_hdl
     - action_desc

    """


    def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
        self.match_spec = match_spec
        self.has_mbr_hdl = has_mbr_hdl
        self.has_grp_hdl = has_grp_hdl
        self.selector_grp_hdl = selector_grp_hdl
        self.action_mbr_hdl = action_mbr_hdl
        self.action_desc = action_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_mbr_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.has_grp_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.selector_grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.action_mbr_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.action_desc = main_action_desc_t()
                    self.action_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_forward_table_by_dst_ip_entry_desc_t')
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.has_mbr_hdl is not None:
            oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
            oprot.writeBool(self.has_mbr_hdl)
            oprot.writeFieldEnd()
        if self.has_grp_hdl is not None:
            oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
            oprot.writeBool(self.has_grp_hdl)
            oprot.writeFieldEnd()
        if self.selector_grp_hdl is not None:
            oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
            oprot.writeI32(self.selector_grp_hdl)
            oprot.writeFieldEnd()
        if self.action_mbr_hdl is not None:
            oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
            oprot.writeI32(self.action_mbr_hdl)
            oprot.writeFieldEnd()
        if self.action_desc is not None:
            oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
            self.action_desc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.match_spec is None:
            raise TProtocolException(message='Required field match_spec is unset!')
        if self.has_mbr_hdl is None:
            raise TProtocolException(message='Required field has_mbr_hdl is unset!')
        if self.has_grp_hdl is None:
            raise TProtocolException(message='Required field has_grp_hdl is unset!')
        if self.selector_grp_hdl is None:
            raise TProtocolException(message='Required field selector_grp_hdl is unset!')
        if self.action_mbr_hdl is None:
            raise TProtocolException(message='Required field action_mbr_hdl is unset!')
        if self.action_desc is None:
            raise TProtocolException(message='Required field action_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class main_state_check_table_entry_desc_t(object):
    """
    Attributes:
     - match_spec
     - has_mbr_hdl
     - has_grp_hdl
     - selector_grp_hdl
     - action_mbr_hdl
     - action_desc

    """


    def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
        self.match_spec = match_spec
        self.has_mbr_hdl = has_mbr_hdl
        self.has_grp_hdl = has_grp_hdl
        self.selector_grp_hdl = selector_grp_hdl
        self.action_mbr_hdl = action_mbr_hdl
        self.action_desc = action_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_mbr_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.has_grp_hdl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.selector_grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.action_mbr_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.action_desc = main_action_desc_t()
                    self.action_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('main_state_check_table_entry_desc_t')
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.has_mbr_hdl is not None:
            oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
            oprot.writeBool(self.has_mbr_hdl)
            oprot.writeFieldEnd()
        if self.has_grp_hdl is not None:
            oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
            oprot.writeBool(self.has_grp_hdl)
            oprot.writeFieldEnd()
        if self.selector_grp_hdl is not None:
            oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
            oprot.writeI32(self.selector_grp_hdl)
            oprot.writeFieldEnd()
        if self.action_mbr_hdl is not None:
            oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
            oprot.writeI32(self.action_mbr_hdl)
            oprot.writeFieldEnd()
        if self.action_desc is not None:
            oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
            self.action_desc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.match_spec is None:
            raise TProtocolException(message='Required field match_spec is unset!')
        if self.has_mbr_hdl is None:
            raise TProtocolException(message='Required field has_mbr_hdl is unset!')
        if self.has_grp_hdl is None:
            raise TProtocolException(message='Required field has_grp_hdl is unset!')
        if self.selector_grp_hdl is None:
            raise TProtocolException(message='Required field selector_grp_hdl is unset!')
        if self.action_mbr_hdl is None:
            raise TProtocolException(message='Required field action_mbr_hdl is unset!')
        if self.action_desc is None:
            raise TProtocolException(message='Required field action_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidTableOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidTableOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidTableOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidLearnOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidLearnOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidLearnOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidDbgOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidDbgOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidDbgOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidSnapshotOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidSnapshotOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidSnapshotOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidCounterOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidCounterOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidCounterOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidRegisterOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidRegisterOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidRegisterOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidMeterOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidMeterOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidMeterOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidLPFOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidLPFOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidLPFOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidWREDOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidWREDOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidWREDOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(main_counter_value_t)
main_counter_value_t.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'packets', None, None, ),  # 1
    (2, TType.I64, 'bytes', None, None, ),  # 2
)
all_structs.append(main_packets_meter_spec_t)
main_packets_meter_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cir_pps', None, None, ),  # 1
    (2, TType.I64, 'cburst_pkts', None, None, ),  # 2
    (3, TType.I64, 'pir_pps', None, None, ),  # 3
    (4, TType.I64, 'pburst_pkts', None, None, ),  # 4
    (5, TType.BOOL, 'color_aware', None, None, ),  # 5
    (6, TType.BOOL, 'is_set', None, True, ),  # 6
)
all_structs.append(main_bytes_meter_spec_t)
main_bytes_meter_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cir_kbps', None, None, ),  # 1
    (2, TType.I64, 'cburst_kbits', None, None, ),  # 2
    (3, TType.I64, 'pir_kbps', None, None, ),  # 3
    (4, TType.I64, 'pburst_kbits', None, None, ),  # 4
    (5, TType.BOOL, 'color_aware', None, None, ),  # 5
    (6, TType.BOOL, 'is_set', None, True, ),  # 6
)
all_structs.append(main_lpf_spec_t)
main_lpf_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'gain_decay_separate_time_constant', None, None, ),  # 1
    (2, TType.DOUBLE, 'gain_time_constant', None, None, ),  # 2
    (3, TType.DOUBLE, 'decay_time_constant', None, None, ),  # 3
    (4, TType.DOUBLE, 'time_constant', None, None, ),  # 4
    (5, TType.I32, 'output_scale_down_factor', None, None, ),  # 5
    (6, TType.I32, 'lpf_type', None, None, ),  # 6
    (7, TType.BOOL, 'is_set', None, True, ),  # 7
)
all_structs.append(main_wred_spec_t)
main_wred_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'time_constant', None, None, ),  # 1
    (2, TType.I32, 'red_min_threshold', None, None, ),  # 2
    (3, TType.I32, 'red_max_threshold', None, None, ),  # 3
    (4, TType.DOUBLE, 'max_probability', None, None, ),  # 4
    (5, TType.BOOL, 'is_set', None, True, ),  # 5
)
all_structs.append(main_idle_time_params_t)
main_idle_time_params_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
    (2, TType.I32, 'ttl_query_interval', None, None, ),  # 2
    (3, TType.I32, 'max_ttl', None, None, ),  # 3
    (4, TType.I32, 'min_ttl', None, None, ),  # 4
    (5, TType.I32, 'cookie', None, None, ),  # 5
)
all_structs.append(main_idle_tmo_expired_t)
main_idle_tmo_expired_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev_id', None, None, ),  # 1
    (2, TType.I32, 'entry', None, None, ),  # 2
    (3, TType.I32, 'cookie', None, None, ),  # 3
)
all_structs.append(main_sel_update_t)
main_sel_update_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'cookie', None, None, ),  # 3
    (4, TType.I32, 'grp_hdl', None, None, ),  # 4
    (5, TType.I32, 'mbr_hdl', None, None, ),  # 5
    (6, TType.I32, 'index', None, None, ),  # 6
    (7, TType.BOOL, 'is_add', None, None, ),  # 7
)
all_structs.append(tbl_property_value_args_t)
tbl_property_value_args_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'value', None, None, ),  # 1
    (2, TType.I32, 'scope_args', None, None, ),  # 2
)
all_structs.append(PVSSpec_t)
PVSSpec_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'parser_value', None, None, ),  # 1
    (2, TType.I32, 'parser_value_mask', None, None, ),  # 2
)
all_structs.append(TblCntrInfo_t)
TblCntrInfo_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)
all_structs.append(TblDbgStageInfo_t)
TblDbgStageInfo_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_counters', None, None, ),  # 1
    (2, TType.LIST, 'tbl_name', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'type', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'value', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(main_counter_flags_t)
main_counter_flags_t.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'read_hw_sync', None, None, ),  # 1
)
all_structs.append(main_register_flags_t)
main_register_flags_t.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'read_hw_sync', None, None, ),  # 1
)
all_structs.append(main_snapshot_trig_spec_t)
main_snapshot_trig_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'field_name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'field_value', None, None, ),  # 2
    (3, TType.I64, 'field_mask', None, None, ),  # 3
)
all_structs.append(main_snapshot_tbl_data_t)
main_snapshot_tbl_data_t.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'hit', None, None, ),  # 1
    (2, TType.BOOL, 'inhibited', None, None, ),  # 2
    (3, TType.BOOL, 'executed', None, None, ),  # 3
    (4, TType.I32, 'hit_entry_handle', None, None, ),  # 4
)
all_structs.append(main_firewall_table_match_spec_t)
main_firewall_table_match_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'ipv4_srcAddr', None, None, ),  # 1
    (2, TType.I32, 'ipv4_dstAddr', None, None, ),  # 2
    (3, TType.I16, 'tcp_udp_srcPort', None, None, ),  # 3
    (4, TType.I16, 'tcp_udp_dstPort', None, None, ),  # 4
)
all_structs.append(main_forward_table_match_spec_t)
main_forward_table_match_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'ig_intr_md_ingress_port', None, None, ),  # 1
)
all_structs.append(main_forward_table_by_dst_ip_match_spec_t)
main_forward_table_by_dst_ip_match_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'ipv4_dstAddr', None, None, ),  # 1
)
all_structs.append(main_state_check_table_match_spec_t)
main_state_check_table_match_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'ipv4_srcAddr', None, None, ),  # 1
    (2, TType.I32, 'ipv4_dstAddr', None, None, ),  # 2
    (3, TType.I16, 'tcp_udp_srcPort', None, None, ),  # 3
    (4, TType.I16, 'tcp_udp_dstPort', None, None, ),  # 4
    (5, TType.BYTE, 'tcp_ack', None, None, ),  # 5
    (6, TType.BYTE, 'tcp_rst', None, None, ),  # 6
    (7, TType.BYTE, 'tcp_syn', None, None, ),  # 7
    (8, TType.BYTE, 'tcp_fin', None, None, ),  # 8
)
all_structs.append(main_forward_hit_action_spec_t)
main_forward_hit_action_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'action_port', None, None, ),  # 1
)
all_structs.append(main_forward_ip_hit_action_spec_t)
main_forward_ip_hit_action_spec_t.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'action_port', None, None, ),  # 1
)
all_structs.append(main_action_specs_t)
main_action_specs_t.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'main_forward_hit', [main_forward_hit_action_spec_t, None], None, ),  # 1
    (2, TType.STRUCT, 'main_forward_ip_hit', [main_forward_ip_hit_action_spec_t, None], None, ),  # 2
)
all_structs.append(main_action_desc_t)
main_action_desc_t.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'data', [main_action_specs_t, None], None, ),  # 2
)
all_structs.append(main_firewall_table_entry_desc_t)
main_firewall_table_entry_desc_t.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ),  # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ),  # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ),  # 5
    (6, TType.STRUCT, 'action_desc', [main_action_desc_t, None], None, ),  # 6
)
all_structs.append(main_forward_table_entry_desc_t)
main_forward_table_entry_desc_t.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ),  # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ),  # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ),  # 5
    (6, TType.STRUCT, 'action_desc', [main_action_desc_t, None], None, ),  # 6
)
all_structs.append(main_forward_table_by_dst_ip_entry_desc_t)
main_forward_table_by_dst_ip_entry_desc_t.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ),  # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ),  # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ),  # 5
    (6, TType.STRUCT, 'action_desc', [main_action_desc_t, None], None, ),  # 6
)
all_structs.append(main_state_check_table_entry_desc_t)
main_state_check_table_entry_desc_t.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ),  # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ),  # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ),  # 5
    (6, TType.STRUCT, 'action_desc', [main_action_desc_t, None], None, ),  # 6
)
all_structs.append(InvalidTableOperation)
InvalidTableOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidLearnOperation)
InvalidLearnOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidDbgOperation)
InvalidDbgOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidSnapshotOperation)
InvalidSnapshotOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidCounterOperation)
InvalidCounterOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidRegisterOperation)
InvalidRegisterOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidMeterOperation)
InvalidMeterOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidLPFOperation)
InvalidLPFOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidWREDOperation)
InvalidWREDOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
fix_spec(all_structs)
del all_structs
