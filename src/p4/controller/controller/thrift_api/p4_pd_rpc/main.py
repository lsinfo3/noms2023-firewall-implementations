#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def firewall_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_by_dst_ip_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def firewall_table_table_add_with_firewall_allow_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def firewall_table_table_add_with_firewall_drop_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_table_add_with_forward_hit(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        pass

    def forward_table_table_add_with_forward_miss(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_by_dst_ip_table_add_with_forward_ip_hit(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        pass

    def forward_table_by_dst_ip_table_add_with_forward_ip_miss(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_add_with_state_check_allow_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_add_with_state_check_to_controller_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_add_with_state_check_drop_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def firewall_table_table_modify_with_firewall_allow_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def firewall_table_table_modify_with_firewall_allow_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def firewall_table_table_modify_with_firewall_drop_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def firewall_table_table_modify_with_firewall_drop_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_table_modify_with_forward_hit(self, sess_hdl, dev_id, entry, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry
         - action_spec

        """
        pass

    def forward_table_table_modify_with_forward_hit_by_match_spec(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        pass

    def forward_table_table_modify_with_forward_miss(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def forward_table_table_modify_with_forward_miss_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_by_dst_ip_table_modify_with_forward_ip_hit(self, sess_hdl, dev_id, entry, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry
         - action_spec

        """
        pass

    def forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        pass

    def forward_table_by_dst_ip_table_modify_with_forward_ip_miss(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_modify_with_state_check_allow_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def state_check_table_table_modify_with_state_check_allow_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_modify_with_state_check_to_controller_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_modify_with_state_check_drop_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def state_check_table_table_modify_with_state_check_drop_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def firewall_table_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def firewall_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def forward_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def forward_table_by_dst_ip_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def forward_table_by_dst_ip_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def state_check_table_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        pass

    def state_check_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        pass

    def firewall_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def firewall_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        pass

    def forward_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        pass

    def forward_table_by_dst_ip_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_by_dst_ip_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        pass

    def state_check_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def state_check_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        pass

    def firewall_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_by_dst_ip_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def state_check_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def firewall_table_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_by_dst_ip_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def state_check_table_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def firewall_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def firewall_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        pass

    def firewall_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        pass

    def forward_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        pass

    def forward_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        pass

    def forward_table_by_dst_ip_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_by_dst_ip_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        pass

    def forward_table_by_dst_ip_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        pass

    def state_check_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def state_check_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        pass

    def state_check_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        pass

    def firewall_table_set_default_action_firewall_drop_action(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_set_default_action_forward_miss(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def forward_table_by_dst_ip_set_default_action_forward_ip_miss(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def state_check_table_set_default_action_state_check_drop_action(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def firewall_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        pass

    def firewall_table_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        pass

    def forward_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        pass

    def forward_table_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        pass

    def forward_table_by_dst_ip_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        pass

    def forward_table_by_dst_ip_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        pass

    def state_check_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        pass

    def state_check_table_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        pass

    def set_learning_timeout(self, sess_hdl, dev_id, usecs):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - usecs

        """
        pass

    def tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
        """
        Parameters:
         - dev_tgt
         - tbl_name
         - type

        """
        pass

    def tbl_dbg_counter_get(self, dev_tgt, tbl_name):
        """
        Parameters:
         - dev_tgt
         - tbl_name

        """
        pass

    def tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
        """
        Parameters:
         - dev_tgt
         - tbl_name

        """
        pass

    def tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
        """
        Parameters:
         - dev_tgt
         - stage
         - type

        """
        pass

    def tbl_dbg_counter_stage_get(self, dev_tgt, stage):
        """
        Parameters:
         - dev_tgt
         - stage

        """
        pass

    def tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
        """
        Parameters:
         - dev_tgt
         - stage

        """
        pass

    def snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
        """
        Parameters:
         - dev_tgt
         - start_stage
         - end_stage
         - direction

        """
        pass

    def snapshot_delete(self, handle):
        """
        Parameters:
         - handle

        """
        pass

    def snapshot_state_set(self, handle, state, usecs):
        """
        Parameters:
         - handle
         - state
         - usecs

        """
        pass

    def snapshot_state_get(self, handle, pipe):
        """
        Parameters:
         - handle
         - pipe

        """
        pass

    def snapshot_timer_enable(self, handle, disable):
        """
        Parameters:
         - handle
         - disable

        """
        pass

    def snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
        """
        Parameters:
         - handle
         - trig_spec
         - trig_spec2

        """
        pass

    def snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
        """
        Parameters:
         - handle
         - pipe
         - stage_id
         - field_name

        """
        pass

    def snapshot_capture_tbl_data_get(self, handle, pipe, table_name):
        """
        Parameters:
         - handle
         - pipe
         - table_name

        """
        pass

    def snapshot_capture_trigger_fields_clr(self, handle):
        """
        Parameters:
         - handle

        """
        pass

    def snapshot_field_in_scope(self, dev_tgt, stage, direction, field_name):
        """
        Parameters:
         - dev_tgt
         - stage
         - direction
         - field_name

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def firewall_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_firewall_table_match_spec_to_entry_hdl(sess_hdl, dev_tgt, match_spec)
        return self.recv_firewall_table_match_spec_to_entry_hdl()

    def send_firewall_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('firewall_table_match_spec_to_entry_hdl', TMessageType.CALL, self._seqid)
        args = firewall_table_match_spec_to_entry_hdl_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_match_spec_to_entry_hdl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_match_spec_to_entry_hdl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_match_spec_to_entry_hdl failed: unknown result")

    def forward_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_match_spec_to_entry_hdl(sess_hdl, dev_tgt, match_spec)
        return self.recv_forward_table_match_spec_to_entry_hdl()

    def send_forward_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_match_spec_to_entry_hdl', TMessageType.CALL, self._seqid)
        args = forward_table_match_spec_to_entry_hdl_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_match_spec_to_entry_hdl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_match_spec_to_entry_hdl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_match_spec_to_entry_hdl failed: unknown result")

    def forward_table_by_dst_ip_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_by_dst_ip_match_spec_to_entry_hdl(sess_hdl, dev_tgt, match_spec)
        return self.recv_forward_table_by_dst_ip_match_spec_to_entry_hdl()

    def send_forward_table_by_dst_ip_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_match_spec_to_entry_hdl', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_match_spec_to_entry_hdl_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_match_spec_to_entry_hdl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_match_spec_to_entry_hdl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_match_spec_to_entry_hdl failed: unknown result")

    def state_check_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_match_spec_to_entry_hdl(sess_hdl, dev_tgt, match_spec)
        return self.recv_state_check_table_match_spec_to_entry_hdl()

    def send_state_check_table_match_spec_to_entry_hdl(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_match_spec_to_entry_hdl', TMessageType.CALL, self._seqid)
        args = state_check_table_match_spec_to_entry_hdl_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_match_spec_to_entry_hdl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_match_spec_to_entry_hdl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_match_spec_to_entry_hdl failed: unknown result")

    def firewall_table_table_add_with_firewall_allow_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_firewall_table_table_add_with_firewall_allow_action(sess_hdl, dev_tgt, match_spec)
        return self.recv_firewall_table_table_add_with_firewall_allow_action()

    def send_firewall_table_table_add_with_firewall_allow_action(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('firewall_table_table_add_with_firewall_allow_action', TMessageType.CALL, self._seqid)
        args = firewall_table_table_add_with_firewall_allow_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_add_with_firewall_allow_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_add_with_firewall_allow_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_table_add_with_firewall_allow_action failed: unknown result")

    def firewall_table_table_add_with_firewall_drop_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_firewall_table_table_add_with_firewall_drop_action(sess_hdl, dev_tgt, match_spec)
        return self.recv_firewall_table_table_add_with_firewall_drop_action()

    def send_firewall_table_table_add_with_firewall_drop_action(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('firewall_table_table_add_with_firewall_drop_action', TMessageType.CALL, self._seqid)
        args = firewall_table_table_add_with_firewall_drop_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_add_with_firewall_drop_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_add_with_firewall_drop_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_table_add_with_firewall_drop_action failed: unknown result")

    def forward_table_table_add_with_forward_hit(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        self.send_forward_table_table_add_with_forward_hit(sess_hdl, dev_tgt, match_spec, action_spec)
        return self.recv_forward_table_table_add_with_forward_hit()

    def send_forward_table_table_add_with_forward_hit(self, sess_hdl, dev_tgt, match_spec, action_spec):
        self._oprot.writeMessageBegin('forward_table_table_add_with_forward_hit', TMessageType.CALL, self._seqid)
        args = forward_table_table_add_with_forward_hit_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.action_spec = action_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_add_with_forward_hit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_add_with_forward_hit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_table_add_with_forward_hit failed: unknown result")

    def forward_table_table_add_with_forward_miss(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_table_add_with_forward_miss(sess_hdl, dev_tgt, match_spec)
        return self.recv_forward_table_table_add_with_forward_miss()

    def send_forward_table_table_add_with_forward_miss(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_table_add_with_forward_miss', TMessageType.CALL, self._seqid)
        args = forward_table_table_add_with_forward_miss_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_add_with_forward_miss(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_add_with_forward_miss_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_table_add_with_forward_miss failed: unknown result")

    def forward_table_by_dst_ip_table_add_with_forward_ip_hit(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        self.send_forward_table_by_dst_ip_table_add_with_forward_ip_hit(sess_hdl, dev_tgt, match_spec, action_spec)
        return self.recv_forward_table_by_dst_ip_table_add_with_forward_ip_hit()

    def send_forward_table_by_dst_ip_table_add_with_forward_ip_hit(self, sess_hdl, dev_tgt, match_spec, action_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_add_with_forward_ip_hit', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_add_with_forward_ip_hit_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.action_spec = action_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_add_with_forward_ip_hit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_add_with_forward_ip_hit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_table_add_with_forward_ip_hit failed: unknown result")

    def forward_table_by_dst_ip_table_add_with_forward_ip_miss(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_by_dst_ip_table_add_with_forward_ip_miss(sess_hdl, dev_tgt, match_spec)
        return self.recv_forward_table_by_dst_ip_table_add_with_forward_ip_miss()

    def send_forward_table_by_dst_ip_table_add_with_forward_ip_miss(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_add_with_forward_ip_miss', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_add_with_forward_ip_miss_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_add_with_forward_ip_miss(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_add_with_forward_ip_miss_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_table_add_with_forward_ip_miss failed: unknown result")

    def state_check_table_table_add_with_state_check_allow_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_add_with_state_check_allow_action(sess_hdl, dev_tgt, match_spec)
        return self.recv_state_check_table_table_add_with_state_check_allow_action()

    def send_state_check_table_table_add_with_state_check_allow_action(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_add_with_state_check_allow_action', TMessageType.CALL, self._seqid)
        args = state_check_table_table_add_with_state_check_allow_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_add_with_state_check_allow_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_add_with_state_check_allow_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_table_add_with_state_check_allow_action failed: unknown result")

    def state_check_table_table_add_with_state_check_to_controller_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_add_with_state_check_to_controller_action(sess_hdl, dev_tgt, match_spec)
        return self.recv_state_check_table_table_add_with_state_check_to_controller_action()

    def send_state_check_table_table_add_with_state_check_to_controller_action(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_add_with_state_check_to_controller_action', TMessageType.CALL, self._seqid)
        args = state_check_table_table_add_with_state_check_to_controller_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_add_with_state_check_to_controller_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_add_with_state_check_to_controller_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_table_add_with_state_check_to_controller_action failed: unknown result")

    def state_check_table_table_add_with_state_check_drop_action(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_add_with_state_check_drop_action(sess_hdl, dev_tgt, match_spec)
        return self.recv_state_check_table_table_add_with_state_check_drop_action()

    def send_state_check_table_table_add_with_state_check_drop_action(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_add_with_state_check_drop_action', TMessageType.CALL, self._seqid)
        args = state_check_table_table_add_with_state_check_drop_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_add_with_state_check_drop_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_add_with_state_check_drop_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_table_add_with_state_check_drop_action failed: unknown result")

    def firewall_table_table_modify_with_firewall_allow_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_firewall_table_table_modify_with_firewall_allow_action(sess_hdl, dev_id, entry)
        self.recv_firewall_table_table_modify_with_firewall_allow_action()

    def send_firewall_table_table_modify_with_firewall_allow_action(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('firewall_table_table_modify_with_firewall_allow_action', TMessageType.CALL, self._seqid)
        args = firewall_table_table_modify_with_firewall_allow_action_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_modify_with_firewall_allow_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_modify_with_firewall_allow_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_table_modify_with_firewall_allow_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_firewall_table_table_modify_with_firewall_allow_action_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_firewall_table_table_modify_with_firewall_allow_action_by_match_spec()

    def send_firewall_table_table_modify_with_firewall_allow_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('firewall_table_table_modify_with_firewall_allow_action_by_match_spec', TMessageType.CALL, self._seqid)
        args = firewall_table_table_modify_with_firewall_allow_action_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_modify_with_firewall_allow_action_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_modify_with_firewall_allow_action_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_table_modify_with_firewall_drop_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_firewall_table_table_modify_with_firewall_drop_action(sess_hdl, dev_id, entry)
        self.recv_firewall_table_table_modify_with_firewall_drop_action()

    def send_firewall_table_table_modify_with_firewall_drop_action(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('firewall_table_table_modify_with_firewall_drop_action', TMessageType.CALL, self._seqid)
        args = firewall_table_table_modify_with_firewall_drop_action_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_modify_with_firewall_drop_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_modify_with_firewall_drop_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_table_modify_with_firewall_drop_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_firewall_table_table_modify_with_firewall_drop_action_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_firewall_table_table_modify_with_firewall_drop_action_by_match_spec()

    def send_firewall_table_table_modify_with_firewall_drop_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('firewall_table_table_modify_with_firewall_drop_action_by_match_spec', TMessageType.CALL, self._seqid)
        args = firewall_table_table_modify_with_firewall_drop_action_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_modify_with_firewall_drop_action_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_modify_with_firewall_drop_action_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_modify_with_forward_hit(self, sess_hdl, dev_id, entry, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry
         - action_spec

        """
        self.send_forward_table_table_modify_with_forward_hit(sess_hdl, dev_id, entry, action_spec)
        self.recv_forward_table_table_modify_with_forward_hit()

    def send_forward_table_table_modify_with_forward_hit(self, sess_hdl, dev_id, entry, action_spec):
        self._oprot.writeMessageBegin('forward_table_table_modify_with_forward_hit', TMessageType.CALL, self._seqid)
        args = forward_table_table_modify_with_forward_hit_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.action_spec = action_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_modify_with_forward_hit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_modify_with_forward_hit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_modify_with_forward_hit_by_match_spec(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        self.send_forward_table_table_modify_with_forward_hit_by_match_spec(sess_hdl, dev_tgt, match_spec, action_spec)
        self.recv_forward_table_table_modify_with_forward_hit_by_match_spec()

    def send_forward_table_table_modify_with_forward_hit_by_match_spec(self, sess_hdl, dev_tgt, match_spec, action_spec):
        self._oprot.writeMessageBegin('forward_table_table_modify_with_forward_hit_by_match_spec', TMessageType.CALL, self._seqid)
        args = forward_table_table_modify_with_forward_hit_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.action_spec = action_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_modify_with_forward_hit_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_modify_with_forward_hit_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_modify_with_forward_miss(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_forward_table_table_modify_with_forward_miss(sess_hdl, dev_id, entry)
        self.recv_forward_table_table_modify_with_forward_miss()

    def send_forward_table_table_modify_with_forward_miss(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('forward_table_table_modify_with_forward_miss', TMessageType.CALL, self._seqid)
        args = forward_table_table_modify_with_forward_miss_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_modify_with_forward_miss(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_modify_with_forward_miss_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_modify_with_forward_miss_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_table_modify_with_forward_miss_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_forward_table_table_modify_with_forward_miss_by_match_spec()

    def send_forward_table_table_modify_with_forward_miss_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_table_modify_with_forward_miss_by_match_spec', TMessageType.CALL, self._seqid)
        args = forward_table_table_modify_with_forward_miss_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_modify_with_forward_miss_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_modify_with_forward_miss_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_modify_with_forward_ip_hit(self, sess_hdl, dev_id, entry, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry
         - action_spec

        """
        self.send_forward_table_by_dst_ip_table_modify_with_forward_ip_hit(sess_hdl, dev_id, entry, action_spec)
        self.recv_forward_table_by_dst_ip_table_modify_with_forward_ip_hit()

    def send_forward_table_by_dst_ip_table_modify_with_forward_ip_hit(self, sess_hdl, dev_id, entry, action_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_hit', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.action_spec = action_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_modify_with_forward_ip_hit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(self, sess_hdl, dev_tgt, match_spec, action_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec
         - action_spec

        """
        self.send_forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(sess_hdl, dev_tgt, match_spec, action_spec)
        self.recv_forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec()

    def send_forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(self, sess_hdl, dev_tgt, match_spec, action_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.action_spec = action_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_modify_with_forward_ip_miss(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_forward_table_by_dst_ip_table_modify_with_forward_ip_miss(sess_hdl, dev_id, entry)
        self.recv_forward_table_by_dst_ip_table_modify_with_forward_ip_miss()

    def send_forward_table_by_dst_ip_table_modify_with_forward_ip_miss(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_miss', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_modify_with_forward_ip_miss(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec()

    def send_forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_modify_with_state_check_allow_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_state_check_table_table_modify_with_state_check_allow_action(sess_hdl, dev_id, entry)
        self.recv_state_check_table_table_modify_with_state_check_allow_action()

    def send_state_check_table_table_modify_with_state_check_allow_action(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('state_check_table_table_modify_with_state_check_allow_action', TMessageType.CALL, self._seqid)
        args = state_check_table_table_modify_with_state_check_allow_action_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_modify_with_state_check_allow_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_modify_with_state_check_allow_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_modify_with_state_check_allow_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_modify_with_state_check_allow_action_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_state_check_table_table_modify_with_state_check_allow_action_by_match_spec()

    def send_state_check_table_table_modify_with_state_check_allow_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_modify_with_state_check_allow_action_by_match_spec', TMessageType.CALL, self._seqid)
        args = state_check_table_table_modify_with_state_check_allow_action_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_modify_with_state_check_allow_action_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_modify_with_state_check_allow_action_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_modify_with_state_check_to_controller_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_state_check_table_table_modify_with_state_check_to_controller_action(sess_hdl, dev_id, entry)
        self.recv_state_check_table_table_modify_with_state_check_to_controller_action()

    def send_state_check_table_table_modify_with_state_check_to_controller_action(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('state_check_table_table_modify_with_state_check_to_controller_action', TMessageType.CALL, self._seqid)
        args = state_check_table_table_modify_with_state_check_to_controller_action_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_modify_with_state_check_to_controller_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_modify_with_state_check_to_controller_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec()

    def send_state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec', TMessageType.CALL, self._seqid)
        args = state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_modify_with_state_check_drop_action(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_state_check_table_table_modify_with_state_check_drop_action(sess_hdl, dev_id, entry)
        self.recv_state_check_table_table_modify_with_state_check_drop_action()

    def send_state_check_table_table_modify_with_state_check_drop_action(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('state_check_table_table_modify_with_state_check_drop_action', TMessageType.CALL, self._seqid)
        args = state_check_table_table_modify_with_state_check_drop_action_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_modify_with_state_check_drop_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_modify_with_state_check_drop_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_modify_with_state_check_drop_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_modify_with_state_check_drop_action_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_state_check_table_table_modify_with_state_check_drop_action_by_match_spec()

    def send_state_check_table_table_modify_with_state_check_drop_action_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_modify_with_state_check_drop_action_by_match_spec', TMessageType.CALL, self._seqid)
        args = state_check_table_table_modify_with_state_check_drop_action_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_modify_with_state_check_drop_action_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_modify_with_state_check_drop_action_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_firewall_table_table_delete(sess_hdl, dev_id, entry)
        self.recv_firewall_table_table_delete()

    def send_firewall_table_table_delete(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('firewall_table_table_delete', TMessageType.CALL, self._seqid)
        args = firewall_table_table_delete_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_delete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_delete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_firewall_table_table_delete_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_firewall_table_table_delete_by_match_spec()

    def send_firewall_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('firewall_table_table_delete_by_match_spec', TMessageType.CALL, self._seqid)
        args = firewall_table_table_delete_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_delete_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_delete_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_forward_table_table_delete(sess_hdl, dev_id, entry)
        self.recv_forward_table_table_delete()

    def send_forward_table_table_delete(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('forward_table_table_delete', TMessageType.CALL, self._seqid)
        args = forward_table_table_delete_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_delete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_delete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_table_delete_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_forward_table_table_delete_by_match_spec()

    def send_forward_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_table_delete_by_match_spec', TMessageType.CALL, self._seqid)
        args = forward_table_table_delete_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_delete_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_delete_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_forward_table_by_dst_ip_table_delete(sess_hdl, dev_id, entry)
        self.recv_forward_table_by_dst_ip_table_delete()

    def send_forward_table_by_dst_ip_table_delete(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_delete', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_delete_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_delete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_delete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_forward_table_by_dst_ip_table_delete_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_forward_table_by_dst_ip_table_delete_by_match_spec()

    def send_forward_table_by_dst_ip_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_delete_by_match_spec', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_delete_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_delete_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_delete_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_delete(self, sess_hdl, dev_id, entry):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry

        """
        self.send_state_check_table_table_delete(sess_hdl, dev_id, entry)
        self.recv_state_check_table_table_delete()

    def send_state_check_table_table_delete(self, sess_hdl, dev_id, entry):
        self._oprot.writeMessageBegin('state_check_table_table_delete', TMessageType.CALL, self._seqid)
        args = state_check_table_table_delete_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry = entry
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_delete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_delete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - match_spec

        """
        self.send_state_check_table_table_delete_by_match_spec(sess_hdl, dev_tgt, match_spec)
        self.recv_state_check_table_table_delete_by_match_spec()

    def send_state_check_table_table_delete_by_match_spec(self, sess_hdl, dev_tgt, match_spec):
        self._oprot.writeMessageBegin('state_check_table_table_delete_by_match_spec', TMessageType.CALL, self._seqid)
        args = state_check_table_table_delete_by_match_spec_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.match_spec = match_spec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_delete_by_match_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_delete_by_match_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_firewall_table_table_get_default_entry_handle(sess_hdl, dev_tgt)
        return self.recv_firewall_table_table_get_default_entry_handle()

    def send_firewall_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('firewall_table_table_get_default_entry_handle', TMessageType.CALL, self._seqid)
        args = firewall_table_table_get_default_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_get_default_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_get_default_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_table_get_default_entry_handle failed: unknown result")

    def firewall_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        self.send_firewall_table_table_get_default_entry(sess_hdl, dev_tgt, read_from_hw)
        return self.recv_firewall_table_table_get_default_entry()

    def send_firewall_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        self._oprot.writeMessageBegin('firewall_table_table_get_default_entry', TMessageType.CALL, self._seqid)
        args = firewall_table_table_get_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_get_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_get_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_table_get_default_entry failed: unknown result")

    def forward_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_table_get_default_entry_handle(sess_hdl, dev_tgt)
        return self.recv_forward_table_table_get_default_entry_handle()

    def send_forward_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_table_get_default_entry_handle', TMessageType.CALL, self._seqid)
        args = forward_table_table_get_default_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_get_default_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_get_default_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_table_get_default_entry_handle failed: unknown result")

    def forward_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        self.send_forward_table_table_get_default_entry(sess_hdl, dev_tgt, read_from_hw)
        return self.recv_forward_table_table_get_default_entry()

    def send_forward_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        self._oprot.writeMessageBegin('forward_table_table_get_default_entry', TMessageType.CALL, self._seqid)
        args = forward_table_table_get_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_get_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_get_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_table_get_default_entry failed: unknown result")

    def forward_table_by_dst_ip_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_by_dst_ip_table_get_default_entry_handle(sess_hdl, dev_tgt)
        return self.recv_forward_table_by_dst_ip_table_get_default_entry_handle()

    def send_forward_table_by_dst_ip_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_get_default_entry_handle', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_get_default_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_get_default_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_get_default_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_table_get_default_entry_handle failed: unknown result")

    def forward_table_by_dst_ip_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        self.send_forward_table_by_dst_ip_table_get_default_entry(sess_hdl, dev_tgt, read_from_hw)
        return self.recv_forward_table_by_dst_ip_table_get_default_entry()

    def send_forward_table_by_dst_ip_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_get_default_entry', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_get_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_get_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_get_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_table_get_default_entry failed: unknown result")

    def state_check_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_state_check_table_table_get_default_entry_handle(sess_hdl, dev_tgt)
        return self.recv_state_check_table_table_get_default_entry_handle()

    def send_state_check_table_table_get_default_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('state_check_table_table_get_default_entry_handle', TMessageType.CALL, self._seqid)
        args = state_check_table_table_get_default_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_get_default_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_get_default_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_table_get_default_entry_handle failed: unknown result")

    def state_check_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - read_from_hw

        """
        self.send_state_check_table_table_get_default_entry(sess_hdl, dev_tgt, read_from_hw)
        return self.recv_state_check_table_table_get_default_entry()

    def send_state_check_table_table_get_default_entry(self, sess_hdl, dev_tgt, read_from_hw):
        self._oprot.writeMessageBegin('state_check_table_table_get_default_entry', TMessageType.CALL, self._seqid)
        args = state_check_table_table_get_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_get_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_get_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_table_get_default_entry failed: unknown result")

    def firewall_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_firewall_table_table_reset_default_entry(sess_hdl, dev_tgt)
        self.recv_firewall_table_table_reset_default_entry()

    def send_firewall_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('firewall_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
        args = firewall_table_table_reset_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_table_reset_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_table_reset_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_table_reset_default_entry(sess_hdl, dev_tgt)
        self.recv_forward_table_table_reset_default_entry()

    def send_forward_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
        args = forward_table_table_reset_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_table_reset_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_table_reset_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_by_dst_ip_table_reset_default_entry(sess_hdl, dev_tgt)
        self.recv_forward_table_by_dst_ip_table_reset_default_entry()

    def send_forward_table_by_dst_ip_table_reset_default_entry(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_table_reset_default_entry', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_table_reset_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_table_reset_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_table_reset_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_state_check_table_table_reset_default_entry(sess_hdl, dev_tgt)
        self.recv_state_check_table_table_reset_default_entry()

    def send_state_check_table_table_reset_default_entry(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('state_check_table_table_reset_default_entry', TMessageType.CALL, self._seqid)
        args = state_check_table_table_reset_default_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_table_reset_default_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_table_reset_default_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_firewall_table_get_entry_count(sess_hdl, dev_tgt)
        return self.recv_firewall_table_get_entry_count()

    def send_firewall_table_get_entry_count(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('firewall_table_get_entry_count', TMessageType.CALL, self._seqid)
        args = firewall_table_get_entry_count_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_get_entry_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_get_entry_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_get_entry_count failed: unknown result")

    def forward_table_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_get_entry_count(sess_hdl, dev_tgt)
        return self.recv_forward_table_get_entry_count()

    def send_forward_table_get_entry_count(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_get_entry_count', TMessageType.CALL, self._seqid)
        args = forward_table_get_entry_count_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_get_entry_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_get_entry_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_get_entry_count failed: unknown result")

    def forward_table_by_dst_ip_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_by_dst_ip_get_entry_count(sess_hdl, dev_tgt)
        return self.recv_forward_table_by_dst_ip_get_entry_count()

    def send_forward_table_by_dst_ip_get_entry_count(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_get_entry_count', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_get_entry_count_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_get_entry_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_get_entry_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_get_entry_count failed: unknown result")

    def state_check_table_get_entry_count(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_state_check_table_get_entry_count(sess_hdl, dev_tgt)
        return self.recv_state_check_table_get_entry_count()

    def send_state_check_table_get_entry_count(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('state_check_table_get_entry_count', TMessageType.CALL, self._seqid)
        args = state_check_table_get_entry_count_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_get_entry_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_get_entry_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_get_entry_count failed: unknown result")

    def firewall_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_firewall_table_get_first_entry_handle(sess_hdl, dev_tgt)
        return self.recv_firewall_table_get_first_entry_handle()

    def send_firewall_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('firewall_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
        args = firewall_table_get_first_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_get_first_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_get_first_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_get_first_entry_handle failed: unknown result")

    def firewall_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        self.send_firewall_table_get_next_entry_handles(sess_hdl, dev_tgt, entry_hdl, n)
        return self.recv_firewall_table_get_next_entry_handles()

    def send_firewall_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        self._oprot.writeMessageBegin('firewall_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
        args = firewall_table_get_next_entry_handles_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.entry_hdl = entry_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_get_next_entry_handles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_get_next_entry_handles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_get_next_entry_handles failed: unknown result")

    def firewall_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        self.send_firewall_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
        return self.recv_firewall_table_get_entry()

    def send_firewall_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        self._oprot.writeMessageBegin('firewall_table_get_entry', TMessageType.CALL, self._seqid)
        args = firewall_table_get_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry_hdl = entry_hdl
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_get_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_get_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_get_entry failed: unknown result")

    def forward_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_get_first_entry_handle(sess_hdl, dev_tgt)
        return self.recv_forward_table_get_first_entry_handle()

    def send_forward_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
        args = forward_table_get_first_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_get_first_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_get_first_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_get_first_entry_handle failed: unknown result")

    def forward_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        self.send_forward_table_get_next_entry_handles(sess_hdl, dev_tgt, entry_hdl, n)
        return self.recv_forward_table_get_next_entry_handles()

    def send_forward_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        self._oprot.writeMessageBegin('forward_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
        args = forward_table_get_next_entry_handles_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.entry_hdl = entry_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_get_next_entry_handles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_get_next_entry_handles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_get_next_entry_handles failed: unknown result")

    def forward_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        self.send_forward_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
        return self.recv_forward_table_get_entry()

    def send_forward_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        self._oprot.writeMessageBegin('forward_table_get_entry', TMessageType.CALL, self._seqid)
        args = forward_table_get_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry_hdl = entry_hdl
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_get_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_get_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_get_entry failed: unknown result")

    def forward_table_by_dst_ip_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_by_dst_ip_get_first_entry_handle(sess_hdl, dev_tgt)
        return self.recv_forward_table_by_dst_ip_get_first_entry_handle()

    def send_forward_table_by_dst_ip_get_first_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_get_first_entry_handle', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_get_first_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_get_first_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_get_first_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_get_first_entry_handle failed: unknown result")

    def forward_table_by_dst_ip_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        self.send_forward_table_by_dst_ip_get_next_entry_handles(sess_hdl, dev_tgt, entry_hdl, n)
        return self.recv_forward_table_by_dst_ip_get_next_entry_handles()

    def send_forward_table_by_dst_ip_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_get_next_entry_handles', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_get_next_entry_handles_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.entry_hdl = entry_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_get_next_entry_handles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_get_next_entry_handles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_get_next_entry_handles failed: unknown result")

    def forward_table_by_dst_ip_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        self.send_forward_table_by_dst_ip_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
        return self.recv_forward_table_by_dst_ip_get_entry()

    def send_forward_table_by_dst_ip_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_get_entry', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_get_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry_hdl = entry_hdl
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_get_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_get_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_get_entry failed: unknown result")

    def state_check_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_state_check_table_get_first_entry_handle(sess_hdl, dev_tgt)
        return self.recv_state_check_table_get_first_entry_handle()

    def send_state_check_table_get_first_entry_handle(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('state_check_table_get_first_entry_handle', TMessageType.CALL, self._seqid)
        args = state_check_table_get_first_entry_handle_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_get_first_entry_handle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_get_first_entry_handle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_get_first_entry_handle failed: unknown result")

    def state_check_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - entry_hdl
         - n

        """
        self.send_state_check_table_get_next_entry_handles(sess_hdl, dev_tgt, entry_hdl, n)
        return self.recv_state_check_table_get_next_entry_handles()

    def send_state_check_table_get_next_entry_handles(self, sess_hdl, dev_tgt, entry_hdl, n):
        self._oprot.writeMessageBegin('state_check_table_get_next_entry_handles', TMessageType.CALL, self._seqid)
        args = state_check_table_get_next_entry_handles_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.entry_hdl = entry_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_get_next_entry_handles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_get_next_entry_handles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_get_next_entry_handles failed: unknown result")

    def state_check_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - entry_hdl
         - read_from_hw

        """
        self.send_state_check_table_get_entry(sess_hdl, dev_id, entry_hdl, read_from_hw)
        return self.recv_state_check_table_get_entry()

    def send_state_check_table_get_entry(self, sess_hdl, dev_id, entry_hdl, read_from_hw):
        self._oprot.writeMessageBegin('state_check_table_get_entry', TMessageType.CALL, self._seqid)
        args = state_check_table_get_entry_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.entry_hdl = entry_hdl
        args.read_from_hw = read_from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_get_entry(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_get_entry_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_get_entry failed: unknown result")

    def firewall_table_set_default_action_firewall_drop_action(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_firewall_table_set_default_action_firewall_drop_action(sess_hdl, dev_tgt)
        return self.recv_firewall_table_set_default_action_firewall_drop_action()

    def send_firewall_table_set_default_action_firewall_drop_action(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('firewall_table_set_default_action_firewall_drop_action', TMessageType.CALL, self._seqid)
        args = firewall_table_set_default_action_firewall_drop_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_set_default_action_firewall_drop_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_set_default_action_firewall_drop_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_set_default_action_firewall_drop_action failed: unknown result")

    def forward_table_set_default_action_forward_miss(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_set_default_action_forward_miss(sess_hdl, dev_tgt)
        return self.recv_forward_table_set_default_action_forward_miss()

    def send_forward_table_set_default_action_forward_miss(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_set_default_action_forward_miss', TMessageType.CALL, self._seqid)
        args = forward_table_set_default_action_forward_miss_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_set_default_action_forward_miss(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_set_default_action_forward_miss_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_set_default_action_forward_miss failed: unknown result")

    def forward_table_by_dst_ip_set_default_action_forward_ip_miss(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_forward_table_by_dst_ip_set_default_action_forward_ip_miss(sess_hdl, dev_tgt)
        return self.recv_forward_table_by_dst_ip_set_default_action_forward_ip_miss()

    def send_forward_table_by_dst_ip_set_default_action_forward_ip_miss(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_set_default_action_forward_ip_miss', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_set_default_action_forward_ip_miss_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_set_default_action_forward_ip_miss(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_set_default_action_forward_ip_miss_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_set_default_action_forward_ip_miss failed: unknown result")

    def state_check_table_set_default_action_state_check_drop_action(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_state_check_table_set_default_action_state_check_drop_action(sess_hdl, dev_tgt)
        return self.recv_state_check_table_set_default_action_state_check_drop_action()

    def send_state_check_table_set_default_action_state_check_drop_action(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('state_check_table_set_default_action_state_check_drop_action', TMessageType.CALL, self._seqid)
        args = state_check_table_set_default_action_state_check_drop_action_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_set_default_action_state_check_drop_action(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_set_default_action_state_check_drop_action_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_set_default_action_state_check_drop_action failed: unknown result")

    def firewall_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        self.send_firewall_table_set_property(sess_hdl, dev_id, property, value, prop_args)
        self.recv_firewall_table_set_property()

    def send_firewall_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        self._oprot.writeMessageBegin('firewall_table_set_property', TMessageType.CALL, self._seqid)
        args = firewall_table_set_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.value = value
        args.prop_args = prop_args
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_set_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_set_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def firewall_table_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        self.send_firewall_table_get_property(sess_hdl, dev_id, property)
        return self.recv_firewall_table_get_property()

    def send_firewall_table_get_property(self, sess_hdl, dev_id, property):
        self._oprot.writeMessageBegin('firewall_table_get_property', TMessageType.CALL, self._seqid)
        args = firewall_table_get_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_firewall_table_get_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = firewall_table_get_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "firewall_table_get_property failed: unknown result")

    def forward_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        self.send_forward_table_set_property(sess_hdl, dev_id, property, value, prop_args)
        self.recv_forward_table_set_property()

    def send_forward_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        self._oprot.writeMessageBegin('forward_table_set_property', TMessageType.CALL, self._seqid)
        args = forward_table_set_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.value = value
        args.prop_args = prop_args
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_set_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_set_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        self.send_forward_table_get_property(sess_hdl, dev_id, property)
        return self.recv_forward_table_get_property()

    def send_forward_table_get_property(self, sess_hdl, dev_id, property):
        self._oprot.writeMessageBegin('forward_table_get_property', TMessageType.CALL, self._seqid)
        args = forward_table_get_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_get_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_get_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_get_property failed: unknown result")

    def forward_table_by_dst_ip_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        self.send_forward_table_by_dst_ip_set_property(sess_hdl, dev_id, property, value, prop_args)
        self.recv_forward_table_by_dst_ip_set_property()

    def send_forward_table_by_dst_ip_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_set_property', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_set_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.value = value
        args.prop_args = prop_args
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_set_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_set_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def forward_table_by_dst_ip_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        self.send_forward_table_by_dst_ip_get_property(sess_hdl, dev_id, property)
        return self.recv_forward_table_by_dst_ip_get_property()

    def send_forward_table_by_dst_ip_get_property(self, sess_hdl, dev_id, property):
        self._oprot.writeMessageBegin('forward_table_by_dst_ip_get_property', TMessageType.CALL, self._seqid)
        args = forward_table_by_dst_ip_get_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_forward_table_by_dst_ip_get_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = forward_table_by_dst_ip_get_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "forward_table_by_dst_ip_get_property failed: unknown result")

    def state_check_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property
         - value
         - prop_args

        """
        self.send_state_check_table_set_property(sess_hdl, dev_id, property, value, prop_args)
        self.recv_state_check_table_set_property()

    def send_state_check_table_set_property(self, sess_hdl, dev_id, property, value, prop_args):
        self._oprot.writeMessageBegin('state_check_table_set_property', TMessageType.CALL, self._seqid)
        args = state_check_table_set_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.value = value
        args.prop_args = prop_args
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_set_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_set_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def state_check_table_get_property(self, sess_hdl, dev_id, property):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - property

        """
        self.send_state_check_table_get_property(sess_hdl, dev_id, property)
        return self.recv_state_check_table_get_property()

    def send_state_check_table_get_property(self, sess_hdl, dev_id, property):
        self._oprot.writeMessageBegin('state_check_table_get_property', TMessageType.CALL, self._seqid)
        args = state_check_table_get_property_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.property = property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_state_check_table_get_property(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = state_check_table_get_property_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "state_check_table_get_property failed: unknown result")

    def set_learning_timeout(self, sess_hdl, dev_id, usecs):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - usecs

        """
        self.send_set_learning_timeout(sess_hdl, dev_id, usecs)
        self.recv_set_learning_timeout()

    def send_set_learning_timeout(self, sess_hdl, dev_id, usecs):
        self._oprot.writeMessageBegin('set_learning_timeout', TMessageType.CALL, self._seqid)
        args = set_learning_timeout_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.usecs = usecs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_learning_timeout(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_learning_timeout_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
        """
        Parameters:
         - dev_tgt
         - tbl_name
         - type

        """
        self.send_tbl_dbg_counter_type_set(dev_tgt, tbl_name, type)
        self.recv_tbl_dbg_counter_type_set()

    def send_tbl_dbg_counter_type_set(self, dev_tgt, tbl_name, type):
        self._oprot.writeMessageBegin('tbl_dbg_counter_type_set', TMessageType.CALL, self._seqid)
        args = tbl_dbg_counter_type_set_args()
        args.dev_tgt = dev_tgt
        args.tbl_name = tbl_name
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tbl_dbg_counter_type_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tbl_dbg_counter_type_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def tbl_dbg_counter_get(self, dev_tgt, tbl_name):
        """
        Parameters:
         - dev_tgt
         - tbl_name

        """
        self.send_tbl_dbg_counter_get(dev_tgt, tbl_name)
        return self.recv_tbl_dbg_counter_get()

    def send_tbl_dbg_counter_get(self, dev_tgt, tbl_name):
        self._oprot.writeMessageBegin('tbl_dbg_counter_get', TMessageType.CALL, self._seqid)
        args = tbl_dbg_counter_get_args()
        args.dev_tgt = dev_tgt
        args.tbl_name = tbl_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tbl_dbg_counter_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tbl_dbg_counter_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_get failed: unknown result")

    def tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
        """
        Parameters:
         - dev_tgt
         - tbl_name

        """
        self.send_tbl_dbg_counter_clear(dev_tgt, tbl_name)
        self.recv_tbl_dbg_counter_clear()

    def send_tbl_dbg_counter_clear(self, dev_tgt, tbl_name):
        self._oprot.writeMessageBegin('tbl_dbg_counter_clear', TMessageType.CALL, self._seqid)
        args = tbl_dbg_counter_clear_args()
        args.dev_tgt = dev_tgt
        args.tbl_name = tbl_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tbl_dbg_counter_clear(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tbl_dbg_counter_clear_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
        """
        Parameters:
         - dev_tgt
         - stage
         - type

        """
        self.send_tbl_dbg_counter_type_stage_set(dev_tgt, stage, type)
        self.recv_tbl_dbg_counter_type_stage_set()

    def send_tbl_dbg_counter_type_stage_set(self, dev_tgt, stage, type):
        self._oprot.writeMessageBegin('tbl_dbg_counter_type_stage_set', TMessageType.CALL, self._seqid)
        args = tbl_dbg_counter_type_stage_set_args()
        args.dev_tgt = dev_tgt
        args.stage = stage
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tbl_dbg_counter_type_stage_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tbl_dbg_counter_type_stage_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def tbl_dbg_counter_stage_get(self, dev_tgt, stage):
        """
        Parameters:
         - dev_tgt
         - stage

        """
        self.send_tbl_dbg_counter_stage_get(dev_tgt, stage)
        return self.recv_tbl_dbg_counter_stage_get()

    def send_tbl_dbg_counter_stage_get(self, dev_tgt, stage):
        self._oprot.writeMessageBegin('tbl_dbg_counter_stage_get', TMessageType.CALL, self._seqid)
        args = tbl_dbg_counter_stage_get_args()
        args.dev_tgt = dev_tgt
        args.stage = stage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tbl_dbg_counter_stage_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tbl_dbg_counter_stage_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tbl_dbg_counter_stage_get failed: unknown result")

    def tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
        """
        Parameters:
         - dev_tgt
         - stage

        """
        self.send_tbl_dbg_counter_stage_clear(dev_tgt, stage)
        self.recv_tbl_dbg_counter_stage_clear()

    def send_tbl_dbg_counter_stage_clear(self, dev_tgt, stage):
        self._oprot.writeMessageBegin('tbl_dbg_counter_stage_clear', TMessageType.CALL, self._seqid)
        args = tbl_dbg_counter_stage_clear_args()
        args.dev_tgt = dev_tgt
        args.stage = stage
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tbl_dbg_counter_stage_clear(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tbl_dbg_counter_stage_clear_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
        """
        Parameters:
         - dev_tgt
         - start_stage
         - end_stage
         - direction

        """
        self.send_snapshot_create(dev_tgt, start_stage, end_stage, direction)
        return self.recv_snapshot_create()

    def send_snapshot_create(self, dev_tgt, start_stage, end_stage, direction):
        self._oprot.writeMessageBegin('snapshot_create', TMessageType.CALL, self._seqid)
        args = snapshot_create_args()
        args.dev_tgt = dev_tgt
        args.start_stage = start_stage
        args.end_stage = end_stage
        args.direction = direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_create(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_create_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_create failed: unknown result")

    def snapshot_delete(self, handle):
        """
        Parameters:
         - handle

        """
        self.send_snapshot_delete(handle)
        self.recv_snapshot_delete()

    def send_snapshot_delete(self, handle):
        self._oprot.writeMessageBegin('snapshot_delete', TMessageType.CALL, self._seqid)
        args = snapshot_delete_args()
        args.handle = handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_delete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_delete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def snapshot_state_set(self, handle, state, usecs):
        """
        Parameters:
         - handle
         - state
         - usecs

        """
        self.send_snapshot_state_set(handle, state, usecs)
        self.recv_snapshot_state_set()

    def send_snapshot_state_set(self, handle, state, usecs):
        self._oprot.writeMessageBegin('snapshot_state_set', TMessageType.CALL, self._seqid)
        args = snapshot_state_set_args()
        args.handle = handle
        args.state = state
        args.usecs = usecs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_state_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_state_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def snapshot_state_get(self, handle, pipe):
        """
        Parameters:
         - handle
         - pipe

        """
        self.send_snapshot_state_get(handle, pipe)
        return self.recv_snapshot_state_get()

    def send_snapshot_state_get(self, handle, pipe):
        self._oprot.writeMessageBegin('snapshot_state_get', TMessageType.CALL, self._seqid)
        args = snapshot_state_get_args()
        args.handle = handle
        args.pipe = pipe
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_state_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_state_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_state_get failed: unknown result")

    def snapshot_timer_enable(self, handle, disable):
        """
        Parameters:
         - handle
         - disable

        """
        self.send_snapshot_timer_enable(handle, disable)
        self.recv_snapshot_timer_enable()

    def send_snapshot_timer_enable(self, handle, disable):
        self._oprot.writeMessageBegin('snapshot_timer_enable', TMessageType.CALL, self._seqid)
        args = snapshot_timer_enable_args()
        args.handle = handle
        args.disable = disable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_timer_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_timer_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
        """
        Parameters:
         - handle
         - trig_spec
         - trig_spec2

        """
        self.send_snapshot_capture_trigger_set(handle, trig_spec, trig_spec2)
        self.recv_snapshot_capture_trigger_set()

    def send_snapshot_capture_trigger_set(self, handle, trig_spec, trig_spec2):
        self._oprot.writeMessageBegin('snapshot_capture_trigger_set', TMessageType.CALL, self._seqid)
        args = snapshot_capture_trigger_set_args()
        args.handle = handle
        args.trig_spec = trig_spec
        args.trig_spec2 = trig_spec2
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_capture_trigger_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_capture_trigger_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
        """
        Parameters:
         - handle
         - pipe
         - stage_id
         - field_name

        """
        self.send_snapshot_capture_data_get(handle, pipe, stage_id, field_name)
        return self.recv_snapshot_capture_data_get()

    def send_snapshot_capture_data_get(self, handle, pipe, stage_id, field_name):
        self._oprot.writeMessageBegin('snapshot_capture_data_get', TMessageType.CALL, self._seqid)
        args = snapshot_capture_data_get_args()
        args.handle = handle
        args.pipe = pipe
        args.stage_id = stage_id
        args.field_name = field_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_capture_data_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_capture_data_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_capture_data_get failed: unknown result")

    def snapshot_capture_tbl_data_get(self, handle, pipe, table_name):
        """
        Parameters:
         - handle
         - pipe
         - table_name

        """
        self.send_snapshot_capture_tbl_data_get(handle, pipe, table_name)
        return self.recv_snapshot_capture_tbl_data_get()

    def send_snapshot_capture_tbl_data_get(self, handle, pipe, table_name):
        self._oprot.writeMessageBegin('snapshot_capture_tbl_data_get', TMessageType.CALL, self._seqid)
        args = snapshot_capture_tbl_data_get_args()
        args.handle = handle
        args.pipe = pipe
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_capture_tbl_data_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_capture_tbl_data_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_capture_tbl_data_get failed: unknown result")

    def snapshot_capture_trigger_fields_clr(self, handle):
        """
        Parameters:
         - handle

        """
        self.send_snapshot_capture_trigger_fields_clr(handle)
        self.recv_snapshot_capture_trigger_fields_clr()

    def send_snapshot_capture_trigger_fields_clr(self, handle):
        self._oprot.writeMessageBegin('snapshot_capture_trigger_fields_clr', TMessageType.CALL, self._seqid)
        args = snapshot_capture_trigger_fields_clr_args()
        args.handle = handle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_capture_trigger_fields_clr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_capture_trigger_fields_clr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def snapshot_field_in_scope(self, dev_tgt, stage, direction, field_name):
        """
        Parameters:
         - dev_tgt
         - stage
         - direction
         - field_name

        """
        self.send_snapshot_field_in_scope(dev_tgt, stage, direction, field_name)
        return self.recv_snapshot_field_in_scope()

    def send_snapshot_field_in_scope(self, dev_tgt, stage, direction, field_name):
        self._oprot.writeMessageBegin('snapshot_field_in_scope', TMessageType.CALL, self._seqid)
        args = snapshot_field_in_scope_args()
        args.dev_tgt = dev_tgt
        args.stage = stage
        args.direction = direction
        args.field_name = field_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_snapshot_field_in_scope(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = snapshot_field_in_scope_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "snapshot_field_in_scope failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["firewall_table_match_spec_to_entry_hdl"] = Processor.process_firewall_table_match_spec_to_entry_hdl
        self._processMap["forward_table_match_spec_to_entry_hdl"] = Processor.process_forward_table_match_spec_to_entry_hdl
        self._processMap["forward_table_by_dst_ip_match_spec_to_entry_hdl"] = Processor.process_forward_table_by_dst_ip_match_spec_to_entry_hdl
        self._processMap["state_check_table_match_spec_to_entry_hdl"] = Processor.process_state_check_table_match_spec_to_entry_hdl
        self._processMap["firewall_table_table_add_with_firewall_allow_action"] = Processor.process_firewall_table_table_add_with_firewall_allow_action
        self._processMap["firewall_table_table_add_with_firewall_drop_action"] = Processor.process_firewall_table_table_add_with_firewall_drop_action
        self._processMap["forward_table_table_add_with_forward_hit"] = Processor.process_forward_table_table_add_with_forward_hit
        self._processMap["forward_table_table_add_with_forward_miss"] = Processor.process_forward_table_table_add_with_forward_miss
        self._processMap["forward_table_by_dst_ip_table_add_with_forward_ip_hit"] = Processor.process_forward_table_by_dst_ip_table_add_with_forward_ip_hit
        self._processMap["forward_table_by_dst_ip_table_add_with_forward_ip_miss"] = Processor.process_forward_table_by_dst_ip_table_add_with_forward_ip_miss
        self._processMap["state_check_table_table_add_with_state_check_allow_action"] = Processor.process_state_check_table_table_add_with_state_check_allow_action
        self._processMap["state_check_table_table_add_with_state_check_to_controller_action"] = Processor.process_state_check_table_table_add_with_state_check_to_controller_action
        self._processMap["state_check_table_table_add_with_state_check_drop_action"] = Processor.process_state_check_table_table_add_with_state_check_drop_action
        self._processMap["firewall_table_table_modify_with_firewall_allow_action"] = Processor.process_firewall_table_table_modify_with_firewall_allow_action
        self._processMap["firewall_table_table_modify_with_firewall_allow_action_by_match_spec"] = Processor.process_firewall_table_table_modify_with_firewall_allow_action_by_match_spec
        self._processMap["firewall_table_table_modify_with_firewall_drop_action"] = Processor.process_firewall_table_table_modify_with_firewall_drop_action
        self._processMap["firewall_table_table_modify_with_firewall_drop_action_by_match_spec"] = Processor.process_firewall_table_table_modify_with_firewall_drop_action_by_match_spec
        self._processMap["forward_table_table_modify_with_forward_hit"] = Processor.process_forward_table_table_modify_with_forward_hit
        self._processMap["forward_table_table_modify_with_forward_hit_by_match_spec"] = Processor.process_forward_table_table_modify_with_forward_hit_by_match_spec
        self._processMap["forward_table_table_modify_with_forward_miss"] = Processor.process_forward_table_table_modify_with_forward_miss
        self._processMap["forward_table_table_modify_with_forward_miss_by_match_spec"] = Processor.process_forward_table_table_modify_with_forward_miss_by_match_spec
        self._processMap["forward_table_by_dst_ip_table_modify_with_forward_ip_hit"] = Processor.process_forward_table_by_dst_ip_table_modify_with_forward_ip_hit
        self._processMap["forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec"] = Processor.process_forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec
        self._processMap["forward_table_by_dst_ip_table_modify_with_forward_ip_miss"] = Processor.process_forward_table_by_dst_ip_table_modify_with_forward_ip_miss
        self._processMap["forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec"] = Processor.process_forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec
        self._processMap["state_check_table_table_modify_with_state_check_allow_action"] = Processor.process_state_check_table_table_modify_with_state_check_allow_action
        self._processMap["state_check_table_table_modify_with_state_check_allow_action_by_match_spec"] = Processor.process_state_check_table_table_modify_with_state_check_allow_action_by_match_spec
        self._processMap["state_check_table_table_modify_with_state_check_to_controller_action"] = Processor.process_state_check_table_table_modify_with_state_check_to_controller_action
        self._processMap["state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec"] = Processor.process_state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec
        self._processMap["state_check_table_table_modify_with_state_check_drop_action"] = Processor.process_state_check_table_table_modify_with_state_check_drop_action
        self._processMap["state_check_table_table_modify_with_state_check_drop_action_by_match_spec"] = Processor.process_state_check_table_table_modify_with_state_check_drop_action_by_match_spec
        self._processMap["firewall_table_table_delete"] = Processor.process_firewall_table_table_delete
        self._processMap["firewall_table_table_delete_by_match_spec"] = Processor.process_firewall_table_table_delete_by_match_spec
        self._processMap["forward_table_table_delete"] = Processor.process_forward_table_table_delete
        self._processMap["forward_table_table_delete_by_match_spec"] = Processor.process_forward_table_table_delete_by_match_spec
        self._processMap["forward_table_by_dst_ip_table_delete"] = Processor.process_forward_table_by_dst_ip_table_delete
        self._processMap["forward_table_by_dst_ip_table_delete_by_match_spec"] = Processor.process_forward_table_by_dst_ip_table_delete_by_match_spec
        self._processMap["state_check_table_table_delete"] = Processor.process_state_check_table_table_delete
        self._processMap["state_check_table_table_delete_by_match_spec"] = Processor.process_state_check_table_table_delete_by_match_spec
        self._processMap["firewall_table_table_get_default_entry_handle"] = Processor.process_firewall_table_table_get_default_entry_handle
        self._processMap["firewall_table_table_get_default_entry"] = Processor.process_firewall_table_table_get_default_entry
        self._processMap["forward_table_table_get_default_entry_handle"] = Processor.process_forward_table_table_get_default_entry_handle
        self._processMap["forward_table_table_get_default_entry"] = Processor.process_forward_table_table_get_default_entry
        self._processMap["forward_table_by_dst_ip_table_get_default_entry_handle"] = Processor.process_forward_table_by_dst_ip_table_get_default_entry_handle
        self._processMap["forward_table_by_dst_ip_table_get_default_entry"] = Processor.process_forward_table_by_dst_ip_table_get_default_entry
        self._processMap["state_check_table_table_get_default_entry_handle"] = Processor.process_state_check_table_table_get_default_entry_handle
        self._processMap["state_check_table_table_get_default_entry"] = Processor.process_state_check_table_table_get_default_entry
        self._processMap["firewall_table_table_reset_default_entry"] = Processor.process_firewall_table_table_reset_default_entry
        self._processMap["forward_table_table_reset_default_entry"] = Processor.process_forward_table_table_reset_default_entry
        self._processMap["forward_table_by_dst_ip_table_reset_default_entry"] = Processor.process_forward_table_by_dst_ip_table_reset_default_entry
        self._processMap["state_check_table_table_reset_default_entry"] = Processor.process_state_check_table_table_reset_default_entry
        self._processMap["firewall_table_get_entry_count"] = Processor.process_firewall_table_get_entry_count
        self._processMap["forward_table_get_entry_count"] = Processor.process_forward_table_get_entry_count
        self._processMap["forward_table_by_dst_ip_get_entry_count"] = Processor.process_forward_table_by_dst_ip_get_entry_count
        self._processMap["state_check_table_get_entry_count"] = Processor.process_state_check_table_get_entry_count
        self._processMap["firewall_table_get_first_entry_handle"] = Processor.process_firewall_table_get_first_entry_handle
        self._processMap["firewall_table_get_next_entry_handles"] = Processor.process_firewall_table_get_next_entry_handles
        self._processMap["firewall_table_get_entry"] = Processor.process_firewall_table_get_entry
        self._processMap["forward_table_get_first_entry_handle"] = Processor.process_forward_table_get_first_entry_handle
        self._processMap["forward_table_get_next_entry_handles"] = Processor.process_forward_table_get_next_entry_handles
        self._processMap["forward_table_get_entry"] = Processor.process_forward_table_get_entry
        self._processMap["forward_table_by_dst_ip_get_first_entry_handle"] = Processor.process_forward_table_by_dst_ip_get_first_entry_handle
        self._processMap["forward_table_by_dst_ip_get_next_entry_handles"] = Processor.process_forward_table_by_dst_ip_get_next_entry_handles
        self._processMap["forward_table_by_dst_ip_get_entry"] = Processor.process_forward_table_by_dst_ip_get_entry
        self._processMap["state_check_table_get_first_entry_handle"] = Processor.process_state_check_table_get_first_entry_handle
        self._processMap["state_check_table_get_next_entry_handles"] = Processor.process_state_check_table_get_next_entry_handles
        self._processMap["state_check_table_get_entry"] = Processor.process_state_check_table_get_entry
        self._processMap["firewall_table_set_default_action_firewall_drop_action"] = Processor.process_firewall_table_set_default_action_firewall_drop_action
        self._processMap["forward_table_set_default_action_forward_miss"] = Processor.process_forward_table_set_default_action_forward_miss
        self._processMap["forward_table_by_dst_ip_set_default_action_forward_ip_miss"] = Processor.process_forward_table_by_dst_ip_set_default_action_forward_ip_miss
        self._processMap["state_check_table_set_default_action_state_check_drop_action"] = Processor.process_state_check_table_set_default_action_state_check_drop_action
        self._processMap["firewall_table_set_property"] = Processor.process_firewall_table_set_property
        self._processMap["firewall_table_get_property"] = Processor.process_firewall_table_get_property
        self._processMap["forward_table_set_property"] = Processor.process_forward_table_set_property
        self._processMap["forward_table_get_property"] = Processor.process_forward_table_get_property
        self._processMap["forward_table_by_dst_ip_set_property"] = Processor.process_forward_table_by_dst_ip_set_property
        self._processMap["forward_table_by_dst_ip_get_property"] = Processor.process_forward_table_by_dst_ip_get_property
        self._processMap["state_check_table_set_property"] = Processor.process_state_check_table_set_property
        self._processMap["state_check_table_get_property"] = Processor.process_state_check_table_get_property
        self._processMap["set_learning_timeout"] = Processor.process_set_learning_timeout
        self._processMap["tbl_dbg_counter_type_set"] = Processor.process_tbl_dbg_counter_type_set
        self._processMap["tbl_dbg_counter_get"] = Processor.process_tbl_dbg_counter_get
        self._processMap["tbl_dbg_counter_clear"] = Processor.process_tbl_dbg_counter_clear
        self._processMap["tbl_dbg_counter_type_stage_set"] = Processor.process_tbl_dbg_counter_type_stage_set
        self._processMap["tbl_dbg_counter_stage_get"] = Processor.process_tbl_dbg_counter_stage_get
        self._processMap["tbl_dbg_counter_stage_clear"] = Processor.process_tbl_dbg_counter_stage_clear
        self._processMap["snapshot_create"] = Processor.process_snapshot_create
        self._processMap["snapshot_delete"] = Processor.process_snapshot_delete
        self._processMap["snapshot_state_set"] = Processor.process_snapshot_state_set
        self._processMap["snapshot_state_get"] = Processor.process_snapshot_state_get
        self._processMap["snapshot_timer_enable"] = Processor.process_snapshot_timer_enable
        self._processMap["snapshot_capture_trigger_set"] = Processor.process_snapshot_capture_trigger_set
        self._processMap["snapshot_capture_data_get"] = Processor.process_snapshot_capture_data_get
        self._processMap["snapshot_capture_tbl_data_get"] = Processor.process_snapshot_capture_tbl_data_get
        self._processMap["snapshot_capture_trigger_fields_clr"] = Processor.process_snapshot_capture_trigger_fields_clr
        self._processMap["snapshot_field_in_scope"] = Processor.process_snapshot_field_in_scope
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_firewall_table_match_spec_to_entry_hdl(self, seqid, iprot, oprot):
        args = firewall_table_match_spec_to_entry_hdl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_match_spec_to_entry_hdl_result()
        try:
            result.success = self._handler.firewall_table_match_spec_to_entry_hdl(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_match_spec_to_entry_hdl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_match_spec_to_entry_hdl(self, seqid, iprot, oprot):
        args = forward_table_match_spec_to_entry_hdl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_match_spec_to_entry_hdl_result()
        try:
            result.success = self._handler.forward_table_match_spec_to_entry_hdl(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_match_spec_to_entry_hdl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_match_spec_to_entry_hdl(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_match_spec_to_entry_hdl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_match_spec_to_entry_hdl_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_match_spec_to_entry_hdl(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_match_spec_to_entry_hdl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_match_spec_to_entry_hdl(self, seqid, iprot, oprot):
        args = state_check_table_match_spec_to_entry_hdl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_match_spec_to_entry_hdl_result()
        try:
            result.success = self._handler.state_check_table_match_spec_to_entry_hdl(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_match_spec_to_entry_hdl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_add_with_firewall_allow_action(self, seqid, iprot, oprot):
        args = firewall_table_table_add_with_firewall_allow_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_add_with_firewall_allow_action_result()
        try:
            result.success = self._handler.firewall_table_table_add_with_firewall_allow_action(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_add_with_firewall_allow_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_add_with_firewall_drop_action(self, seqid, iprot, oprot):
        args = firewall_table_table_add_with_firewall_drop_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_add_with_firewall_drop_action_result()
        try:
            result.success = self._handler.firewall_table_table_add_with_firewall_drop_action(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_add_with_firewall_drop_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_add_with_forward_hit(self, seqid, iprot, oprot):
        args = forward_table_table_add_with_forward_hit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_add_with_forward_hit_result()
        try:
            result.success = self._handler.forward_table_table_add_with_forward_hit(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_add_with_forward_hit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_add_with_forward_miss(self, seqid, iprot, oprot):
        args = forward_table_table_add_with_forward_miss_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_add_with_forward_miss_result()
        try:
            result.success = self._handler.forward_table_table_add_with_forward_miss(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_add_with_forward_miss", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_add_with_forward_ip_hit(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_add_with_forward_ip_hit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_add_with_forward_ip_hit_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_table_add_with_forward_ip_hit(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_add_with_forward_ip_hit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_add_with_forward_ip_miss(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_add_with_forward_ip_miss_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_add_with_forward_ip_miss_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_table_add_with_forward_ip_miss(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_add_with_forward_ip_miss", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_add_with_state_check_allow_action(self, seqid, iprot, oprot):
        args = state_check_table_table_add_with_state_check_allow_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_add_with_state_check_allow_action_result()
        try:
            result.success = self._handler.state_check_table_table_add_with_state_check_allow_action(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_add_with_state_check_allow_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_add_with_state_check_to_controller_action(self, seqid, iprot, oprot):
        args = state_check_table_table_add_with_state_check_to_controller_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_add_with_state_check_to_controller_action_result()
        try:
            result.success = self._handler.state_check_table_table_add_with_state_check_to_controller_action(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_add_with_state_check_to_controller_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_add_with_state_check_drop_action(self, seqid, iprot, oprot):
        args = state_check_table_table_add_with_state_check_drop_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_add_with_state_check_drop_action_result()
        try:
            result.success = self._handler.state_check_table_table_add_with_state_check_drop_action(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_add_with_state_check_drop_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_modify_with_firewall_allow_action(self, seqid, iprot, oprot):
        args = firewall_table_table_modify_with_firewall_allow_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_modify_with_firewall_allow_action_result()
        try:
            self._handler.firewall_table_table_modify_with_firewall_allow_action(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_modify_with_firewall_allow_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_modify_with_firewall_allow_action_by_match_spec(self, seqid, iprot, oprot):
        args = firewall_table_table_modify_with_firewall_allow_action_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_modify_with_firewall_allow_action_by_match_spec_result()
        try:
            self._handler.firewall_table_table_modify_with_firewall_allow_action_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_modify_with_firewall_allow_action_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_modify_with_firewall_drop_action(self, seqid, iprot, oprot):
        args = firewall_table_table_modify_with_firewall_drop_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_modify_with_firewall_drop_action_result()
        try:
            self._handler.firewall_table_table_modify_with_firewall_drop_action(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_modify_with_firewall_drop_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_modify_with_firewall_drop_action_by_match_spec(self, seqid, iprot, oprot):
        args = firewall_table_table_modify_with_firewall_drop_action_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_modify_with_firewall_drop_action_by_match_spec_result()
        try:
            self._handler.firewall_table_table_modify_with_firewall_drop_action_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_modify_with_firewall_drop_action_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_modify_with_forward_hit(self, seqid, iprot, oprot):
        args = forward_table_table_modify_with_forward_hit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_modify_with_forward_hit_result()
        try:
            self._handler.forward_table_table_modify_with_forward_hit(args.sess_hdl, args.dev_id, args.entry, args.action_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_modify_with_forward_hit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_modify_with_forward_hit_by_match_spec(self, seqid, iprot, oprot):
        args = forward_table_table_modify_with_forward_hit_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_modify_with_forward_hit_by_match_spec_result()
        try:
            self._handler.forward_table_table_modify_with_forward_hit_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_modify_with_forward_hit_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_modify_with_forward_miss(self, seqid, iprot, oprot):
        args = forward_table_table_modify_with_forward_miss_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_modify_with_forward_miss_result()
        try:
            self._handler.forward_table_table_modify_with_forward_miss(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_modify_with_forward_miss", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_modify_with_forward_miss_by_match_spec(self, seqid, iprot, oprot):
        args = forward_table_table_modify_with_forward_miss_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_modify_with_forward_miss_by_match_spec_result()
        try:
            self._handler.forward_table_table_modify_with_forward_miss_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_modify_with_forward_miss_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_modify_with_forward_ip_hit(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_result()
        try:
            self._handler.forward_table_by_dst_ip_table_modify_with_forward_ip_hit(args.sess_hdl, args.dev_id, args.entry, args.action_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_modify_with_forward_ip_hit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_result()
        try:
            self._handler.forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec, args.action_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_modify_with_forward_ip_miss(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_result()
        try:
            self._handler.forward_table_by_dst_ip_table_modify_with_forward_ip_miss(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_modify_with_forward_ip_miss", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_result()
        try:
            self._handler.forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_modify_with_state_check_allow_action(self, seqid, iprot, oprot):
        args = state_check_table_table_modify_with_state_check_allow_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_modify_with_state_check_allow_action_result()
        try:
            self._handler.state_check_table_table_modify_with_state_check_allow_action(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_modify_with_state_check_allow_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_modify_with_state_check_allow_action_by_match_spec(self, seqid, iprot, oprot):
        args = state_check_table_table_modify_with_state_check_allow_action_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_modify_with_state_check_allow_action_by_match_spec_result()
        try:
            self._handler.state_check_table_table_modify_with_state_check_allow_action_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_modify_with_state_check_allow_action_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_modify_with_state_check_to_controller_action(self, seqid, iprot, oprot):
        args = state_check_table_table_modify_with_state_check_to_controller_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_modify_with_state_check_to_controller_action_result()
        try:
            self._handler.state_check_table_table_modify_with_state_check_to_controller_action(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_modify_with_state_check_to_controller_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(self, seqid, iprot, oprot):
        args = state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_result()
        try:
            self._handler.state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_modify_with_state_check_drop_action(self, seqid, iprot, oprot):
        args = state_check_table_table_modify_with_state_check_drop_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_modify_with_state_check_drop_action_result()
        try:
            self._handler.state_check_table_table_modify_with_state_check_drop_action(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_modify_with_state_check_drop_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_modify_with_state_check_drop_action_by_match_spec(self, seqid, iprot, oprot):
        args = state_check_table_table_modify_with_state_check_drop_action_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_modify_with_state_check_drop_action_by_match_spec_result()
        try:
            self._handler.state_check_table_table_modify_with_state_check_drop_action_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_modify_with_state_check_drop_action_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_delete(self, seqid, iprot, oprot):
        args = firewall_table_table_delete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_delete_result()
        try:
            self._handler.firewall_table_table_delete(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_delete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_delete_by_match_spec(self, seqid, iprot, oprot):
        args = firewall_table_table_delete_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_delete_by_match_spec_result()
        try:
            self._handler.firewall_table_table_delete_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_delete_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_delete(self, seqid, iprot, oprot):
        args = forward_table_table_delete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_delete_result()
        try:
            self._handler.forward_table_table_delete(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_delete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_delete_by_match_spec(self, seqid, iprot, oprot):
        args = forward_table_table_delete_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_delete_by_match_spec_result()
        try:
            self._handler.forward_table_table_delete_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_delete_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_delete(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_delete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_delete_result()
        try:
            self._handler.forward_table_by_dst_ip_table_delete(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_delete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_delete_by_match_spec(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_delete_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_delete_by_match_spec_result()
        try:
            self._handler.forward_table_by_dst_ip_table_delete_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_delete_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_delete(self, seqid, iprot, oprot):
        args = state_check_table_table_delete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_delete_result()
        try:
            self._handler.state_check_table_table_delete(args.sess_hdl, args.dev_id, args.entry)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_delete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_delete_by_match_spec(self, seqid, iprot, oprot):
        args = state_check_table_table_delete_by_match_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_delete_by_match_spec_result()
        try:
            self._handler.state_check_table_table_delete_by_match_spec(args.sess_hdl, args.dev_tgt, args.match_spec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_delete_by_match_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_get_default_entry_handle(self, seqid, iprot, oprot):
        args = firewall_table_table_get_default_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_get_default_entry_handle_result()
        try:
            result.success = self._handler.firewall_table_table_get_default_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_get_default_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_get_default_entry(self, seqid, iprot, oprot):
        args = firewall_table_table_get_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_get_default_entry_result()
        try:
            result.success = self._handler.firewall_table_table_get_default_entry(args.sess_hdl, args.dev_tgt, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_get_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_get_default_entry_handle(self, seqid, iprot, oprot):
        args = forward_table_table_get_default_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_get_default_entry_handle_result()
        try:
            result.success = self._handler.forward_table_table_get_default_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_get_default_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_get_default_entry(self, seqid, iprot, oprot):
        args = forward_table_table_get_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_get_default_entry_result()
        try:
            result.success = self._handler.forward_table_table_get_default_entry(args.sess_hdl, args.dev_tgt, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_get_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_get_default_entry_handle(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_get_default_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_get_default_entry_handle_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_table_get_default_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_get_default_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_get_default_entry(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_get_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_get_default_entry_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_table_get_default_entry(args.sess_hdl, args.dev_tgt, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_get_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_get_default_entry_handle(self, seqid, iprot, oprot):
        args = state_check_table_table_get_default_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_get_default_entry_handle_result()
        try:
            result.success = self._handler.state_check_table_table_get_default_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_get_default_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_get_default_entry(self, seqid, iprot, oprot):
        args = state_check_table_table_get_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_get_default_entry_result()
        try:
            result.success = self._handler.state_check_table_table_get_default_entry(args.sess_hdl, args.dev_tgt, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_get_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_table_reset_default_entry(self, seqid, iprot, oprot):
        args = firewall_table_table_reset_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_table_reset_default_entry_result()
        try:
            self._handler.firewall_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_table_reset_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_table_reset_default_entry(self, seqid, iprot, oprot):
        args = forward_table_table_reset_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_table_reset_default_entry_result()
        try:
            self._handler.forward_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_table_reset_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_table_reset_default_entry(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_table_reset_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_table_reset_default_entry_result()
        try:
            self._handler.forward_table_by_dst_ip_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_table_reset_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_table_reset_default_entry(self, seqid, iprot, oprot):
        args = state_check_table_table_reset_default_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_table_reset_default_entry_result()
        try:
            self._handler.state_check_table_table_reset_default_entry(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_table_reset_default_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_get_entry_count(self, seqid, iprot, oprot):
        args = firewall_table_get_entry_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_get_entry_count_result()
        try:
            result.success = self._handler.firewall_table_get_entry_count(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_get_entry_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_get_entry_count(self, seqid, iprot, oprot):
        args = forward_table_get_entry_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_get_entry_count_result()
        try:
            result.success = self._handler.forward_table_get_entry_count(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_get_entry_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_get_entry_count(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_get_entry_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_get_entry_count_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_get_entry_count(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_get_entry_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_get_entry_count(self, seqid, iprot, oprot):
        args = state_check_table_get_entry_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_get_entry_count_result()
        try:
            result.success = self._handler.state_check_table_get_entry_count(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_get_entry_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_get_first_entry_handle(self, seqid, iprot, oprot):
        args = firewall_table_get_first_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_get_first_entry_handle_result()
        try:
            result.success = self._handler.firewall_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_get_first_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_get_next_entry_handles(self, seqid, iprot, oprot):
        args = firewall_table_get_next_entry_handles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_get_next_entry_handles_result()
        try:
            result.success = self._handler.firewall_table_get_next_entry_handles(args.sess_hdl, args.dev_tgt, args.entry_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_get_next_entry_handles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_get_entry(self, seqid, iprot, oprot):
        args = firewall_table_get_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_get_entry_result()
        try:
            result.success = self._handler.firewall_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_get_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_get_first_entry_handle(self, seqid, iprot, oprot):
        args = forward_table_get_first_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_get_first_entry_handle_result()
        try:
            result.success = self._handler.forward_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_get_first_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_get_next_entry_handles(self, seqid, iprot, oprot):
        args = forward_table_get_next_entry_handles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_get_next_entry_handles_result()
        try:
            result.success = self._handler.forward_table_get_next_entry_handles(args.sess_hdl, args.dev_tgt, args.entry_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_get_next_entry_handles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_get_entry(self, seqid, iprot, oprot):
        args = forward_table_get_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_get_entry_result()
        try:
            result.success = self._handler.forward_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_get_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_get_first_entry_handle(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_get_first_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_get_first_entry_handle_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_get_first_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_get_next_entry_handles(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_get_next_entry_handles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_get_next_entry_handles_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_get_next_entry_handles(args.sess_hdl, args.dev_tgt, args.entry_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_get_next_entry_handles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_get_entry(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_get_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_get_entry_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_get_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_get_first_entry_handle(self, seqid, iprot, oprot):
        args = state_check_table_get_first_entry_handle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_get_first_entry_handle_result()
        try:
            result.success = self._handler.state_check_table_get_first_entry_handle(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_get_first_entry_handle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_get_next_entry_handles(self, seqid, iprot, oprot):
        args = state_check_table_get_next_entry_handles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_get_next_entry_handles_result()
        try:
            result.success = self._handler.state_check_table_get_next_entry_handles(args.sess_hdl, args.dev_tgt, args.entry_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_get_next_entry_handles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_get_entry(self, seqid, iprot, oprot):
        args = state_check_table_get_entry_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_get_entry_result()
        try:
            result.success = self._handler.state_check_table_get_entry(args.sess_hdl, args.dev_id, args.entry_hdl, args.read_from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_get_entry", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_set_default_action_firewall_drop_action(self, seqid, iprot, oprot):
        args = firewall_table_set_default_action_firewall_drop_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_set_default_action_firewall_drop_action_result()
        try:
            result.success = self._handler.firewall_table_set_default_action_firewall_drop_action(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_set_default_action_firewall_drop_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_set_default_action_forward_miss(self, seqid, iprot, oprot):
        args = forward_table_set_default_action_forward_miss_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_set_default_action_forward_miss_result()
        try:
            result.success = self._handler.forward_table_set_default_action_forward_miss(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_set_default_action_forward_miss", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_set_default_action_forward_ip_miss(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_set_default_action_forward_ip_miss_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_set_default_action_forward_ip_miss_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_set_default_action_forward_ip_miss(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_set_default_action_forward_ip_miss", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_set_default_action_state_check_drop_action(self, seqid, iprot, oprot):
        args = state_check_table_set_default_action_state_check_drop_action_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_set_default_action_state_check_drop_action_result()
        try:
            result.success = self._handler.state_check_table_set_default_action_state_check_drop_action(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_set_default_action_state_check_drop_action", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_set_property(self, seqid, iprot, oprot):
        args = firewall_table_set_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_set_property_result()
        try:
            self._handler.firewall_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value, args.prop_args)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_set_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_firewall_table_get_property(self, seqid, iprot, oprot):
        args = firewall_table_get_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = firewall_table_get_property_result()
        try:
            result.success = self._handler.firewall_table_get_property(args.sess_hdl, args.dev_id, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("firewall_table_get_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_set_property(self, seqid, iprot, oprot):
        args = forward_table_set_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_set_property_result()
        try:
            self._handler.forward_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value, args.prop_args)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_set_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_get_property(self, seqid, iprot, oprot):
        args = forward_table_get_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_get_property_result()
        try:
            result.success = self._handler.forward_table_get_property(args.sess_hdl, args.dev_id, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_get_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_set_property(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_set_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_set_property_result()
        try:
            self._handler.forward_table_by_dst_ip_set_property(args.sess_hdl, args.dev_id, args.property, args.value, args.prop_args)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_set_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_forward_table_by_dst_ip_get_property(self, seqid, iprot, oprot):
        args = forward_table_by_dst_ip_get_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = forward_table_by_dst_ip_get_property_result()
        try:
            result.success = self._handler.forward_table_by_dst_ip_get_property(args.sess_hdl, args.dev_id, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("forward_table_by_dst_ip_get_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_set_property(self, seqid, iprot, oprot):
        args = state_check_table_set_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_set_property_result()
        try:
            self._handler.state_check_table_set_property(args.sess_hdl, args.dev_id, args.property, args.value, args.prop_args)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_set_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_state_check_table_get_property(self, seqid, iprot, oprot):
        args = state_check_table_get_property_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = state_check_table_get_property_result()
        try:
            result.success = self._handler.state_check_table_get_property(args.sess_hdl, args.dev_id, args.property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidTableOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("state_check_table_get_property", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_learning_timeout(self, seqid, iprot, oprot):
        args = set_learning_timeout_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_learning_timeout_result()
        try:
            self._handler.set_learning_timeout(args.sess_hdl, args.dev_id, args.usecs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidLearnOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_learning_timeout", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tbl_dbg_counter_type_set(self, seqid, iprot, oprot):
        args = tbl_dbg_counter_type_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tbl_dbg_counter_type_set_result()
        try:
            self._handler.tbl_dbg_counter_type_set(args.dev_tgt, args.tbl_name, args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidDbgOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tbl_dbg_counter_type_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tbl_dbg_counter_get(self, seqid, iprot, oprot):
        args = tbl_dbg_counter_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tbl_dbg_counter_get_result()
        try:
            result.success = self._handler.tbl_dbg_counter_get(args.dev_tgt, args.tbl_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidDbgOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tbl_dbg_counter_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tbl_dbg_counter_clear(self, seqid, iprot, oprot):
        args = tbl_dbg_counter_clear_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tbl_dbg_counter_clear_result()
        try:
            self._handler.tbl_dbg_counter_clear(args.dev_tgt, args.tbl_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidDbgOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tbl_dbg_counter_clear", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tbl_dbg_counter_type_stage_set(self, seqid, iprot, oprot):
        args = tbl_dbg_counter_type_stage_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tbl_dbg_counter_type_stage_set_result()
        try:
            self._handler.tbl_dbg_counter_type_stage_set(args.dev_tgt, args.stage, args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidDbgOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tbl_dbg_counter_type_stage_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tbl_dbg_counter_stage_get(self, seqid, iprot, oprot):
        args = tbl_dbg_counter_stage_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tbl_dbg_counter_stage_get_result()
        try:
            result.success = self._handler.tbl_dbg_counter_stage_get(args.dev_tgt, args.stage)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidDbgOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tbl_dbg_counter_stage_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tbl_dbg_counter_stage_clear(self, seqid, iprot, oprot):
        args = tbl_dbg_counter_stage_clear_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tbl_dbg_counter_stage_clear_result()
        try:
            self._handler.tbl_dbg_counter_stage_clear(args.dev_tgt, args.stage)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidDbgOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tbl_dbg_counter_stage_clear", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_create(self, seqid, iprot, oprot):
        args = snapshot_create_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_create_result()
        try:
            result.success = self._handler.snapshot_create(args.dev_tgt, args.start_stage, args.end_stage, args.direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_create", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_delete(self, seqid, iprot, oprot):
        args = snapshot_delete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_delete_result()
        try:
            self._handler.snapshot_delete(args.handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_delete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_state_set(self, seqid, iprot, oprot):
        args = snapshot_state_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_state_set_result()
        try:
            self._handler.snapshot_state_set(args.handle, args.state, args.usecs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_state_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_state_get(self, seqid, iprot, oprot):
        args = snapshot_state_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_state_get_result()
        try:
            result.success = self._handler.snapshot_state_get(args.handle, args.pipe)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_state_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_timer_enable(self, seqid, iprot, oprot):
        args = snapshot_timer_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_timer_enable_result()
        try:
            self._handler.snapshot_timer_enable(args.handle, args.disable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_timer_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_capture_trigger_set(self, seqid, iprot, oprot):
        args = snapshot_capture_trigger_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_capture_trigger_set_result()
        try:
            self._handler.snapshot_capture_trigger_set(args.handle, args.trig_spec, args.trig_spec2)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_capture_trigger_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_capture_data_get(self, seqid, iprot, oprot):
        args = snapshot_capture_data_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_capture_data_get_result()
        try:
            result.success = self._handler.snapshot_capture_data_get(args.handle, args.pipe, args.stage_id, args.field_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_capture_data_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_capture_tbl_data_get(self, seqid, iprot, oprot):
        args = snapshot_capture_tbl_data_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_capture_tbl_data_get_result()
        try:
            result.success = self._handler.snapshot_capture_tbl_data_get(args.handle, args.pipe, args.table_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_capture_tbl_data_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_capture_trigger_fields_clr(self, seqid, iprot, oprot):
        args = snapshot_capture_trigger_fields_clr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_capture_trigger_fields_clr_result()
        try:
            self._handler.snapshot_capture_trigger_fields_clr(args.handle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_capture_trigger_fields_clr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_snapshot_field_in_scope(self, seqid, iprot, oprot):
        args = snapshot_field_in_scope_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = snapshot_field_in_scope_result()
        try:
            result.success = self._handler.snapshot_field_in_scope(args.dev_tgt, args.stage, args.direction, args.field_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidSnapshotOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("snapshot_field_in_scope", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class firewall_table_match_spec_to_entry_hdl_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_match_spec_to_entry_hdl_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_match_spec_to_entry_hdl_args)
firewall_table_match_spec_to_entry_hdl_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 3
)


class firewall_table_match_spec_to_entry_hdl_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_match_spec_to_entry_hdl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_match_spec_to_entry_hdl_result)
firewall_table_match_spec_to_entry_hdl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_match_spec_to_entry_hdl_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_match_spec_to_entry_hdl_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_match_spec_to_entry_hdl_args)
forward_table_match_spec_to_entry_hdl_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 3
)


class forward_table_match_spec_to_entry_hdl_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_match_spec_to_entry_hdl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_match_spec_to_entry_hdl_result)
forward_table_match_spec_to_entry_hdl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_match_spec_to_entry_hdl_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_match_spec_to_entry_hdl_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_match_spec_to_entry_hdl_args)
forward_table_by_dst_ip_match_spec_to_entry_hdl_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 3
)


class forward_table_by_dst_ip_match_spec_to_entry_hdl_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_match_spec_to_entry_hdl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_match_spec_to_entry_hdl_result)
forward_table_by_dst_ip_match_spec_to_entry_hdl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_match_spec_to_entry_hdl_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_match_spec_to_entry_hdl_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_match_spec_to_entry_hdl_args)
state_check_table_match_spec_to_entry_hdl_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_match_spec_to_entry_hdl_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_match_spec_to_entry_hdl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_match_spec_to_entry_hdl_result)
state_check_table_match_spec_to_entry_hdl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_add_with_firewall_allow_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_add_with_firewall_allow_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_add_with_firewall_allow_action_args)
firewall_table_table_add_with_firewall_allow_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 3
)


class firewall_table_table_add_with_firewall_allow_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_add_with_firewall_allow_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_add_with_firewall_allow_action_result)
firewall_table_table_add_with_firewall_allow_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_add_with_firewall_drop_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_add_with_firewall_drop_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_add_with_firewall_drop_action_args)
firewall_table_table_add_with_firewall_drop_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 3
)


class firewall_table_table_add_with_firewall_drop_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_add_with_firewall_drop_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_add_with_firewall_drop_action_result)
firewall_table_table_add_with_firewall_drop_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_add_with_forward_hit_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec
        self.action_spec = action_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_spec = main_forward_hit_action_spec_t()
                    self.action_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_add_with_forward_hit_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.action_spec is not None:
            oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
            self.action_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_add_with_forward_hit_args)
forward_table_table_add_with_forward_hit_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 3
    (4, TType.STRUCT, 'action_spec', [main_forward_hit_action_spec_t, None], None, ),  # 4
)


class forward_table_table_add_with_forward_hit_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_add_with_forward_hit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_add_with_forward_hit_result)
forward_table_table_add_with_forward_hit_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_add_with_forward_miss_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_add_with_forward_miss_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_add_with_forward_miss_args)
forward_table_table_add_with_forward_miss_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 3
)


class forward_table_table_add_with_forward_miss_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_add_with_forward_miss_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_add_with_forward_miss_result)
forward_table_table_add_with_forward_miss_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_add_with_forward_ip_hit_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec
        self.action_spec = action_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_spec = main_forward_ip_hit_action_spec_t()
                    self.action_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_add_with_forward_ip_hit_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.action_spec is not None:
            oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
            self.action_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_add_with_forward_ip_hit_args)
forward_table_by_dst_ip_table_add_with_forward_ip_hit_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 3
    (4, TType.STRUCT, 'action_spec', [main_forward_ip_hit_action_spec_t, None], None, ),  # 4
)


class forward_table_by_dst_ip_table_add_with_forward_ip_hit_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_add_with_forward_ip_hit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_add_with_forward_ip_hit_result)
forward_table_by_dst_ip_table_add_with_forward_ip_hit_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_add_with_forward_ip_miss_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_add_with_forward_ip_miss_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_add_with_forward_ip_miss_args)
forward_table_by_dst_ip_table_add_with_forward_ip_miss_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 3
)


class forward_table_by_dst_ip_table_add_with_forward_ip_miss_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_add_with_forward_ip_miss_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_add_with_forward_ip_miss_result)
forward_table_by_dst_ip_table_add_with_forward_ip_miss_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_add_with_state_check_allow_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_add_with_state_check_allow_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_add_with_state_check_allow_action_args)
state_check_table_table_add_with_state_check_allow_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_add_with_state_check_allow_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_add_with_state_check_allow_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_add_with_state_check_allow_action_result)
state_check_table_table_add_with_state_check_allow_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_add_with_state_check_to_controller_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_add_with_state_check_to_controller_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_add_with_state_check_to_controller_action_args)
state_check_table_table_add_with_state_check_to_controller_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_add_with_state_check_to_controller_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_add_with_state_check_to_controller_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_add_with_state_check_to_controller_action_result)
state_check_table_table_add_with_state_check_to_controller_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_add_with_state_check_drop_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_add_with_state_check_drop_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_add_with_state_check_drop_action_args)
state_check_table_table_add_with_state_check_drop_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_add_with_state_check_drop_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_add_with_state_check_drop_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_add_with_state_check_drop_action_result)
state_check_table_table_add_with_state_check_drop_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_modify_with_firewall_allow_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_allow_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_allow_action_args)
firewall_table_table_modify_with_firewall_allow_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class firewall_table_table_modify_with_firewall_allow_action_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_allow_action_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_allow_action_result)
firewall_table_table_modify_with_firewall_allow_action_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_modify_with_firewall_allow_action_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_allow_action_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_allow_action_by_match_spec_args)
firewall_table_table_modify_with_firewall_allow_action_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 3
)


class firewall_table_table_modify_with_firewall_allow_action_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_allow_action_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_allow_action_by_match_spec_result)
firewall_table_table_modify_with_firewall_allow_action_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_modify_with_firewall_drop_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_drop_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_drop_action_args)
firewall_table_table_modify_with_firewall_drop_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class firewall_table_table_modify_with_firewall_drop_action_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_drop_action_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_drop_action_result)
firewall_table_table_modify_with_firewall_drop_action_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_modify_with_firewall_drop_action_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_drop_action_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_drop_action_by_match_spec_args)
firewall_table_table_modify_with_firewall_drop_action_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 3
)


class firewall_table_table_modify_with_firewall_drop_action_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_modify_with_firewall_drop_action_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_modify_with_firewall_drop_action_by_match_spec_result)
firewall_table_table_modify_with_firewall_drop_action_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_modify_with_forward_hit_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry
     - action_spec

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None, action_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry
        self.action_spec = action_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_spec = main_forward_hit_action_spec_t()
                    self.action_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_hit_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        if self.action_spec is not None:
            oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
            self.action_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_hit_args)
forward_table_table_modify_with_forward_hit_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
    (4, TType.STRUCT, 'action_spec', [main_forward_hit_action_spec_t, None], None, ),  # 4
)


class forward_table_table_modify_with_forward_hit_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_hit_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_hit_result)
forward_table_table_modify_with_forward_hit_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_modify_with_forward_hit_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec
        self.action_spec = action_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_spec = main_forward_hit_action_spec_t()
                    self.action_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_hit_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.action_spec is not None:
            oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
            self.action_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_hit_by_match_spec_args)
forward_table_table_modify_with_forward_hit_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 3
    (4, TType.STRUCT, 'action_spec', [main_forward_hit_action_spec_t, None], None, ),  # 4
)


class forward_table_table_modify_with_forward_hit_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_hit_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_hit_by_match_spec_result)
forward_table_table_modify_with_forward_hit_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_modify_with_forward_miss_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_miss_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_miss_args)
forward_table_table_modify_with_forward_miss_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class forward_table_table_modify_with_forward_miss_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_miss_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_miss_result)
forward_table_table_modify_with_forward_miss_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_modify_with_forward_miss_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_miss_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_miss_by_match_spec_args)
forward_table_table_modify_with_forward_miss_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 3
)


class forward_table_table_modify_with_forward_miss_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_modify_with_forward_miss_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_modify_with_forward_miss_by_match_spec_result)
forward_table_table_modify_with_forward_miss_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_hit_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry
     - action_spec

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None, action_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry
        self.action_spec = action_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_spec = main_forward_ip_hit_action_spec_t()
                    self.action_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_hit_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        if self.action_spec is not None:
            oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
            self.action_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_hit_args)
forward_table_by_dst_ip_table_modify_with_forward_ip_hit_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
    (4, TType.STRUCT, 'action_spec', [main_forward_ip_hit_action_spec_t, None], None, ),  # 4
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_hit_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_hit_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_hit_result)
forward_table_by_dst_ip_table_modify_with_forward_ip_hit_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec
     - action_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None, action_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec
        self.action_spec = action_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.action_spec = main_forward_ip_hit_action_spec_t()
                    self.action_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.action_spec is not None:
            oprot.writeFieldBegin('action_spec', TType.STRUCT, 4)
            self.action_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_args)
forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 3
    (4, TType.STRUCT, 'action_spec', [main_forward_ip_hit_action_spec_t, None], None, ),  # 4
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_result)
forward_table_by_dst_ip_table_modify_with_forward_ip_hit_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_miss_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_miss_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_miss_args)
forward_table_by_dst_ip_table_modify_with_forward_ip_miss_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_miss_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_miss_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_miss_result)
forward_table_by_dst_ip_table_modify_with_forward_ip_miss_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_args)
forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 3
)


class forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_result)
forward_table_by_dst_ip_table_modify_with_forward_ip_miss_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_modify_with_state_check_allow_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_allow_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_allow_action_args)
state_check_table_table_modify_with_state_check_allow_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class state_check_table_table_modify_with_state_check_allow_action_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_allow_action_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_allow_action_result)
state_check_table_table_modify_with_state_check_allow_action_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_modify_with_state_check_allow_action_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_allow_action_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_allow_action_by_match_spec_args)
state_check_table_table_modify_with_state_check_allow_action_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_modify_with_state_check_allow_action_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_allow_action_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_allow_action_by_match_spec_result)
state_check_table_table_modify_with_state_check_allow_action_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_modify_with_state_check_to_controller_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_to_controller_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_to_controller_action_args)
state_check_table_table_modify_with_state_check_to_controller_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class state_check_table_table_modify_with_state_check_to_controller_action_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_to_controller_action_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_to_controller_action_result)
state_check_table_table_modify_with_state_check_to_controller_action_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_args)
state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_result)
state_check_table_table_modify_with_state_check_to_controller_action_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_modify_with_state_check_drop_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_drop_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_drop_action_args)
state_check_table_table_modify_with_state_check_drop_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class state_check_table_table_modify_with_state_check_drop_action_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_drop_action_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_drop_action_result)
state_check_table_table_modify_with_state_check_drop_action_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_modify_with_state_check_drop_action_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_drop_action_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_drop_action_by_match_spec_args)
state_check_table_table_modify_with_state_check_drop_action_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_modify_with_state_check_drop_action_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_modify_with_state_check_drop_action_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_modify_with_state_check_drop_action_by_match_spec_result)
state_check_table_table_modify_with_state_check_drop_action_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_delete_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_delete_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_delete_args)
firewall_table_table_delete_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class firewall_table_table_delete_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_delete_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_delete_result)
firewall_table_table_delete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_delete_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_firewall_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_delete_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_delete_by_match_spec_args)
firewall_table_table_delete_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_firewall_table_match_spec_t, None], None, ),  # 3
)


class firewall_table_table_delete_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_delete_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_delete_by_match_spec_result)
firewall_table_table_delete_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_delete_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_delete_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_delete_args)
forward_table_table_delete_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class forward_table_table_delete_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_delete_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_delete_result)
forward_table_table_delete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_delete_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_delete_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_delete_by_match_spec_args)
forward_table_table_delete_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_match_spec_t, None], None, ),  # 3
)


class forward_table_table_delete_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_delete_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_delete_by_match_spec_result)
forward_table_table_delete_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_delete_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_delete_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_delete_args)
forward_table_by_dst_ip_table_delete_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class forward_table_by_dst_ip_table_delete_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_delete_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_delete_result)
forward_table_by_dst_ip_table_delete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_delete_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_forward_table_by_dst_ip_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_delete_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_delete_by_match_spec_args)
forward_table_by_dst_ip_table_delete_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_forward_table_by_dst_ip_match_spec_t, None], None, ),  # 3
)


class forward_table_by_dst_ip_table_delete_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_delete_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_delete_by_match_spec_result)
forward_table_by_dst_ip_table_delete_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_delete_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry = entry

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_delete_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry is not None:
            oprot.writeFieldBegin('entry', TType.I32, 3)
            oprot.writeI32(self.entry)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_delete_args)
state_check_table_table_delete_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry', None, None, ),  # 3
)


class state_check_table_table_delete_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_delete_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_delete_result)
state_check_table_table_delete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_delete_by_match_spec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - match_spec

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, match_spec=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.match_spec = match_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.match_spec = main_state_check_table_match_spec_t()
                    self.match_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_delete_by_match_spec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.match_spec is not None:
            oprot.writeFieldBegin('match_spec', TType.STRUCT, 3)
            self.match_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_delete_by_match_spec_args)
state_check_table_table_delete_by_match_spec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.STRUCT, 'match_spec', [main_state_check_table_match_spec_t, None], None, ),  # 3
)


class state_check_table_table_delete_by_match_spec_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_delete_by_match_spec_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_delete_by_match_spec_result)
state_check_table_table_delete_by_match_spec_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_get_default_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_get_default_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_get_default_entry_handle_args)
firewall_table_table_get_default_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class firewall_table_table_get_default_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_get_default_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_get_default_entry_handle_result)
firewall_table_table_get_default_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_get_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_get_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 3)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_get_default_entry_args)
firewall_table_table_get_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.BOOL, 'read_from_hw', None, None, ),  # 3
)


class firewall_table_table_get_default_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_firewall_table_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_get_default_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_get_default_entry_result)
firewall_table_table_get_default_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_firewall_table_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_get_default_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_get_default_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_get_default_entry_handle_args)
forward_table_table_get_default_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_table_get_default_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_get_default_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_get_default_entry_handle_result)
forward_table_table_get_default_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_get_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_get_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 3)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_get_default_entry_args)
forward_table_table_get_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.BOOL, 'read_from_hw', None, None, ),  # 3
)


class forward_table_table_get_default_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_forward_table_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_get_default_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_get_default_entry_result)
forward_table_table_get_default_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_forward_table_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_get_default_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_get_default_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_get_default_entry_handle_args)
forward_table_by_dst_ip_table_get_default_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_by_dst_ip_table_get_default_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_get_default_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_get_default_entry_handle_result)
forward_table_by_dst_ip_table_get_default_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_get_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_get_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 3)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_get_default_entry_args)
forward_table_by_dst_ip_table_get_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.BOOL, 'read_from_hw', None, None, ),  # 3
)


class forward_table_by_dst_ip_table_get_default_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_forward_table_by_dst_ip_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_get_default_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_get_default_entry_result)
forward_table_by_dst_ip_table_get_default_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_forward_table_by_dst_ip_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_get_default_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_get_default_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_get_default_entry_handle_args)
state_check_table_table_get_default_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class state_check_table_table_get_default_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_get_default_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_get_default_entry_handle_result)
state_check_table_table_get_default_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_get_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_get_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 3)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_get_default_entry_args)
state_check_table_table_get_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.BOOL, 'read_from_hw', None, None, ),  # 3
)


class state_check_table_table_get_default_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_state_check_table_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_get_default_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_get_default_entry_result)
state_check_table_table_get_default_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_state_check_table_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_table_reset_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_reset_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_reset_default_entry_args)
firewall_table_table_reset_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class firewall_table_table_reset_default_entry_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_table_reset_default_entry_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_table_reset_default_entry_result)
firewall_table_table_reset_default_entry_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_table_reset_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_reset_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_reset_default_entry_args)
forward_table_table_reset_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_table_reset_default_entry_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_table_reset_default_entry_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_table_reset_default_entry_result)
forward_table_table_reset_default_entry_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_table_reset_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_reset_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_reset_default_entry_args)
forward_table_by_dst_ip_table_reset_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_by_dst_ip_table_reset_default_entry_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_table_reset_default_entry_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_table_reset_default_entry_result)
forward_table_by_dst_ip_table_reset_default_entry_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_table_reset_default_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_reset_default_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_reset_default_entry_args)
state_check_table_table_reset_default_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class state_check_table_table_reset_default_entry_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_table_reset_default_entry_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_table_reset_default_entry_result)
state_check_table_table_reset_default_entry_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_get_entry_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_entry_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_entry_count_args)
firewall_table_get_entry_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class firewall_table_get_entry_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_entry_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_entry_count_result)
firewall_table_get_entry_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_get_entry_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_entry_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_entry_count_args)
forward_table_get_entry_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_get_entry_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_entry_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_entry_count_result)
forward_table_get_entry_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_get_entry_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_entry_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_entry_count_args)
forward_table_by_dst_ip_get_entry_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_by_dst_ip_get_entry_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_entry_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_entry_count_result)
forward_table_by_dst_ip_get_entry_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_get_entry_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_entry_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_entry_count_args)
state_check_table_get_entry_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class state_check_table_get_entry_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_entry_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_entry_count_result)
state_check_table_get_entry_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_get_first_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_first_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_first_entry_handle_args)
firewall_table_get_first_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class firewall_table_get_first_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_first_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_first_entry_handle_result)
firewall_table_get_first_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_get_next_entry_handles_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - entry_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, entry_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.entry_hdl = entry_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_next_entry_handles_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_next_entry_handles_args)
firewall_table_get_next_entry_handles_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class firewall_table_get_next_entry_handles_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_next_entry_handles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter27 in self.success:
                oprot.writeI32(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_next_entry_handles_result)
firewall_table_get_next_entry_handles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_get_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry_hdl = entry_hdl
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_entry_args)
firewall_table_get_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ),  # 4
)


class firewall_table_get_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_firewall_table_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_entry_result)
firewall_table_get_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_firewall_table_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_get_first_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_first_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_first_entry_handle_args)
forward_table_get_first_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_get_first_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_first_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_first_entry_handle_result)
forward_table_get_first_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_get_next_entry_handles_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - entry_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, entry_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.entry_hdl = entry_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_next_entry_handles_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_next_entry_handles_args)
forward_table_get_next_entry_handles_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class forward_table_get_next_entry_handles_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI32()
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_next_entry_handles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter34 in self.success:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_next_entry_handles_result)
forward_table_get_next_entry_handles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_get_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry_hdl = entry_hdl
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_entry_args)
forward_table_get_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ),  # 4
)


class forward_table_get_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_forward_table_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_entry_result)
forward_table_get_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_forward_table_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_get_first_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_first_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_first_entry_handle_args)
forward_table_by_dst_ip_get_first_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_by_dst_ip_get_first_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_first_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_first_entry_handle_result)
forward_table_by_dst_ip_get_first_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_get_next_entry_handles_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - entry_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, entry_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.entry_hdl = entry_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_next_entry_handles_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_next_entry_handles_args)
forward_table_by_dst_ip_get_next_entry_handles_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class forward_table_by_dst_ip_get_next_entry_handles_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI32()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_next_entry_handles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter41 in self.success:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_next_entry_handles_result)
forward_table_by_dst_ip_get_next_entry_handles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_get_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry_hdl = entry_hdl
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_entry_args)
forward_table_by_dst_ip_get_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ),  # 4
)


class forward_table_by_dst_ip_get_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_forward_table_by_dst_ip_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_entry_result)
forward_table_by_dst_ip_get_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_forward_table_by_dst_ip_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_get_first_entry_handle_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_first_entry_handle_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_first_entry_handle_args)
state_check_table_get_first_entry_handle_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class state_check_table_get_first_entry_handle_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_first_entry_handle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_first_entry_handle_result)
state_check_table_get_first_entry_handle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_get_next_entry_handles_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - entry_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, entry_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.entry_hdl = entry_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_next_entry_handles_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_next_entry_handles_args)
state_check_table_get_next_entry_handles_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class state_check_table_get_next_entry_handles_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI32()
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_next_entry_handles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter48 in self.success:
                oprot.writeI32(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_next_entry_handles_result)
state_check_table_get_next_entry_handles_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_get_entry_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - entry_hdl
     - read_from_hw

    """


    def __init__(self, sess_hdl=None, dev_id=None, entry_hdl=None, read_from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.entry_hdl = entry_hdl
        self.read_from_hw = read_from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.entry_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.read_from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_entry_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.entry_hdl is not None:
            oprot.writeFieldBegin('entry_hdl', TType.I32, 3)
            oprot.writeI32(self.entry_hdl)
            oprot.writeFieldEnd()
        if self.read_from_hw is not None:
            oprot.writeFieldBegin('read_from_hw', TType.BOOL, 4)
            oprot.writeBool(self.read_from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_entry_args)
state_check_table_get_entry_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'entry_hdl', None, None, ),  # 3
    (4, TType.BOOL, 'read_from_hw', None, None, ),  # 4
)


class state_check_table_get_entry_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_state_check_table_entry_desc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_entry_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_entry_result)
state_check_table_get_entry_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_state_check_table_entry_desc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_set_default_action_firewall_drop_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_set_default_action_firewall_drop_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_set_default_action_firewall_drop_action_args)
firewall_table_set_default_action_firewall_drop_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class firewall_table_set_default_action_firewall_drop_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_set_default_action_firewall_drop_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_set_default_action_firewall_drop_action_result)
firewall_table_set_default_action_firewall_drop_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_set_default_action_forward_miss_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_set_default_action_forward_miss_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_set_default_action_forward_miss_args)
forward_table_set_default_action_forward_miss_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_set_default_action_forward_miss_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_set_default_action_forward_miss_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_set_default_action_forward_miss_result)
forward_table_set_default_action_forward_miss_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_set_default_action_forward_ip_miss_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_set_default_action_forward_ip_miss_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_set_default_action_forward_ip_miss_args)
forward_table_by_dst_ip_set_default_action_forward_ip_miss_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class forward_table_by_dst_ip_set_default_action_forward_ip_miss_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_set_default_action_forward_ip_miss_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_set_default_action_forward_ip_miss_result)
forward_table_by_dst_ip_set_default_action_forward_ip_miss_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_set_default_action_state_check_drop_action_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_set_default_action_state_check_drop_action_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_set_default_action_state_check_drop_action_args)
state_check_table_set_default_action_state_check_drop_action_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class state_check_table_set_default_action_state_check_drop_action_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_set_default_action_state_check_drop_action_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_set_default_action_state_check_drop_action_result)
state_check_table_set_default_action_state_check_drop_action_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_set_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property
     - value
     - prop_args

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None, prop_args=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property
        self.value = value
        self.prop_args = prop_args

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.prop_args = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_set_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 4)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.prop_args is not None:
            oprot.writeFieldBegin('prop_args', TType.I32, 5)
            oprot.writeI32(self.prop_args)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_set_property_args)
firewall_table_set_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
    (4, TType.I32, 'value', None, None, ),  # 4
    (5, TType.I32, 'prop_args', None, None, ),  # 5
)


class firewall_table_set_property_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_set_property_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_set_property_result)
firewall_table_set_property_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class firewall_table_get_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_property_args)
firewall_table_get_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
)


class firewall_table_get_property_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = tbl_property_value_args_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('firewall_table_get_property_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(firewall_table_get_property_result)
firewall_table_get_property_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [tbl_property_value_args_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_set_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property
     - value
     - prop_args

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None, prop_args=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property
        self.value = value
        self.prop_args = prop_args

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.prop_args = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_set_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 4)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.prop_args is not None:
            oprot.writeFieldBegin('prop_args', TType.I32, 5)
            oprot.writeI32(self.prop_args)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_set_property_args)
forward_table_set_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
    (4, TType.I32, 'value', None, None, ),  # 4
    (5, TType.I32, 'prop_args', None, None, ),  # 5
)


class forward_table_set_property_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_set_property_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_set_property_result)
forward_table_set_property_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_get_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_property_args)
forward_table_get_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
)


class forward_table_get_property_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = tbl_property_value_args_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_get_property_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_get_property_result)
forward_table_get_property_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [tbl_property_value_args_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_set_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property
     - value
     - prop_args

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None, prop_args=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property
        self.value = value
        self.prop_args = prop_args

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.prop_args = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_set_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 4)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.prop_args is not None:
            oprot.writeFieldBegin('prop_args', TType.I32, 5)
            oprot.writeI32(self.prop_args)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_set_property_args)
forward_table_by_dst_ip_set_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
    (4, TType.I32, 'value', None, None, ),  # 4
    (5, TType.I32, 'prop_args', None, None, ),  # 5
)


class forward_table_by_dst_ip_set_property_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_set_property_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_set_property_result)
forward_table_by_dst_ip_set_property_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class forward_table_by_dst_ip_get_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_property_args)
forward_table_by_dst_ip_get_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
)


class forward_table_by_dst_ip_get_property_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = tbl_property_value_args_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('forward_table_by_dst_ip_get_property_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(forward_table_by_dst_ip_get_property_result)
forward_table_by_dst_ip_get_property_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [tbl_property_value_args_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_set_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property
     - value
     - prop_args

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None, value=None, prop_args=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property
        self.value = value
        self.prop_args = prop_args

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.prop_args = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_set_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 4)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.prop_args is not None:
            oprot.writeFieldBegin('prop_args', TType.I32, 5)
            oprot.writeI32(self.prop_args)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_set_property_args)
state_check_table_set_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
    (4, TType.I32, 'value', None, None, ),  # 4
    (5, TType.I32, 'prop_args', None, None, ),  # 5
)


class state_check_table_set_property_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_set_property_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_set_property_result)
state_check_table_set_property_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class state_check_table_get_property_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - property

    """


    def __init__(self, sess_hdl=None, dev_id=None, property=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.property = property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_property_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.property is not None:
            oprot.writeFieldBegin('property', TType.I32, 3)
            oprot.writeI32(self.property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_property_args)
state_check_table_get_property_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'property', None, None, ),  # 3
)


class state_check_table_get_property_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = tbl_property_value_args_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidTableOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('state_check_table_get_property_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(state_check_table_get_property_result)
state_check_table_get_property_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [tbl_property_value_args_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidTableOperation, None], None, ),  # 1
)


class set_learning_timeout_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - usecs

    """


    def __init__(self, sess_hdl=None, dev_id=None, usecs=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.usecs = usecs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.dev_id = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.usecs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_learning_timeout_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.BYTE, 2)
            oprot.writeByte(self.dev_id)
            oprot.writeFieldEnd()
        if self.usecs is not None:
            oprot.writeFieldBegin('usecs', TType.I32, 3)
            oprot.writeI32(self.usecs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_learning_timeout_args)
set_learning_timeout_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BYTE, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'usecs', None, None, ),  # 3
)


class set_learning_timeout_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidLearnOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_learning_timeout_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_learning_timeout_result)
set_learning_timeout_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidLearnOperation, None], None, ),  # 1
)


class tbl_dbg_counter_type_set_args(object):
    """
    Attributes:
     - dev_tgt
     - tbl_name
     - type

    """


    def __init__(self, dev_tgt=None, tbl_name=None, type=None,):
        self.dev_tgt = dev_tgt
        self.tbl_name = tbl_name
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_type_set_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_type_set_args)
tbl_dbg_counter_type_set_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
)


class tbl_dbg_counter_type_set_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidDbgOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_type_set_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_type_set_result)
tbl_dbg_counter_type_set_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidDbgOperation, None], None, ),  # 1
)


class tbl_dbg_counter_get_args(object):
    """
    Attributes:
     - dev_tgt
     - tbl_name

    """


    def __init__(self, dev_tgt=None, tbl_name=None,):
        self.dev_tgt = dev_tgt
        self.tbl_name = tbl_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_get_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_get_args)
tbl_dbg_counter_get_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
)


class tbl_dbg_counter_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TblCntrInfo_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidDbgOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_get_result)
tbl_dbg_counter_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TblCntrInfo_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidDbgOperation, None], None, ),  # 1
)


class tbl_dbg_counter_clear_args(object):
    """
    Attributes:
     - dev_tgt
     - tbl_name

    """


    def __init__(self, dev_tgt=None, tbl_name=None,):
        self.dev_tgt = dev_tgt
        self.tbl_name = tbl_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_clear_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_clear_args)
tbl_dbg_counter_clear_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
)


class tbl_dbg_counter_clear_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidDbgOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_clear_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_clear_result)
tbl_dbg_counter_clear_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidDbgOperation, None], None, ),  # 1
)


class tbl_dbg_counter_type_stage_set_args(object):
    """
    Attributes:
     - dev_tgt
     - stage
     - type

    """


    def __init__(self, dev_tgt=None, stage=None, type=None,):
        self.dev_tgt = dev_tgt
        self.stage = stage
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.stage = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_type_stage_set_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.stage is not None:
            oprot.writeFieldBegin('stage', TType.BYTE, 2)
            oprot.writeByte(self.stage)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_type_stage_set_args)
tbl_dbg_counter_type_stage_set_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.BYTE, 'stage', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
)


class tbl_dbg_counter_type_stage_set_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidDbgOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_type_stage_set_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_type_stage_set_result)
tbl_dbg_counter_type_stage_set_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidDbgOperation, None], None, ),  # 1
)


class tbl_dbg_counter_stage_get_args(object):
    """
    Attributes:
     - dev_tgt
     - stage

    """


    def __init__(self, dev_tgt=None, stage=None,):
        self.dev_tgt = dev_tgt
        self.stage = stage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.stage = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_stage_get_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.stage is not None:
            oprot.writeFieldBegin('stage', TType.BYTE, 2)
            oprot.writeByte(self.stage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_stage_get_args)
tbl_dbg_counter_stage_get_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.BYTE, 'stage', None, None, ),  # 2
)


class tbl_dbg_counter_stage_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TblDbgStageInfo_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidDbgOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_stage_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_stage_get_result)
tbl_dbg_counter_stage_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TblDbgStageInfo_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidDbgOperation, None], None, ),  # 1
)


class tbl_dbg_counter_stage_clear_args(object):
    """
    Attributes:
     - dev_tgt
     - stage

    """


    def __init__(self, dev_tgt=None, stage=None,):
        self.dev_tgt = dev_tgt
        self.stage = stage

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.stage = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_stage_clear_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.stage is not None:
            oprot.writeFieldBegin('stage', TType.BYTE, 2)
            oprot.writeByte(self.stage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_stage_clear_args)
tbl_dbg_counter_stage_clear_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.BYTE, 'stage', None, None, ),  # 2
)


class tbl_dbg_counter_stage_clear_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidDbgOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tbl_dbg_counter_stage_clear_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tbl_dbg_counter_stage_clear_result)
tbl_dbg_counter_stage_clear_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidDbgOperation, None], None, ),  # 1
)


class snapshot_create_args(object):
    """
    Attributes:
     - dev_tgt
     - start_stage
     - end_stage
     - direction

    """


    def __init__(self, dev_tgt=None, start_stage=None, end_stage=None, direction=None,):
        self.dev_tgt = dev_tgt
        self.start_stage = start_stage
        self.end_stage = end_stage
        self.direction = direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.start_stage = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.end_stage = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.direction = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_create_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.start_stage is not None:
            oprot.writeFieldBegin('start_stage', TType.BYTE, 2)
            oprot.writeByte(self.start_stage)
            oprot.writeFieldEnd()
        if self.end_stage is not None:
            oprot.writeFieldBegin('end_stage', TType.BYTE, 3)
            oprot.writeByte(self.end_stage)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.BYTE, 4)
            oprot.writeByte(self.direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_create_args)
snapshot_create_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.BYTE, 'start_stage', None, None, ),  # 2
    (3, TType.BYTE, 'end_stage', None, None, ),  # 3
    (4, TType.BYTE, 'direction', None, None, ),  # 4
)


class snapshot_create_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_create_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_create_result)
snapshot_create_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_delete_args(object):
    """
    Attributes:
     - handle

    """


    def __init__(self, handle=None,):
        self.handle = handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_delete_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_delete_args)
snapshot_delete_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
)


class snapshot_delete_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_delete_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_delete_result)
snapshot_delete_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_state_set_args(object):
    """
    Attributes:
     - handle
     - state
     - usecs

    """


    def __init__(self, handle=None, state=None, usecs=None,):
        self.handle = handle
        self.state = state
        self.usecs = usecs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.usecs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_state_set_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        if self.state is not None:
            oprot.writeFieldBegin('state', TType.I32, 2)
            oprot.writeI32(self.state)
            oprot.writeFieldEnd()
        if self.usecs is not None:
            oprot.writeFieldBegin('usecs', TType.I32, 3)
            oprot.writeI32(self.usecs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_state_set_args)
snapshot_state_set_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
    (2, TType.I32, 'state', None, None, ),  # 2
    (3, TType.I32, 'usecs', None, None, ),  # 3
)


class snapshot_state_set_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_state_set_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_state_set_result)
snapshot_state_set_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_state_get_args(object):
    """
    Attributes:
     - handle
     - pipe

    """


    def __init__(self, handle=None, pipe=None,):
        self.handle = handle
        self.pipe = pipe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pipe = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_state_get_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        if self.pipe is not None:
            oprot.writeFieldBegin('pipe', TType.I16, 2)
            oprot.writeI16(self.pipe)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_state_get_args)
snapshot_state_get_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
    (2, TType.I16, 'pipe', None, None, ),  # 2
)


class snapshot_state_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_state_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_state_get_result)
snapshot_state_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_timer_enable_args(object):
    """
    Attributes:
     - handle
     - disable

    """


    def __init__(self, handle=None, disable=None,):
        self.handle = handle
        self.disable = disable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.disable = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_timer_enable_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        if self.disable is not None:
            oprot.writeFieldBegin('disable', TType.BYTE, 2)
            oprot.writeByte(self.disable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_timer_enable_args)
snapshot_timer_enable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
    (2, TType.BYTE, 'disable', None, None, ),  # 2
)


class snapshot_timer_enable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_timer_enable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_timer_enable_result)
snapshot_timer_enable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_capture_trigger_set_args(object):
    """
    Attributes:
     - handle
     - trig_spec
     - trig_spec2

    """


    def __init__(self, handle=None, trig_spec=None, trig_spec2=None,):
        self.handle = handle
        self.trig_spec = trig_spec
        self.trig_spec2 = trig_spec2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.trig_spec = main_snapshot_trig_spec_t()
                    self.trig_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.trig_spec2 = main_snapshot_trig_spec_t()
                    self.trig_spec2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_trigger_set_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        if self.trig_spec is not None:
            oprot.writeFieldBegin('trig_spec', TType.STRUCT, 2)
            self.trig_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.trig_spec2 is not None:
            oprot.writeFieldBegin('trig_spec2', TType.STRUCT, 3)
            self.trig_spec2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_trigger_set_args)
snapshot_capture_trigger_set_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
    (2, TType.STRUCT, 'trig_spec', [main_snapshot_trig_spec_t, None], None, ),  # 2
    (3, TType.STRUCT, 'trig_spec2', [main_snapshot_trig_spec_t, None], None, ),  # 3
)


class snapshot_capture_trigger_set_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_trigger_set_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_trigger_set_result)
snapshot_capture_trigger_set_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_capture_data_get_args(object):
    """
    Attributes:
     - handle
     - pipe
     - stage_id
     - field_name

    """


    def __init__(self, handle=None, pipe=None, stage_id=None, field_name=None,):
        self.handle = handle
        self.pipe = pipe
        self.stage_id = stage_id
        self.field_name = field_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pipe = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.stage_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.field_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_data_get_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        if self.pipe is not None:
            oprot.writeFieldBegin('pipe', TType.I16, 2)
            oprot.writeI16(self.pipe)
            oprot.writeFieldEnd()
        if self.stage_id is not None:
            oprot.writeFieldBegin('stage_id', TType.I16, 3)
            oprot.writeI16(self.stage_id)
            oprot.writeFieldEnd()
        if self.field_name is not None:
            oprot.writeFieldBegin('field_name', TType.STRING, 4)
            oprot.writeString(self.field_name.encode('utf-8') if sys.version_info[0] == 2 else self.field_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_data_get_args)
snapshot_capture_data_get_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
    (2, TType.I16, 'pipe', None, None, ),  # 2
    (3, TType.I16, 'stage_id', None, None, ),  # 3
    (4, TType.STRING, 'field_name', 'UTF8', None, ),  # 4
)


class snapshot_capture_data_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_data_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_data_get_result)
snapshot_capture_data_get_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_capture_tbl_data_get_args(object):
    """
    Attributes:
     - handle
     - pipe
     - table_name

    """


    def __init__(self, handle=None, pipe=None, table_name=None,):
        self.handle = handle
        self.pipe = pipe
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pipe = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_tbl_data_get_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        if self.pipe is not None:
            oprot.writeFieldBegin('pipe', TType.I16, 2)
            oprot.writeI16(self.pipe)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 3)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_tbl_data_get_args)
snapshot_capture_tbl_data_get_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
    (2, TType.I16, 'pipe', None, None, ),  # 2
    (3, TType.STRING, 'table_name', 'UTF8', None, ),  # 3
)


class snapshot_capture_tbl_data_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = main_snapshot_tbl_data_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_tbl_data_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_tbl_data_get_result)
snapshot_capture_tbl_data_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [main_snapshot_tbl_data_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_capture_trigger_fields_clr_args(object):
    """
    Attributes:
     - handle

    """


    def __init__(self, handle=None,):
        self.handle = handle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.handle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_trigger_fields_clr_args')
        if self.handle is not None:
            oprot.writeFieldBegin('handle', TType.I32, 1)
            oprot.writeI32(self.handle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_trigger_fields_clr_args)
snapshot_capture_trigger_fields_clr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'handle', None, None, ),  # 1
)


class snapshot_capture_trigger_fields_clr_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_capture_trigger_fields_clr_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_capture_trigger_fields_clr_result)
snapshot_capture_trigger_fields_clr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)


class snapshot_field_in_scope_args(object):
    """
    Attributes:
     - dev_tgt
     - stage
     - direction
     - field_name

    """


    def __init__(self, dev_tgt=None, stage=None, direction=None, field_name=None,):
        self.dev_tgt = dev_tgt
        self.stage = stage
        self.direction = direction
        self.field_name = field_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.stage = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.direction = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.field_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_field_in_scope_args')
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 1)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.stage is not None:
            oprot.writeFieldBegin('stage', TType.BYTE, 2)
            oprot.writeByte(self.stage)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.BYTE, 3)
            oprot.writeByte(self.direction)
            oprot.writeFieldEnd()
        if self.field_name is not None:
            oprot.writeFieldBegin('field_name', TType.STRING, 4)
            oprot.writeString(self.field_name.encode('utf-8') if sys.version_info[0] == 2 else self.field_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_field_in_scope_args)
snapshot_field_in_scope_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 1
    (2, TType.BYTE, 'stage', None, None, ),  # 2
    (3, TType.BYTE, 'direction', None, None, ),  # 3
    (4, TType.STRING, 'field_name', 'UTF8', None, ),  # 4
)


class snapshot_field_in_scope_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidSnapshotOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('snapshot_field_in_scope_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(snapshot_field_in_scope_result)
snapshot_field_in_scope_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidSnapshotOperation, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
