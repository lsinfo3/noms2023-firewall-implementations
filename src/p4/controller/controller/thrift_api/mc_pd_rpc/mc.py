#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def mc_init(self):
        pass

    def mc_create_session(self):
        pass

    def mc_destroy_session(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def mc_complete_operations(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def mc_begin_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def mc_flush_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def mc_end_batch(self, sess_hdl, hwSynchronous):
        """
        Parameters:
         - sess_hdl
         - hwSynchronous

        """
        pass

    def mc_mgrp_create(self, sess_hdl, dev_id, mgid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgid

        """
        pass

    def mc_mgrp_get_attr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        pass

    def mc_mgrp_destroy(self, sess_hdl, dev_id, grp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl

        """
        pass

    def mc_mgrp_get_first(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_mgrp_get_count(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_mgrp_get_next_i(self, sess_hdl, dev_id, mgrp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - n

        """
        pass

    def mc_mgrp_get_first_node_mbr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        pass

    def mc_mgrp_get_node_mbr_count(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        pass

    def mc_mgrp_get_next_i_node_mbr(self, sess_hdl, dev_id, mgrp_hdl, node_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - node_hdl
         - n

        """
        pass

    def mc_mgrp_get_first_ecmp_mbr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        pass

    def mc_mgrp_get_ecmp_mbr_count(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        pass

    def mc_mgrp_get_next_i_ecmp_mbr(self, sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - ecmp_hdl
         - n

        """
        pass

    def mc_node_create(self, sess_hdl, dev_id, rid, port_map, lag_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - rid
         - port_map
         - lag_map

        """
        pass

    def mc_node_get_attr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        pass

    def mc_node_update(self, sess_hdl, dev_id, l1_hdl, port_map, lag_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - l1_hdl
         - port_map
         - lag_map

        """
        pass

    def mc_node_destroy(self, sess_hdl, dev_id, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - l1_hdl

        """
        pass

    def mc_node_get_first(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_node_get_count(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_node_get_next_i(self, sess_hdl, dev_id, node_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_hdl
         - n

        """
        pass

    def mc_ecmp_get_mbr_from_hash(self, sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, level1_mcast_hash, pkt_xid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - ecmp_hdl
         - level1_mcast_hash
         - pkt_xid

        """
        pass

    def mc_node_get_association(self, sess_hdl, dev_id, node_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_hdl

        """
        pass

    def mc_node_is_mbr(self, sess_hdl, dev_id, node_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_hdl

        """
        pass

    def mc_associate_node(self, sess_hdl, dev_id, grp_hdl, l1_hdl, xid, xid_valid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - l1_hdl
         - xid
         - xid_valid

        """
        pass

    def mc_dissociate_node(self, sess_hdl, dev_id, grp_hdl, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - l1_hdl

        """
        pass

    def mc_ecmp_create(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_ecmp_destroy(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        pass

    def mc_ecmp_get_first(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_ecmp_get_count(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_ecmp_get_next_i(self, sess_hdl, dev_id, ecmp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - n

        """
        pass

    def mc_ecmp_mbr_add(self, sess_hdl, dev_id, ecmp_hdl, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - l1_hdl

        """
        pass

    def mc_ecmp_mbr_rem(self, sess_hdl, dev_id, ecmp_hdl, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - l1_hdl

        """
        pass

    def mc_ecmp_get_first_mbr(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        pass

    def mc_ecmp_get_mbr_count(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        pass

    def mc_ecmp_get_next_i_mbr(self, sess_hdl, dev_id, ecmp_hdl, node_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - node_hdl
         - n

        """
        pass

    def mc_associate_ecmp(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl, xid, xid_valid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - ecmp_hdl
         - xid
         - xid_valid

        """
        pass

    def mc_ecmp_get_assoc_attr(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - ecmp_hdl

        """
        pass

    def mc_dissociate_ecmp(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - ecmp_hdl

        """
        pass

    def mc_ecmp_get_first_assoc(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        pass

    def mc_ecmp_get_assoc_count(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        pass

    def mc_ecmp_get_next_i_assoc(self, sess_hdl, dev_id, ecmp_hdl, mgrp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - mgrp_hdl
         - n

        """
        pass

    def mc_set_lag_membership(self, sess_hdl, dev_id, lag_index, port_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - lag_index
         - port_map

        """
        pass

    def mc_get_lag_membership(self, sess_hdl, dev_id, lag_index):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - lag_index

        """
        pass

    def mc_get_lag_member_from_hash(self, sess_hdl, dev_id, l1_hdl, lag_index, level2_mcast_hash, pkt_xid, pkt_yid, pkt_rid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - l1_hdl
         - lag_index
         - level2_mcast_hash
         - pkt_xid
         - pkt_yid
         - pkt_rid

        """
        pass

    def mc_set_remote_lag_member_count(self, sess_hdl, dev_id, lag_index, left, right):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - lag_index
         - left
         - right

        """
        pass

    def mc_update_port_prune_table(self, sess_hdl, dev_id, yid, port_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - yid
         - port_map

        """
        pass

    def mc_get_port_prune_table(self, sess_hdl, dev_id, yid, from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - yid
         - from_hw

        """
        pass

    def mc_set_global_rid(self, sess_hdl, dev_id, rid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - rid

        """
        pass

    def mc_set_port_mc_fwd_state(self, sess_hdl, dev_id, port, is_active):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - port
         - is_active

        """
        pass

    def mc_enable_port_ff(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_disable_port_ff(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_clr_port_ff_state(self, sess_hdl, dev_id, port):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - port

        """
        pass

    def mc_enable_port_protection(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_disable_port_protection(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        pass

    def mc_set_port_protection(self, sess_hdl, dev_id, pport, bport):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - pport
         - bport

        """
        pass

    def mc_clear_port_protection(self, sess_hdl, dev_id, pport):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - pport

        """
        pass

    def mc_set_max_nodes_before_yield(self, sess_hdl, dev_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - count

        """
        pass

    def mc_set_max_node_threshold(self, sess_hdl, dev_id, node_count, lag_count):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_count
         - lag_count

        """
        pass

    def mc_get_pipe_vec(self, sess_hdl, dev_id, mgid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgid

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def mc_init(self):
        self.send_mc_init()
        self.recv_mc_init()

    def send_mc_init(self):
        self._oprot.writeMessageBegin('mc_init', TMessageType.CALL, self._seqid)
        args = mc_init_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_init(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_init_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_create_session(self):
        self.send_mc_create_session()
        return self.recv_mc_create_session()

    def send_mc_create_session(self):
        self._oprot.writeMessageBegin('mc_create_session', TMessageType.CALL, self._seqid)
        args = mc_create_session_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_create_session(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_create_session_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_create_session failed: unknown result")

    def mc_destroy_session(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_mc_destroy_session(sess_hdl)
        self.recv_mc_destroy_session()

    def send_mc_destroy_session(self, sess_hdl):
        self._oprot.writeMessageBegin('mc_destroy_session', TMessageType.CALL, self._seqid)
        args = mc_destroy_session_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_destroy_session(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_destroy_session_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_complete_operations(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_mc_complete_operations(sess_hdl)
        self.recv_mc_complete_operations()

    def send_mc_complete_operations(self, sess_hdl):
        self._oprot.writeMessageBegin('mc_complete_operations', TMessageType.CALL, self._seqid)
        args = mc_complete_operations_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_complete_operations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_complete_operations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_begin_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_mc_begin_batch(sess_hdl)
        self.recv_mc_begin_batch()

    def send_mc_begin_batch(self, sess_hdl):
        self._oprot.writeMessageBegin('mc_begin_batch', TMessageType.CALL, self._seqid)
        args = mc_begin_batch_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_begin_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_begin_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_flush_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_mc_flush_batch(sess_hdl)
        self.recv_mc_flush_batch()

    def send_mc_flush_batch(self, sess_hdl):
        self._oprot.writeMessageBegin('mc_flush_batch', TMessageType.CALL, self._seqid)
        args = mc_flush_batch_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_flush_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_flush_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_end_batch(self, sess_hdl, hwSynchronous):
        """
        Parameters:
         - sess_hdl
         - hwSynchronous

        """
        self.send_mc_end_batch(sess_hdl, hwSynchronous)
        self.recv_mc_end_batch()

    def send_mc_end_batch(self, sess_hdl, hwSynchronous):
        self._oprot.writeMessageBegin('mc_end_batch', TMessageType.CALL, self._seqid)
        args = mc_end_batch_args()
        args.sess_hdl = sess_hdl
        args.hwSynchronous = hwSynchronous
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_end_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_end_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_mgrp_create(self, sess_hdl, dev_id, mgid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgid

        """
        self.send_mc_mgrp_create(sess_hdl, dev_id, mgid)
        return self.recv_mc_mgrp_create()

    def send_mc_mgrp_create(self, sess_hdl, dev_id, mgid):
        self._oprot.writeMessageBegin('mc_mgrp_create', TMessageType.CALL, self._seqid)
        args = mc_mgrp_create_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgid = mgid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_create(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_create_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_create failed: unknown result")

    def mc_mgrp_get_attr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        self.send_mc_mgrp_get_attr(sess_hdl, dev_id, mgrp_hdl)
        return self.recv_mc_mgrp_get_attr()

    def send_mc_mgrp_get_attr(self, sess_hdl, dev_id, mgrp_hdl):
        self._oprot.writeMessageBegin('mc_mgrp_get_attr', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_attr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_attr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_attr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_attr failed: unknown result")

    def mc_mgrp_destroy(self, sess_hdl, dev_id, grp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl

        """
        self.send_mc_mgrp_destroy(sess_hdl, dev_id, grp_hdl)
        self.recv_mc_mgrp_destroy()

    def send_mc_mgrp_destroy(self, sess_hdl, dev_id, grp_hdl):
        self._oprot.writeMessageBegin('mc_mgrp_destroy', TMessageType.CALL, self._seqid)
        args = mc_mgrp_destroy_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.grp_hdl = grp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_destroy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_destroy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_mgrp_get_first(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_mgrp_get_first(sess_hdl, dev_id)
        return self.recv_mc_mgrp_get_first()

    def send_mc_mgrp_get_first(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_mgrp_get_first', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_first_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_first(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_first_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_first failed: unknown result")

    def mc_mgrp_get_count(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_mgrp_get_count(sess_hdl, dev_id)
        return self.recv_mc_mgrp_get_count()

    def send_mc_mgrp_get_count(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_mgrp_get_count', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_count failed: unknown result")

    def mc_mgrp_get_next_i(self, sess_hdl, dev_id, mgrp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - n

        """
        self.send_mc_mgrp_get_next_i(sess_hdl, dev_id, mgrp_hdl, n)
        return self.recv_mc_mgrp_get_next_i()

    def send_mc_mgrp_get_next_i(self, sess_hdl, dev_id, mgrp_hdl, n):
        self._oprot.writeMessageBegin('mc_mgrp_get_next_i', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_next_i_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_next_i(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_next_i_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_next_i failed: unknown result")

    def mc_mgrp_get_first_node_mbr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        self.send_mc_mgrp_get_first_node_mbr(sess_hdl, dev_id, mgrp_hdl)
        return self.recv_mc_mgrp_get_first_node_mbr()

    def send_mc_mgrp_get_first_node_mbr(self, sess_hdl, dev_id, mgrp_hdl):
        self._oprot.writeMessageBegin('mc_mgrp_get_first_node_mbr', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_first_node_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_first_node_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_first_node_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_first_node_mbr failed: unknown result")

    def mc_mgrp_get_node_mbr_count(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        self.send_mc_mgrp_get_node_mbr_count(sess_hdl, dev_id, mgrp_hdl)
        return self.recv_mc_mgrp_get_node_mbr_count()

    def send_mc_mgrp_get_node_mbr_count(self, sess_hdl, dev_id, mgrp_hdl):
        self._oprot.writeMessageBegin('mc_mgrp_get_node_mbr_count', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_node_mbr_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_node_mbr_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_node_mbr_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_node_mbr_count failed: unknown result")

    def mc_mgrp_get_next_i_node_mbr(self, sess_hdl, dev_id, mgrp_hdl, node_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - node_hdl
         - n

        """
        self.send_mc_mgrp_get_next_i_node_mbr(sess_hdl, dev_id, mgrp_hdl, node_hdl, n)
        return self.recv_mc_mgrp_get_next_i_node_mbr()

    def send_mc_mgrp_get_next_i_node_mbr(self, sess_hdl, dev_id, mgrp_hdl, node_hdl, n):
        self._oprot.writeMessageBegin('mc_mgrp_get_next_i_node_mbr', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_next_i_node_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.node_hdl = node_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_next_i_node_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_next_i_node_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_next_i_node_mbr failed: unknown result")

    def mc_mgrp_get_first_ecmp_mbr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        self.send_mc_mgrp_get_first_ecmp_mbr(sess_hdl, dev_id, mgrp_hdl)
        return self.recv_mc_mgrp_get_first_ecmp_mbr()

    def send_mc_mgrp_get_first_ecmp_mbr(self, sess_hdl, dev_id, mgrp_hdl):
        self._oprot.writeMessageBegin('mc_mgrp_get_first_ecmp_mbr', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_first_ecmp_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_first_ecmp_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_first_ecmp_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_first_ecmp_mbr failed: unknown result")

    def mc_mgrp_get_ecmp_mbr_count(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        self.send_mc_mgrp_get_ecmp_mbr_count(sess_hdl, dev_id, mgrp_hdl)
        return self.recv_mc_mgrp_get_ecmp_mbr_count()

    def send_mc_mgrp_get_ecmp_mbr_count(self, sess_hdl, dev_id, mgrp_hdl):
        self._oprot.writeMessageBegin('mc_mgrp_get_ecmp_mbr_count', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_ecmp_mbr_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_ecmp_mbr_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_ecmp_mbr_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_ecmp_mbr_count failed: unknown result")

    def mc_mgrp_get_next_i_ecmp_mbr(self, sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - ecmp_hdl
         - n

        """
        self.send_mc_mgrp_get_next_i_ecmp_mbr(sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, n)
        return self.recv_mc_mgrp_get_next_i_ecmp_mbr()

    def send_mc_mgrp_get_next_i_ecmp_mbr(self, sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, n):
        self._oprot.writeMessageBegin('mc_mgrp_get_next_i_ecmp_mbr', TMessageType.CALL, self._seqid)
        args = mc_mgrp_get_next_i_ecmp_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.ecmp_hdl = ecmp_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_mgrp_get_next_i_ecmp_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_mgrp_get_next_i_ecmp_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_mgrp_get_next_i_ecmp_mbr failed: unknown result")

    def mc_node_create(self, sess_hdl, dev_id, rid, port_map, lag_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - rid
         - port_map
         - lag_map

        """
        self.send_mc_node_create(sess_hdl, dev_id, rid, port_map, lag_map)
        return self.recv_mc_node_create()

    def send_mc_node_create(self, sess_hdl, dev_id, rid, port_map, lag_map):
        self._oprot.writeMessageBegin('mc_node_create', TMessageType.CALL, self._seqid)
        args = mc_node_create_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.rid = rid
        args.port_map = port_map
        args.lag_map = lag_map
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_create(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_create_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_create failed: unknown result")

    def mc_node_get_attr(self, sess_hdl, dev_id, mgrp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl

        """
        self.send_mc_node_get_attr(sess_hdl, dev_id, mgrp_hdl)
        return self.recv_mc_node_get_attr()

    def send_mc_node_get_attr(self, sess_hdl, dev_id, mgrp_hdl):
        self._oprot.writeMessageBegin('mc_node_get_attr', TMessageType.CALL, self._seqid)
        args = mc_node_get_attr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_get_attr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_get_attr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_get_attr failed: unknown result")

    def mc_node_update(self, sess_hdl, dev_id, l1_hdl, port_map, lag_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - l1_hdl
         - port_map
         - lag_map

        """
        self.send_mc_node_update(sess_hdl, dev_id, l1_hdl, port_map, lag_map)
        self.recv_mc_node_update()

    def send_mc_node_update(self, sess_hdl, dev_id, l1_hdl, port_map, lag_map):
        self._oprot.writeMessageBegin('mc_node_update', TMessageType.CALL, self._seqid)
        args = mc_node_update_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.l1_hdl = l1_hdl
        args.port_map = port_map
        args.lag_map = lag_map
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_node_destroy(self, sess_hdl, dev_id, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - l1_hdl

        """
        self.send_mc_node_destroy(sess_hdl, dev_id, l1_hdl)
        self.recv_mc_node_destroy()

    def send_mc_node_destroy(self, sess_hdl, dev_id, l1_hdl):
        self._oprot.writeMessageBegin('mc_node_destroy', TMessageType.CALL, self._seqid)
        args = mc_node_destroy_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.l1_hdl = l1_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_destroy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_destroy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_node_get_first(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_node_get_first(sess_hdl, dev_id)
        return self.recv_mc_node_get_first()

    def send_mc_node_get_first(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_node_get_first', TMessageType.CALL, self._seqid)
        args = mc_node_get_first_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_get_first(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_get_first_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_get_first failed: unknown result")

    def mc_node_get_count(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_node_get_count(sess_hdl, dev_id)
        return self.recv_mc_node_get_count()

    def send_mc_node_get_count(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_node_get_count', TMessageType.CALL, self._seqid)
        args = mc_node_get_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_get_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_get_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_get_count failed: unknown result")

    def mc_node_get_next_i(self, sess_hdl, dev_id, node_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_hdl
         - n

        """
        self.send_mc_node_get_next_i(sess_hdl, dev_id, node_hdl, n)
        return self.recv_mc_node_get_next_i()

    def send_mc_node_get_next_i(self, sess_hdl, dev_id, node_hdl, n):
        self._oprot.writeMessageBegin('mc_node_get_next_i', TMessageType.CALL, self._seqid)
        args = mc_node_get_next_i_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.node_hdl = node_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_get_next_i(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_get_next_i_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_get_next_i failed: unknown result")

    def mc_ecmp_get_mbr_from_hash(self, sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, level1_mcast_hash, pkt_xid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgrp_hdl
         - ecmp_hdl
         - level1_mcast_hash
         - pkt_xid

        """
        self.send_mc_ecmp_get_mbr_from_hash(sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, level1_mcast_hash, pkt_xid)
        return self.recv_mc_ecmp_get_mbr_from_hash()

    def send_mc_ecmp_get_mbr_from_hash(self, sess_hdl, dev_id, mgrp_hdl, ecmp_hdl, level1_mcast_hash, pkt_xid):
        self._oprot.writeMessageBegin('mc_ecmp_get_mbr_from_hash', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_mbr_from_hash_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgrp_hdl = mgrp_hdl
        args.ecmp_hdl = ecmp_hdl
        args.level1_mcast_hash = level1_mcast_hash
        args.pkt_xid = pkt_xid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_mbr_from_hash(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_mbr_from_hash_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_mbr_from_hash failed: unknown result")

    def mc_node_get_association(self, sess_hdl, dev_id, node_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_hdl

        """
        self.send_mc_node_get_association(sess_hdl, dev_id, node_hdl)
        return self.recv_mc_node_get_association()

    def send_mc_node_get_association(self, sess_hdl, dev_id, node_hdl):
        self._oprot.writeMessageBegin('mc_node_get_association', TMessageType.CALL, self._seqid)
        args = mc_node_get_association_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.node_hdl = node_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_get_association(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_get_association_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_get_association failed: unknown result")

    def mc_node_is_mbr(self, sess_hdl, dev_id, node_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_hdl

        """
        self.send_mc_node_is_mbr(sess_hdl, dev_id, node_hdl)
        return self.recv_mc_node_is_mbr()

    def send_mc_node_is_mbr(self, sess_hdl, dev_id, node_hdl):
        self._oprot.writeMessageBegin('mc_node_is_mbr', TMessageType.CALL, self._seqid)
        args = mc_node_is_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.node_hdl = node_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_node_is_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_node_is_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_node_is_mbr failed: unknown result")

    def mc_associate_node(self, sess_hdl, dev_id, grp_hdl, l1_hdl, xid, xid_valid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - l1_hdl
         - xid
         - xid_valid

        """
        self.send_mc_associate_node(sess_hdl, dev_id, grp_hdl, l1_hdl, xid, xid_valid)
        self.recv_mc_associate_node()

    def send_mc_associate_node(self, sess_hdl, dev_id, grp_hdl, l1_hdl, xid, xid_valid):
        self._oprot.writeMessageBegin('mc_associate_node', TMessageType.CALL, self._seqid)
        args = mc_associate_node_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.grp_hdl = grp_hdl
        args.l1_hdl = l1_hdl
        args.xid = xid
        args.xid_valid = xid_valid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_associate_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_associate_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_dissociate_node(self, sess_hdl, dev_id, grp_hdl, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - l1_hdl

        """
        self.send_mc_dissociate_node(sess_hdl, dev_id, grp_hdl, l1_hdl)
        self.recv_mc_dissociate_node()

    def send_mc_dissociate_node(self, sess_hdl, dev_id, grp_hdl, l1_hdl):
        self._oprot.writeMessageBegin('mc_dissociate_node', TMessageType.CALL, self._seqid)
        args = mc_dissociate_node_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.grp_hdl = grp_hdl
        args.l1_hdl = l1_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_dissociate_node(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_dissociate_node_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_ecmp_create(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_ecmp_create(sess_hdl, dev_id)
        return self.recv_mc_ecmp_create()

    def send_mc_ecmp_create(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_ecmp_create', TMessageType.CALL, self._seqid)
        args = mc_ecmp_create_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_create(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_create_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_create failed: unknown result")

    def mc_ecmp_destroy(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        self.send_mc_ecmp_destroy(sess_hdl, dev_id, ecmp_hdl)
        self.recv_mc_ecmp_destroy()

    def send_mc_ecmp_destroy(self, sess_hdl, dev_id, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_destroy', TMessageType.CALL, self._seqid)
        args = mc_ecmp_destroy_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_destroy(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_destroy_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_ecmp_get_first(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_ecmp_get_first(sess_hdl, dev_id)
        return self.recv_mc_ecmp_get_first()

    def send_mc_ecmp_get_first(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_ecmp_get_first', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_first_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_first(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_first_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_first failed: unknown result")

    def mc_ecmp_get_count(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_ecmp_get_count(sess_hdl, dev_id)
        return self.recv_mc_ecmp_get_count()

    def send_mc_ecmp_get_count(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_ecmp_get_count', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_count failed: unknown result")

    def mc_ecmp_get_next_i(self, sess_hdl, dev_id, ecmp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - n

        """
        self.send_mc_ecmp_get_next_i(sess_hdl, dev_id, ecmp_hdl, n)
        return self.recv_mc_ecmp_get_next_i()

    def send_mc_ecmp_get_next_i(self, sess_hdl, dev_id, ecmp_hdl, n):
        self._oprot.writeMessageBegin('mc_ecmp_get_next_i', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_next_i_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_next_i(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_next_i_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_next_i failed: unknown result")

    def mc_ecmp_mbr_add(self, sess_hdl, dev_id, ecmp_hdl, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - l1_hdl

        """
        self.send_mc_ecmp_mbr_add(sess_hdl, dev_id, ecmp_hdl, l1_hdl)
        self.recv_mc_ecmp_mbr_add()

    def send_mc_ecmp_mbr_add(self, sess_hdl, dev_id, ecmp_hdl, l1_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_mbr_add', TMessageType.CALL, self._seqid)
        args = mc_ecmp_mbr_add_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.l1_hdl = l1_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_mbr_add(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_mbr_add_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_ecmp_mbr_rem(self, sess_hdl, dev_id, ecmp_hdl, l1_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - l1_hdl

        """
        self.send_mc_ecmp_mbr_rem(sess_hdl, dev_id, ecmp_hdl, l1_hdl)
        self.recv_mc_ecmp_mbr_rem()

    def send_mc_ecmp_mbr_rem(self, sess_hdl, dev_id, ecmp_hdl, l1_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_mbr_rem', TMessageType.CALL, self._seqid)
        args = mc_ecmp_mbr_rem_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.l1_hdl = l1_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_mbr_rem(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_mbr_rem_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_ecmp_get_first_mbr(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        self.send_mc_ecmp_get_first_mbr(sess_hdl, dev_id, ecmp_hdl)
        return self.recv_mc_ecmp_get_first_mbr()

    def send_mc_ecmp_get_first_mbr(self, sess_hdl, dev_id, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_get_first_mbr', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_first_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_first_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_first_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_first_mbr failed: unknown result")

    def mc_ecmp_get_mbr_count(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        self.send_mc_ecmp_get_mbr_count(sess_hdl, dev_id, ecmp_hdl)
        return self.recv_mc_ecmp_get_mbr_count()

    def send_mc_ecmp_get_mbr_count(self, sess_hdl, dev_id, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_get_mbr_count', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_mbr_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_mbr_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_mbr_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_mbr_count failed: unknown result")

    def mc_ecmp_get_next_i_mbr(self, sess_hdl, dev_id, ecmp_hdl, node_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - node_hdl
         - n

        """
        self.send_mc_ecmp_get_next_i_mbr(sess_hdl, dev_id, ecmp_hdl, node_hdl, n)
        return self.recv_mc_ecmp_get_next_i_mbr()

    def send_mc_ecmp_get_next_i_mbr(self, sess_hdl, dev_id, ecmp_hdl, node_hdl, n):
        self._oprot.writeMessageBegin('mc_ecmp_get_next_i_mbr', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_next_i_mbr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.node_hdl = node_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_next_i_mbr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_next_i_mbr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_next_i_mbr failed: unknown result")

    def mc_associate_ecmp(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl, xid, xid_valid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - ecmp_hdl
         - xid
         - xid_valid

        """
        self.send_mc_associate_ecmp(sess_hdl, dev_id, grp_hdl, ecmp_hdl, xid, xid_valid)
        self.recv_mc_associate_ecmp()

    def send_mc_associate_ecmp(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl, xid, xid_valid):
        self._oprot.writeMessageBegin('mc_associate_ecmp', TMessageType.CALL, self._seqid)
        args = mc_associate_ecmp_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.grp_hdl = grp_hdl
        args.ecmp_hdl = ecmp_hdl
        args.xid = xid
        args.xid_valid = xid_valid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_associate_ecmp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_associate_ecmp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_ecmp_get_assoc_attr(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - ecmp_hdl

        """
        self.send_mc_ecmp_get_assoc_attr(sess_hdl, dev_id, grp_hdl, ecmp_hdl)
        return self.recv_mc_ecmp_get_assoc_attr()

    def send_mc_ecmp_get_assoc_attr(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_get_assoc_attr', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_assoc_attr_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.grp_hdl = grp_hdl
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_assoc_attr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_assoc_attr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_assoc_attr failed: unknown result")

    def mc_dissociate_ecmp(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - grp_hdl
         - ecmp_hdl

        """
        self.send_mc_dissociate_ecmp(sess_hdl, dev_id, grp_hdl, ecmp_hdl)
        self.recv_mc_dissociate_ecmp()

    def send_mc_dissociate_ecmp(self, sess_hdl, dev_id, grp_hdl, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_dissociate_ecmp', TMessageType.CALL, self._seqid)
        args = mc_dissociate_ecmp_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.grp_hdl = grp_hdl
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_dissociate_ecmp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_dissociate_ecmp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_ecmp_get_first_assoc(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        self.send_mc_ecmp_get_first_assoc(sess_hdl, dev_id, ecmp_hdl)
        return self.recv_mc_ecmp_get_first_assoc()

    def send_mc_ecmp_get_first_assoc(self, sess_hdl, dev_id, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_get_first_assoc', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_first_assoc_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_first_assoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_first_assoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_first_assoc failed: unknown result")

    def mc_ecmp_get_assoc_count(self, sess_hdl, dev_id, ecmp_hdl):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl

        """
        self.send_mc_ecmp_get_assoc_count(sess_hdl, dev_id, ecmp_hdl)
        return self.recv_mc_ecmp_get_assoc_count()

    def send_mc_ecmp_get_assoc_count(self, sess_hdl, dev_id, ecmp_hdl):
        self._oprot.writeMessageBegin('mc_ecmp_get_assoc_count', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_assoc_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_assoc_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_assoc_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_assoc_count failed: unknown result")

    def mc_ecmp_get_next_i_assoc(self, sess_hdl, dev_id, ecmp_hdl, mgrp_hdl, n):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - ecmp_hdl
         - mgrp_hdl
         - n

        """
        self.send_mc_ecmp_get_next_i_assoc(sess_hdl, dev_id, ecmp_hdl, mgrp_hdl, n)
        return self.recv_mc_ecmp_get_next_i_assoc()

    def send_mc_ecmp_get_next_i_assoc(self, sess_hdl, dev_id, ecmp_hdl, mgrp_hdl, n):
        self._oprot.writeMessageBegin('mc_ecmp_get_next_i_assoc', TMessageType.CALL, self._seqid)
        args = mc_ecmp_get_next_i_assoc_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.ecmp_hdl = ecmp_hdl
        args.mgrp_hdl = mgrp_hdl
        args.n = n
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_ecmp_get_next_i_assoc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_ecmp_get_next_i_assoc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_ecmp_get_next_i_assoc failed: unknown result")

    def mc_set_lag_membership(self, sess_hdl, dev_id, lag_index, port_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - lag_index
         - port_map

        """
        self.send_mc_set_lag_membership(sess_hdl, dev_id, lag_index, port_map)
        self.recv_mc_set_lag_membership()

    def send_mc_set_lag_membership(self, sess_hdl, dev_id, lag_index, port_map):
        self._oprot.writeMessageBegin('mc_set_lag_membership', TMessageType.CALL, self._seqid)
        args = mc_set_lag_membership_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.lag_index = lag_index
        args.port_map = port_map
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_lag_membership(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_lag_membership_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_get_lag_membership(self, sess_hdl, dev_id, lag_index):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - lag_index

        """
        self.send_mc_get_lag_membership(sess_hdl, dev_id, lag_index)
        return self.recv_mc_get_lag_membership()

    def send_mc_get_lag_membership(self, sess_hdl, dev_id, lag_index):
        self._oprot.writeMessageBegin('mc_get_lag_membership', TMessageType.CALL, self._seqid)
        args = mc_get_lag_membership_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.lag_index = lag_index
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_get_lag_membership(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_get_lag_membership_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_get_lag_membership failed: unknown result")

    def mc_get_lag_member_from_hash(self, sess_hdl, dev_id, l1_hdl, lag_index, level2_mcast_hash, pkt_xid, pkt_yid, pkt_rid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - l1_hdl
         - lag_index
         - level2_mcast_hash
         - pkt_xid
         - pkt_yid
         - pkt_rid

        """
        self.send_mc_get_lag_member_from_hash(sess_hdl, dev_id, l1_hdl, lag_index, level2_mcast_hash, pkt_xid, pkt_yid, pkt_rid)
        return self.recv_mc_get_lag_member_from_hash()

    def send_mc_get_lag_member_from_hash(self, sess_hdl, dev_id, l1_hdl, lag_index, level2_mcast_hash, pkt_xid, pkt_yid, pkt_rid):
        self._oprot.writeMessageBegin('mc_get_lag_member_from_hash', TMessageType.CALL, self._seqid)
        args = mc_get_lag_member_from_hash_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.l1_hdl = l1_hdl
        args.lag_index = lag_index
        args.level2_mcast_hash = level2_mcast_hash
        args.pkt_xid = pkt_xid
        args.pkt_yid = pkt_yid
        args.pkt_rid = pkt_rid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_get_lag_member_from_hash(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_get_lag_member_from_hash_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_get_lag_member_from_hash failed: unknown result")

    def mc_set_remote_lag_member_count(self, sess_hdl, dev_id, lag_index, left, right):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - lag_index
         - left
         - right

        """
        self.send_mc_set_remote_lag_member_count(sess_hdl, dev_id, lag_index, left, right)
        self.recv_mc_set_remote_lag_member_count()

    def send_mc_set_remote_lag_member_count(self, sess_hdl, dev_id, lag_index, left, right):
        self._oprot.writeMessageBegin('mc_set_remote_lag_member_count', TMessageType.CALL, self._seqid)
        args = mc_set_remote_lag_member_count_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.lag_index = lag_index
        args.left = left
        args.right = right
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_remote_lag_member_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_remote_lag_member_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_update_port_prune_table(self, sess_hdl, dev_id, yid, port_map):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - yid
         - port_map

        """
        self.send_mc_update_port_prune_table(sess_hdl, dev_id, yid, port_map)
        self.recv_mc_update_port_prune_table()

    def send_mc_update_port_prune_table(self, sess_hdl, dev_id, yid, port_map):
        self._oprot.writeMessageBegin('mc_update_port_prune_table', TMessageType.CALL, self._seqid)
        args = mc_update_port_prune_table_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.yid = yid
        args.port_map = port_map
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_update_port_prune_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_update_port_prune_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_get_port_prune_table(self, sess_hdl, dev_id, yid, from_hw):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - yid
         - from_hw

        """
        self.send_mc_get_port_prune_table(sess_hdl, dev_id, yid, from_hw)
        return self.recv_mc_get_port_prune_table()

    def send_mc_get_port_prune_table(self, sess_hdl, dev_id, yid, from_hw):
        self._oprot.writeMessageBegin('mc_get_port_prune_table', TMessageType.CALL, self._seqid)
        args = mc_get_port_prune_table_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.yid = yid
        args.from_hw = from_hw
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_get_port_prune_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_get_port_prune_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_get_port_prune_table failed: unknown result")

    def mc_set_global_rid(self, sess_hdl, dev_id, rid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - rid

        """
        self.send_mc_set_global_rid(sess_hdl, dev_id, rid)
        self.recv_mc_set_global_rid()

    def send_mc_set_global_rid(self, sess_hdl, dev_id, rid):
        self._oprot.writeMessageBegin('mc_set_global_rid', TMessageType.CALL, self._seqid)
        args = mc_set_global_rid_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.rid = rid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_global_rid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_global_rid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_set_port_mc_fwd_state(self, sess_hdl, dev_id, port, is_active):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - port
         - is_active

        """
        self.send_mc_set_port_mc_fwd_state(sess_hdl, dev_id, port, is_active)
        self.recv_mc_set_port_mc_fwd_state()

    def send_mc_set_port_mc_fwd_state(self, sess_hdl, dev_id, port, is_active):
        self._oprot.writeMessageBegin('mc_set_port_mc_fwd_state', TMessageType.CALL, self._seqid)
        args = mc_set_port_mc_fwd_state_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.port = port
        args.is_active = is_active
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_port_mc_fwd_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_port_mc_fwd_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_enable_port_ff(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_enable_port_ff(sess_hdl, dev_id)
        self.recv_mc_enable_port_ff()

    def send_mc_enable_port_ff(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_enable_port_ff', TMessageType.CALL, self._seqid)
        args = mc_enable_port_ff_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_enable_port_ff(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_enable_port_ff_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_disable_port_ff(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_disable_port_ff(sess_hdl, dev_id)
        self.recv_mc_disable_port_ff()

    def send_mc_disable_port_ff(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_disable_port_ff', TMessageType.CALL, self._seqid)
        args = mc_disable_port_ff_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_disable_port_ff(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_disable_port_ff_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_clr_port_ff_state(self, sess_hdl, dev_id, port):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - port

        """
        self.send_mc_clr_port_ff_state(sess_hdl, dev_id, port)
        self.recv_mc_clr_port_ff_state()

    def send_mc_clr_port_ff_state(self, sess_hdl, dev_id, port):
        self._oprot.writeMessageBegin('mc_clr_port_ff_state', TMessageType.CALL, self._seqid)
        args = mc_clr_port_ff_state_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_clr_port_ff_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_clr_port_ff_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_enable_port_protection(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_enable_port_protection(sess_hdl, dev_id)
        self.recv_mc_enable_port_protection()

    def send_mc_enable_port_protection(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_enable_port_protection', TMessageType.CALL, self._seqid)
        args = mc_enable_port_protection_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_enable_port_protection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_enable_port_protection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_disable_port_protection(self, sess_hdl, dev_id):
        """
        Parameters:
         - sess_hdl
         - dev_id

        """
        self.send_mc_disable_port_protection(sess_hdl, dev_id)
        self.recv_mc_disable_port_protection()

    def send_mc_disable_port_protection(self, sess_hdl, dev_id):
        self._oprot.writeMessageBegin('mc_disable_port_protection', TMessageType.CALL, self._seqid)
        args = mc_disable_port_protection_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_disable_port_protection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_disable_port_protection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_set_port_protection(self, sess_hdl, dev_id, pport, bport):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - pport
         - bport

        """
        self.send_mc_set_port_protection(sess_hdl, dev_id, pport, bport)
        self.recv_mc_set_port_protection()

    def send_mc_set_port_protection(self, sess_hdl, dev_id, pport, bport):
        self._oprot.writeMessageBegin('mc_set_port_protection', TMessageType.CALL, self._seqid)
        args = mc_set_port_protection_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.pport = pport
        args.bport = bport
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_port_protection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_port_protection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_clear_port_protection(self, sess_hdl, dev_id, pport):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - pport

        """
        self.send_mc_clear_port_protection(sess_hdl, dev_id, pport)
        self.recv_mc_clear_port_protection()

    def send_mc_clear_port_protection(self, sess_hdl, dev_id, pport):
        self._oprot.writeMessageBegin('mc_clear_port_protection', TMessageType.CALL, self._seqid)
        args = mc_clear_port_protection_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.pport = pport
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_clear_port_protection(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_clear_port_protection_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_set_max_nodes_before_yield(self, sess_hdl, dev_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - count

        """
        self.send_mc_set_max_nodes_before_yield(sess_hdl, dev_id, count)
        self.recv_mc_set_max_nodes_before_yield()

    def send_mc_set_max_nodes_before_yield(self, sess_hdl, dev_id, count):
        self._oprot.writeMessageBegin('mc_set_max_nodes_before_yield', TMessageType.CALL, self._seqid)
        args = mc_set_max_nodes_before_yield_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_max_nodes_before_yield(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_max_nodes_before_yield_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_set_max_node_threshold(self, sess_hdl, dev_id, node_count, lag_count):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - node_count
         - lag_count

        """
        self.send_mc_set_max_node_threshold(sess_hdl, dev_id, node_count, lag_count)
        self.recv_mc_set_max_node_threshold()

    def send_mc_set_max_node_threshold(self, sess_hdl, dev_id, node_count, lag_count):
        self._oprot.writeMessageBegin('mc_set_max_node_threshold', TMessageType.CALL, self._seqid)
        args = mc_set_max_node_threshold_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.node_count = node_count
        args.lag_count = lag_count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_set_max_node_threshold(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_set_max_node_threshold_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def mc_get_pipe_vec(self, sess_hdl, dev_id, mgid):
        """
        Parameters:
         - sess_hdl
         - dev_id
         - mgid

        """
        self.send_mc_get_pipe_vec(sess_hdl, dev_id, mgid)
        return self.recv_mc_get_pipe_vec()

    def send_mc_get_pipe_vec(self, sess_hdl, dev_id, mgid):
        self._oprot.writeMessageBegin('mc_get_pipe_vec', TMessageType.CALL, self._seqid)
        args = mc_get_pipe_vec_args()
        args.sess_hdl = sess_hdl
        args.dev_id = dev_id
        args.mgid = mgid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_mc_get_pipe_vec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = mc_get_pipe_vec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "mc_get_pipe_vec failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["mc_init"] = Processor.process_mc_init
        self._processMap["mc_create_session"] = Processor.process_mc_create_session
        self._processMap["mc_destroy_session"] = Processor.process_mc_destroy_session
        self._processMap["mc_complete_operations"] = Processor.process_mc_complete_operations
        self._processMap["mc_begin_batch"] = Processor.process_mc_begin_batch
        self._processMap["mc_flush_batch"] = Processor.process_mc_flush_batch
        self._processMap["mc_end_batch"] = Processor.process_mc_end_batch
        self._processMap["mc_mgrp_create"] = Processor.process_mc_mgrp_create
        self._processMap["mc_mgrp_get_attr"] = Processor.process_mc_mgrp_get_attr
        self._processMap["mc_mgrp_destroy"] = Processor.process_mc_mgrp_destroy
        self._processMap["mc_mgrp_get_first"] = Processor.process_mc_mgrp_get_first
        self._processMap["mc_mgrp_get_count"] = Processor.process_mc_mgrp_get_count
        self._processMap["mc_mgrp_get_next_i"] = Processor.process_mc_mgrp_get_next_i
        self._processMap["mc_mgrp_get_first_node_mbr"] = Processor.process_mc_mgrp_get_first_node_mbr
        self._processMap["mc_mgrp_get_node_mbr_count"] = Processor.process_mc_mgrp_get_node_mbr_count
        self._processMap["mc_mgrp_get_next_i_node_mbr"] = Processor.process_mc_mgrp_get_next_i_node_mbr
        self._processMap["mc_mgrp_get_first_ecmp_mbr"] = Processor.process_mc_mgrp_get_first_ecmp_mbr
        self._processMap["mc_mgrp_get_ecmp_mbr_count"] = Processor.process_mc_mgrp_get_ecmp_mbr_count
        self._processMap["mc_mgrp_get_next_i_ecmp_mbr"] = Processor.process_mc_mgrp_get_next_i_ecmp_mbr
        self._processMap["mc_node_create"] = Processor.process_mc_node_create
        self._processMap["mc_node_get_attr"] = Processor.process_mc_node_get_attr
        self._processMap["mc_node_update"] = Processor.process_mc_node_update
        self._processMap["mc_node_destroy"] = Processor.process_mc_node_destroy
        self._processMap["mc_node_get_first"] = Processor.process_mc_node_get_first
        self._processMap["mc_node_get_count"] = Processor.process_mc_node_get_count
        self._processMap["mc_node_get_next_i"] = Processor.process_mc_node_get_next_i
        self._processMap["mc_ecmp_get_mbr_from_hash"] = Processor.process_mc_ecmp_get_mbr_from_hash
        self._processMap["mc_node_get_association"] = Processor.process_mc_node_get_association
        self._processMap["mc_node_is_mbr"] = Processor.process_mc_node_is_mbr
        self._processMap["mc_associate_node"] = Processor.process_mc_associate_node
        self._processMap["mc_dissociate_node"] = Processor.process_mc_dissociate_node
        self._processMap["mc_ecmp_create"] = Processor.process_mc_ecmp_create
        self._processMap["mc_ecmp_destroy"] = Processor.process_mc_ecmp_destroy
        self._processMap["mc_ecmp_get_first"] = Processor.process_mc_ecmp_get_first
        self._processMap["mc_ecmp_get_count"] = Processor.process_mc_ecmp_get_count
        self._processMap["mc_ecmp_get_next_i"] = Processor.process_mc_ecmp_get_next_i
        self._processMap["mc_ecmp_mbr_add"] = Processor.process_mc_ecmp_mbr_add
        self._processMap["mc_ecmp_mbr_rem"] = Processor.process_mc_ecmp_mbr_rem
        self._processMap["mc_ecmp_get_first_mbr"] = Processor.process_mc_ecmp_get_first_mbr
        self._processMap["mc_ecmp_get_mbr_count"] = Processor.process_mc_ecmp_get_mbr_count
        self._processMap["mc_ecmp_get_next_i_mbr"] = Processor.process_mc_ecmp_get_next_i_mbr
        self._processMap["mc_associate_ecmp"] = Processor.process_mc_associate_ecmp
        self._processMap["mc_ecmp_get_assoc_attr"] = Processor.process_mc_ecmp_get_assoc_attr
        self._processMap["mc_dissociate_ecmp"] = Processor.process_mc_dissociate_ecmp
        self._processMap["mc_ecmp_get_first_assoc"] = Processor.process_mc_ecmp_get_first_assoc
        self._processMap["mc_ecmp_get_assoc_count"] = Processor.process_mc_ecmp_get_assoc_count
        self._processMap["mc_ecmp_get_next_i_assoc"] = Processor.process_mc_ecmp_get_next_i_assoc
        self._processMap["mc_set_lag_membership"] = Processor.process_mc_set_lag_membership
        self._processMap["mc_get_lag_membership"] = Processor.process_mc_get_lag_membership
        self._processMap["mc_get_lag_member_from_hash"] = Processor.process_mc_get_lag_member_from_hash
        self._processMap["mc_set_remote_lag_member_count"] = Processor.process_mc_set_remote_lag_member_count
        self._processMap["mc_update_port_prune_table"] = Processor.process_mc_update_port_prune_table
        self._processMap["mc_get_port_prune_table"] = Processor.process_mc_get_port_prune_table
        self._processMap["mc_set_global_rid"] = Processor.process_mc_set_global_rid
        self._processMap["mc_set_port_mc_fwd_state"] = Processor.process_mc_set_port_mc_fwd_state
        self._processMap["mc_enable_port_ff"] = Processor.process_mc_enable_port_ff
        self._processMap["mc_disable_port_ff"] = Processor.process_mc_disable_port_ff
        self._processMap["mc_clr_port_ff_state"] = Processor.process_mc_clr_port_ff_state
        self._processMap["mc_enable_port_protection"] = Processor.process_mc_enable_port_protection
        self._processMap["mc_disable_port_protection"] = Processor.process_mc_disable_port_protection
        self._processMap["mc_set_port_protection"] = Processor.process_mc_set_port_protection
        self._processMap["mc_clear_port_protection"] = Processor.process_mc_clear_port_protection
        self._processMap["mc_set_max_nodes_before_yield"] = Processor.process_mc_set_max_nodes_before_yield
        self._processMap["mc_set_max_node_threshold"] = Processor.process_mc_set_max_node_threshold
        self._processMap["mc_get_pipe_vec"] = Processor.process_mc_get_pipe_vec
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_mc_init(self, seqid, iprot, oprot):
        args = mc_init_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_init_result()
        try:
            self._handler.mc_init()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_init", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_create_session(self, seqid, iprot, oprot):
        args = mc_create_session_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_create_session_result()
        try:
            result.success = self._handler.mc_create_session()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_create_session", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_destroy_session(self, seqid, iprot, oprot):
        args = mc_destroy_session_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_destroy_session_result()
        try:
            self._handler.mc_destroy_session(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_destroy_session", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_complete_operations(self, seqid, iprot, oprot):
        args = mc_complete_operations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_complete_operations_result()
        try:
            self._handler.mc_complete_operations(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_complete_operations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_begin_batch(self, seqid, iprot, oprot):
        args = mc_begin_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_begin_batch_result()
        try:
            self._handler.mc_begin_batch(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_begin_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_flush_batch(self, seqid, iprot, oprot):
        args = mc_flush_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_flush_batch_result()
        try:
            self._handler.mc_flush_batch(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_flush_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_end_batch(self, seqid, iprot, oprot):
        args = mc_end_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_end_batch_result()
        try:
            self._handler.mc_end_batch(args.sess_hdl, args.hwSynchronous)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_end_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_create(self, seqid, iprot, oprot):
        args = mc_mgrp_create_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_create_result()
        try:
            result.success = self._handler.mc_mgrp_create(args.sess_hdl, args.dev_id, args.mgid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_create", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_attr(self, seqid, iprot, oprot):
        args = mc_mgrp_get_attr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_attr_result()
        try:
            result.success = self._handler.mc_mgrp_get_attr(args.sess_hdl, args.dev_id, args.mgrp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_attr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_destroy(self, seqid, iprot, oprot):
        args = mc_mgrp_destroy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_destroy_result()
        try:
            self._handler.mc_mgrp_destroy(args.sess_hdl, args.dev_id, args.grp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_destroy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_first(self, seqid, iprot, oprot):
        args = mc_mgrp_get_first_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_first_result()
        try:
            result.success = self._handler.mc_mgrp_get_first(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_first", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_count(self, seqid, iprot, oprot):
        args = mc_mgrp_get_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_count_result()
        try:
            result.success = self._handler.mc_mgrp_get_count(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_next_i(self, seqid, iprot, oprot):
        args = mc_mgrp_get_next_i_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_next_i_result()
        try:
            result.success = self._handler.mc_mgrp_get_next_i(args.sess_hdl, args.dev_id, args.mgrp_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_next_i", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_first_node_mbr(self, seqid, iprot, oprot):
        args = mc_mgrp_get_first_node_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_first_node_mbr_result()
        try:
            result.success = self._handler.mc_mgrp_get_first_node_mbr(args.sess_hdl, args.dev_id, args.mgrp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_first_node_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_node_mbr_count(self, seqid, iprot, oprot):
        args = mc_mgrp_get_node_mbr_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_node_mbr_count_result()
        try:
            result.success = self._handler.mc_mgrp_get_node_mbr_count(args.sess_hdl, args.dev_id, args.mgrp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_node_mbr_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_next_i_node_mbr(self, seqid, iprot, oprot):
        args = mc_mgrp_get_next_i_node_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_next_i_node_mbr_result()
        try:
            result.success = self._handler.mc_mgrp_get_next_i_node_mbr(args.sess_hdl, args.dev_id, args.mgrp_hdl, args.node_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_next_i_node_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_first_ecmp_mbr(self, seqid, iprot, oprot):
        args = mc_mgrp_get_first_ecmp_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_first_ecmp_mbr_result()
        try:
            result.success = self._handler.mc_mgrp_get_first_ecmp_mbr(args.sess_hdl, args.dev_id, args.mgrp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_first_ecmp_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_ecmp_mbr_count(self, seqid, iprot, oprot):
        args = mc_mgrp_get_ecmp_mbr_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_ecmp_mbr_count_result()
        try:
            result.success = self._handler.mc_mgrp_get_ecmp_mbr_count(args.sess_hdl, args.dev_id, args.mgrp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_ecmp_mbr_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_mgrp_get_next_i_ecmp_mbr(self, seqid, iprot, oprot):
        args = mc_mgrp_get_next_i_ecmp_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_mgrp_get_next_i_ecmp_mbr_result()
        try:
            result.success = self._handler.mc_mgrp_get_next_i_ecmp_mbr(args.sess_hdl, args.dev_id, args.mgrp_hdl, args.ecmp_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_mgrp_get_next_i_ecmp_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_create(self, seqid, iprot, oprot):
        args = mc_node_create_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_create_result()
        try:
            result.success = self._handler.mc_node_create(args.sess_hdl, args.dev_id, args.rid, args.port_map, args.lag_map)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_create", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_get_attr(self, seqid, iprot, oprot):
        args = mc_node_get_attr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_get_attr_result()
        try:
            result.success = self._handler.mc_node_get_attr(args.sess_hdl, args.dev_id, args.mgrp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_get_attr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_update(self, seqid, iprot, oprot):
        args = mc_node_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_update_result()
        try:
            self._handler.mc_node_update(args.sess_hdl, args.dev_id, args.l1_hdl, args.port_map, args.lag_map)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_destroy(self, seqid, iprot, oprot):
        args = mc_node_destroy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_destroy_result()
        try:
            self._handler.mc_node_destroy(args.sess_hdl, args.dev_id, args.l1_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_destroy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_get_first(self, seqid, iprot, oprot):
        args = mc_node_get_first_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_get_first_result()
        try:
            result.success = self._handler.mc_node_get_first(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_get_first", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_get_count(self, seqid, iprot, oprot):
        args = mc_node_get_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_get_count_result()
        try:
            result.success = self._handler.mc_node_get_count(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_get_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_get_next_i(self, seqid, iprot, oprot):
        args = mc_node_get_next_i_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_get_next_i_result()
        try:
            result.success = self._handler.mc_node_get_next_i(args.sess_hdl, args.dev_id, args.node_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_get_next_i", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_mbr_from_hash(self, seqid, iprot, oprot):
        args = mc_ecmp_get_mbr_from_hash_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_mbr_from_hash_result()
        try:
            result.success = self._handler.mc_ecmp_get_mbr_from_hash(args.sess_hdl, args.dev_id, args.mgrp_hdl, args.ecmp_hdl, args.level1_mcast_hash, args.pkt_xid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_mbr_from_hash", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_get_association(self, seqid, iprot, oprot):
        args = mc_node_get_association_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_get_association_result()
        try:
            result.success = self._handler.mc_node_get_association(args.sess_hdl, args.dev_id, args.node_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_get_association", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_node_is_mbr(self, seqid, iprot, oprot):
        args = mc_node_is_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_node_is_mbr_result()
        try:
            result.success = self._handler.mc_node_is_mbr(args.sess_hdl, args.dev_id, args.node_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_node_is_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_associate_node(self, seqid, iprot, oprot):
        args = mc_associate_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_associate_node_result()
        try:
            self._handler.mc_associate_node(args.sess_hdl, args.dev_id, args.grp_hdl, args.l1_hdl, args.xid, args.xid_valid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_associate_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_dissociate_node(self, seqid, iprot, oprot):
        args = mc_dissociate_node_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_dissociate_node_result()
        try:
            self._handler.mc_dissociate_node(args.sess_hdl, args.dev_id, args.grp_hdl, args.l1_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_dissociate_node", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_create(self, seqid, iprot, oprot):
        args = mc_ecmp_create_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_create_result()
        try:
            result.success = self._handler.mc_ecmp_create(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_create", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_destroy(self, seqid, iprot, oprot):
        args = mc_ecmp_destroy_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_destroy_result()
        try:
            self._handler.mc_ecmp_destroy(args.sess_hdl, args.dev_id, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_destroy", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_first(self, seqid, iprot, oprot):
        args = mc_ecmp_get_first_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_first_result()
        try:
            result.success = self._handler.mc_ecmp_get_first(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_first", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_count(self, seqid, iprot, oprot):
        args = mc_ecmp_get_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_count_result()
        try:
            result.success = self._handler.mc_ecmp_get_count(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_next_i(self, seqid, iprot, oprot):
        args = mc_ecmp_get_next_i_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_next_i_result()
        try:
            result.success = self._handler.mc_ecmp_get_next_i(args.sess_hdl, args.dev_id, args.ecmp_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_next_i", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_mbr_add(self, seqid, iprot, oprot):
        args = mc_ecmp_mbr_add_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_mbr_add_result()
        try:
            self._handler.mc_ecmp_mbr_add(args.sess_hdl, args.dev_id, args.ecmp_hdl, args.l1_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_mbr_add", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_mbr_rem(self, seqid, iprot, oprot):
        args = mc_ecmp_mbr_rem_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_mbr_rem_result()
        try:
            self._handler.mc_ecmp_mbr_rem(args.sess_hdl, args.dev_id, args.ecmp_hdl, args.l1_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_mbr_rem", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_first_mbr(self, seqid, iprot, oprot):
        args = mc_ecmp_get_first_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_first_mbr_result()
        try:
            result.success = self._handler.mc_ecmp_get_first_mbr(args.sess_hdl, args.dev_id, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_first_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_mbr_count(self, seqid, iprot, oprot):
        args = mc_ecmp_get_mbr_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_mbr_count_result()
        try:
            result.success = self._handler.mc_ecmp_get_mbr_count(args.sess_hdl, args.dev_id, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_mbr_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_next_i_mbr(self, seqid, iprot, oprot):
        args = mc_ecmp_get_next_i_mbr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_next_i_mbr_result()
        try:
            result.success = self._handler.mc_ecmp_get_next_i_mbr(args.sess_hdl, args.dev_id, args.ecmp_hdl, args.node_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_next_i_mbr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_associate_ecmp(self, seqid, iprot, oprot):
        args = mc_associate_ecmp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_associate_ecmp_result()
        try:
            self._handler.mc_associate_ecmp(args.sess_hdl, args.dev_id, args.grp_hdl, args.ecmp_hdl, args.xid, args.xid_valid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_associate_ecmp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_assoc_attr(self, seqid, iprot, oprot):
        args = mc_ecmp_get_assoc_attr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_assoc_attr_result()
        try:
            result.success = self._handler.mc_ecmp_get_assoc_attr(args.sess_hdl, args.dev_id, args.grp_hdl, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_assoc_attr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_dissociate_ecmp(self, seqid, iprot, oprot):
        args = mc_dissociate_ecmp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_dissociate_ecmp_result()
        try:
            self._handler.mc_dissociate_ecmp(args.sess_hdl, args.dev_id, args.grp_hdl, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_dissociate_ecmp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_first_assoc(self, seqid, iprot, oprot):
        args = mc_ecmp_get_first_assoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_first_assoc_result()
        try:
            result.success = self._handler.mc_ecmp_get_first_assoc(args.sess_hdl, args.dev_id, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_first_assoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_assoc_count(self, seqid, iprot, oprot):
        args = mc_ecmp_get_assoc_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_assoc_count_result()
        try:
            result.success = self._handler.mc_ecmp_get_assoc_count(args.sess_hdl, args.dev_id, args.ecmp_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_assoc_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_ecmp_get_next_i_assoc(self, seqid, iprot, oprot):
        args = mc_ecmp_get_next_i_assoc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_ecmp_get_next_i_assoc_result()
        try:
            result.success = self._handler.mc_ecmp_get_next_i_assoc(args.sess_hdl, args.dev_id, args.ecmp_hdl, args.mgrp_hdl, args.n)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_ecmp_get_next_i_assoc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_lag_membership(self, seqid, iprot, oprot):
        args = mc_set_lag_membership_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_lag_membership_result()
        try:
            self._handler.mc_set_lag_membership(args.sess_hdl, args.dev_id, args.lag_index, args.port_map)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_lag_membership", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_get_lag_membership(self, seqid, iprot, oprot):
        args = mc_get_lag_membership_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_get_lag_membership_result()
        try:
            result.success = self._handler.mc_get_lag_membership(args.sess_hdl, args.dev_id, args.lag_index)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_get_lag_membership", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_get_lag_member_from_hash(self, seqid, iprot, oprot):
        args = mc_get_lag_member_from_hash_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_get_lag_member_from_hash_result()
        try:
            result.success = self._handler.mc_get_lag_member_from_hash(args.sess_hdl, args.dev_id, args.l1_hdl, args.lag_index, args.level2_mcast_hash, args.pkt_xid, args.pkt_yid, args.pkt_rid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_get_lag_member_from_hash", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_remote_lag_member_count(self, seqid, iprot, oprot):
        args = mc_set_remote_lag_member_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_remote_lag_member_count_result()
        try:
            self._handler.mc_set_remote_lag_member_count(args.sess_hdl, args.dev_id, args.lag_index, args.left, args.right)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_remote_lag_member_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_update_port_prune_table(self, seqid, iprot, oprot):
        args = mc_update_port_prune_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_update_port_prune_table_result()
        try:
            self._handler.mc_update_port_prune_table(args.sess_hdl, args.dev_id, args.yid, args.port_map)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_update_port_prune_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_get_port_prune_table(self, seqid, iprot, oprot):
        args = mc_get_port_prune_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_get_port_prune_table_result()
        try:
            result.success = self._handler.mc_get_port_prune_table(args.sess_hdl, args.dev_id, args.yid, args.from_hw)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_get_port_prune_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_global_rid(self, seqid, iprot, oprot):
        args = mc_set_global_rid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_global_rid_result()
        try:
            self._handler.mc_set_global_rid(args.sess_hdl, args.dev_id, args.rid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_global_rid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_port_mc_fwd_state(self, seqid, iprot, oprot):
        args = mc_set_port_mc_fwd_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_port_mc_fwd_state_result()
        try:
            self._handler.mc_set_port_mc_fwd_state(args.sess_hdl, args.dev_id, args.port, args.is_active)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_port_mc_fwd_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_enable_port_ff(self, seqid, iprot, oprot):
        args = mc_enable_port_ff_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_enable_port_ff_result()
        try:
            self._handler.mc_enable_port_ff(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_enable_port_ff", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_disable_port_ff(self, seqid, iprot, oprot):
        args = mc_disable_port_ff_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_disable_port_ff_result()
        try:
            self._handler.mc_disable_port_ff(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_disable_port_ff", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_clr_port_ff_state(self, seqid, iprot, oprot):
        args = mc_clr_port_ff_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_clr_port_ff_state_result()
        try:
            self._handler.mc_clr_port_ff_state(args.sess_hdl, args.dev_id, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_clr_port_ff_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_enable_port_protection(self, seqid, iprot, oprot):
        args = mc_enable_port_protection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_enable_port_protection_result()
        try:
            self._handler.mc_enable_port_protection(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_enable_port_protection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_disable_port_protection(self, seqid, iprot, oprot):
        args = mc_disable_port_protection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_disable_port_protection_result()
        try:
            self._handler.mc_disable_port_protection(args.sess_hdl, args.dev_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_disable_port_protection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_port_protection(self, seqid, iprot, oprot):
        args = mc_set_port_protection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_port_protection_result()
        try:
            self._handler.mc_set_port_protection(args.sess_hdl, args.dev_id, args.pport, args.bport)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_port_protection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_clear_port_protection(self, seqid, iprot, oprot):
        args = mc_clear_port_protection_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_clear_port_protection_result()
        try:
            self._handler.mc_clear_port_protection(args.sess_hdl, args.dev_id, args.pport)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_clear_port_protection", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_max_nodes_before_yield(self, seqid, iprot, oprot):
        args = mc_set_max_nodes_before_yield_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_max_nodes_before_yield_result()
        try:
            self._handler.mc_set_max_nodes_before_yield(args.sess_hdl, args.dev_id, args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_max_nodes_before_yield", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_set_max_node_threshold(self, seqid, iprot, oprot):
        args = mc_set_max_node_threshold_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_set_max_node_threshold_result()
        try:
            self._handler.mc_set_max_node_threshold(args.sess_hdl, args.dev_id, args.node_count, args.lag_count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_set_max_node_threshold", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_mc_get_pipe_vec(self, seqid, iprot, oprot):
        args = mc_get_pipe_vec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = mc_get_pipe_vec_result()
        try:
            result.success = self._handler.mc_get_pipe_vec(args.sess_hdl, args.dev_id, args.mgid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidMcOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("mc_get_pipe_vec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class mc_init_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_init_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_init_args)
mc_init_args.thrift_spec = (
)


class mc_init_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_init_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_init_result)
mc_init_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_create_session_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_create_session_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_create_session_args)
mc_create_session_args.thrift_spec = (
)


class mc_create_session_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_create_session_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_create_session_result)
mc_create_session_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_destroy_session_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_destroy_session_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_destroy_session_args)
mc_destroy_session_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class mc_destroy_session_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_destroy_session_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_destroy_session_result)
mc_destroy_session_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_complete_operations_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_complete_operations_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_complete_operations_args)
mc_complete_operations_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class mc_complete_operations_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_complete_operations_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_complete_operations_result)
mc_complete_operations_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_begin_batch_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_begin_batch_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_begin_batch_args)
mc_begin_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class mc_begin_batch_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_begin_batch_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_begin_batch_result)
mc_begin_batch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_flush_batch_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_flush_batch_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_flush_batch_args)
mc_flush_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class mc_flush_batch_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_flush_batch_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_flush_batch_result)
mc_flush_batch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_end_batch_args(object):
    """
    Attributes:
     - sess_hdl
     - hwSynchronous

    """


    def __init__(self, sess_hdl=None, hwSynchronous=None,):
        self.sess_hdl = sess_hdl
        self.hwSynchronous = hwSynchronous

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hwSynchronous = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_end_batch_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.hwSynchronous is not None:
            oprot.writeFieldBegin('hwSynchronous', TType.BOOL, 2)
            oprot.writeBool(self.hwSynchronous)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_end_batch_args)
mc_end_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BOOL, 'hwSynchronous', None, None, ),  # 2
)


class mc_end_batch_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_end_batch_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_end_batch_result)
mc_end_batch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_create_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgid

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgid = mgid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.mgid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_create_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgid is not None:
            oprot.writeFieldBegin('mgid', TType.I16, 3)
            oprot.writeI16(self.mgid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_create_args)
mc_mgrp_create_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'mgid', None, None, ),  # 3
)


class mc_mgrp_create_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_create_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_create_result)
mc_mgrp_create_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_attr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_attr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_attr_args)
mc_mgrp_get_attr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
)


class mc_mgrp_get_attr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_mgrp_attr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_attr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_attr_result)
mc_mgrp_get_attr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_mgrp_attr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_destroy_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - grp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, grp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.grp_hdl = grp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_destroy_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 3)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_destroy_args)
mc_mgrp_destroy_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'grp_hdl', None, None, ),  # 3
)


class mc_mgrp_destroy_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_destroy_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_destroy_result)
mc_mgrp_destroy_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_first_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_first_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_first_args)
mc_mgrp_get_first_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_mgrp_get_first_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_first_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_first_result)
mc_mgrp_get_first_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_count_args)
mc_mgrp_get_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_mgrp_get_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_count_result)
mc_mgrp_get_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_next_i_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_next_i_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_next_i_args)
mc_mgrp_get_next_i_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class mc_mgrp_get_next_i_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.success.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_next_i_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter6 in self.success:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_next_i_result)
mc_mgrp_get_next_i_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_first_node_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_first_node_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_first_node_mbr_args)
mc_mgrp_get_first_node_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
)


class mc_mgrp_get_first_node_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_mgrp_node_mbr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_first_node_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_first_node_mbr_result)
mc_mgrp_get_first_node_mbr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_mgrp_node_mbr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_node_mbr_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_node_mbr_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_node_mbr_count_args)
mc_mgrp_get_node_mbr_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
)


class mc_mgrp_get_node_mbr_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_node_mbr_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_node_mbr_count_result)
mc_mgrp_get_node_mbr_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_next_i_node_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl
     - node_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None, node_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl
        self.node_hdl = node_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.node_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_next_i_node_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        if self.node_hdl is not None:
            oprot.writeFieldBegin('node_hdl', TType.I32, 4)
            oprot.writeI32(self.node_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 5)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_next_i_node_mbr_args)
mc_mgrp_get_next_i_node_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
    (4, TType.I32, 'node_hdl', None, None, ),  # 4
    (5, TType.I32, 'n', None, None, ),  # 5
)


class mc_mgrp_get_next_i_node_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = mc_mgrp_node_mbr()
                        _elem12.read(iprot)
                        self.success.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_next_i_node_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter13 in self.success:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_next_i_node_mbr_result)
mc_mgrp_get_next_i_node_mbr_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [mc_mgrp_node_mbr, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_first_ecmp_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_first_ecmp_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_first_ecmp_mbr_args)
mc_mgrp_get_first_ecmp_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
)


class mc_mgrp_get_first_ecmp_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_mgrp_ecmp_mbr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_first_ecmp_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_first_ecmp_mbr_result)
mc_mgrp_get_first_ecmp_mbr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_mgrp_ecmp_mbr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_ecmp_mbr_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_ecmp_mbr_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_ecmp_mbr_count_args)
mc_mgrp_get_ecmp_mbr_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
)


class mc_mgrp_get_ecmp_mbr_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_ecmp_mbr_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_ecmp_mbr_count_result)
mc_mgrp_get_ecmp_mbr_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_mgrp_get_next_i_ecmp_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl
     - ecmp_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None, ecmp_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl
        self.ecmp_hdl = ecmp_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_next_i_ecmp_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 4)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 5)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_next_i_ecmp_mbr_args)
mc_mgrp_get_next_i_ecmp_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
    (4, TType.I32, 'ecmp_hdl', None, None, ),  # 4
    (5, TType.I32, 'n', None, None, ),  # 5
)


class mc_mgrp_get_next_i_ecmp_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = mc_mgrp_ecmp_mbr()
                        _elem19.read(iprot)
                        self.success.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_mgrp_get_next_i_ecmp_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter20 in self.success:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_mgrp_get_next_i_ecmp_mbr_result)
mc_mgrp_get_next_i_ecmp_mbr_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [mc_mgrp_ecmp_mbr, None], False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_create_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - rid
     - port_map
     - lag_map

    """


    def __init__(self, sess_hdl=None, dev_id=None, rid=None, port_map=None, lag_map=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.rid = rid
        self.port_map = port_map
        self.lag_map = lag_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.rid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.port_map = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.lag_map = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_create_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.rid is not None:
            oprot.writeFieldBegin('rid', TType.I16, 3)
            oprot.writeI16(self.rid)
            oprot.writeFieldEnd()
        if self.port_map is not None:
            oprot.writeFieldBegin('port_map', TType.STRING, 4)
            oprot.writeBinary(self.port_map)
            oprot.writeFieldEnd()
        if self.lag_map is not None:
            oprot.writeFieldBegin('lag_map', TType.STRING, 5)
            oprot.writeBinary(self.lag_map)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_create_args)
mc_node_create_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'rid', None, None, ),  # 3
    (4, TType.STRING, 'port_map', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'lag_map', 'BINARY', None, ),  # 5
)


class mc_node_create_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_create_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_create_result)
mc_node_create_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_get_attr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_attr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_attr_args)
mc_node_get_attr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'mgrp_hdl', None, None, ),  # 3
)


class mc_node_get_attr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_node_attr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_attr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_attr_result)
mc_node_get_attr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_node_attr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_update_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - l1_hdl
     - port_map
     - lag_map

    """


    def __init__(self, sess_hdl=None, dev_id=None, l1_hdl=None, port_map=None, lag_map=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.l1_hdl = l1_hdl
        self.port_map = port_map
        self.lag_map = lag_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.port_map = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.lag_map = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_update_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 3)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        if self.port_map is not None:
            oprot.writeFieldBegin('port_map', TType.STRING, 4)
            oprot.writeBinary(self.port_map)
            oprot.writeFieldEnd()
        if self.lag_map is not None:
            oprot.writeFieldBegin('lag_map', TType.STRING, 5)
            oprot.writeBinary(self.lag_map)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_update_args)
mc_node_update_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'l1_hdl', None, None, ),  # 3
    (4, TType.STRING, 'port_map', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'lag_map', 'BINARY', None, ),  # 5
)


class mc_node_update_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_update_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_update_result)
mc_node_update_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_destroy_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - l1_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, l1_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.l1_hdl = l1_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_destroy_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 3)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_destroy_args)
mc_node_destroy_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'l1_hdl', None, None, ),  # 3
)


class mc_node_destroy_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_destroy_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_destroy_result)
mc_node_destroy_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_get_first_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_first_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_first_args)
mc_node_get_first_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_node_get_first_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_first_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_first_result)
mc_node_get_first_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_get_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_count_args)
mc_node_get_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_node_get_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_count_result)
mc_node_get_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_get_next_i_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - node_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, node_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.node_hdl = node_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_next_i_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.node_hdl is not None:
            oprot.writeFieldBegin('node_hdl', TType.I32, 3)
            oprot.writeI32(self.node_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_next_i_args)
mc_node_get_next_i_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'node_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class mc_node_get_next_i_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI32()
                        self.success.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_next_i_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter27 in self.success:
                oprot.writeI32(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_next_i_result)
mc_node_get_next_i_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_mbr_from_hash_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgrp_hdl
     - ecmp_hdl
     - level1_mcast_hash
     - pkt_xid

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgrp_hdl=None, ecmp_hdl=None, level1_mcast_hash=None, pkt_xid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgrp_hdl = mgrp_hdl
        self.ecmp_hdl = ecmp_hdl
        self.level1_mcast_hash = level1_mcast_hash
        self.pkt_xid = pkt_xid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.level1_mcast_hash = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == -1:
                if ftype == TType.I16:
                    self.pkt_xid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_mbr_from_hash_args')
        if self.pkt_xid is not None:
            oprot.writeFieldBegin('pkt_xid', TType.I16, -1)
            oprot.writeI16(self.pkt_xid)
            oprot.writeFieldEnd()
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 3)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 4)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.level1_mcast_hash is not None:
            oprot.writeFieldBegin('level1_mcast_hash', TType.I16, 5)
            oprot.writeI16(self.level1_mcast_hash)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_mbr_from_hash_args)
mc_ecmp_get_mbr_from_hash_args.thrift_spec = ()


class mc_ecmp_get_mbr_from_hash_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_ecmp_mbr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_mbr_from_hash_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_mbr_from_hash_result)
mc_ecmp_get_mbr_from_hash_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_ecmp_mbr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_get_association_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - node_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, node_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.node_hdl = node_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_association_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.node_hdl is not None:
            oprot.writeFieldBegin('node_hdl', TType.I32, 3)
            oprot.writeI32(self.node_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_association_args)
mc_node_get_association_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'node_hdl', None, None, ),  # 3
)


class mc_node_get_association_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_node_assoc_attr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_get_association_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_get_association_result)
mc_node_get_association_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_node_assoc_attr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_node_is_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - node_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, node_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.node_hdl = node_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_is_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.node_hdl is not None:
            oprot.writeFieldBegin('node_hdl', TType.I32, 3)
            oprot.writeI32(self.node_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_is_mbr_args)
mc_node_is_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'node_hdl', None, None, ),  # 3
)


class mc_node_is_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_node_is_member()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_node_is_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_node_is_mbr_result)
mc_node_is_mbr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_node_is_member, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_associate_node_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - grp_hdl
     - l1_hdl
     - xid
     - xid_valid

    """


    def __init__(self, sess_hdl=None, dev_id=None, grp_hdl=None, l1_hdl=None, xid=None, xid_valid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.grp_hdl = grp_hdl
        self.l1_hdl = l1_hdl
        self.xid = xid
        self.xid_valid = xid_valid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.xid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.xid_valid = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_associate_node_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 3)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 4)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.I16, 5)
            oprot.writeI16(self.xid)
            oprot.writeFieldEnd()
        if self.xid_valid is not None:
            oprot.writeFieldBegin('xid_valid', TType.BYTE, 6)
            oprot.writeByte(self.xid_valid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_associate_node_args)
mc_associate_node_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'l1_hdl', None, None, ),  # 4
    (5, TType.I16, 'xid', None, None, ),  # 5
    (6, TType.BYTE, 'xid_valid', None, None, ),  # 6
)


class mc_associate_node_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_associate_node_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_associate_node_result)
mc_associate_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_dissociate_node_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - grp_hdl
     - l1_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, grp_hdl=None, l1_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.grp_hdl = grp_hdl
        self.l1_hdl = l1_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_dissociate_node_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 3)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 4)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_dissociate_node_args)
mc_dissociate_node_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'l1_hdl', None, None, ),  # 4
)


class mc_dissociate_node_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_dissociate_node_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_dissociate_node_result)
mc_dissociate_node_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_create_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_create_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_create_args)
mc_ecmp_create_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_ecmp_create_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_create_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_create_result)
mc_ecmp_create_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_destroy_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_destroy_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_destroy_args)
mc_ecmp_destroy_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
)


class mc_ecmp_destroy_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_destroy_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_destroy_result)
mc_ecmp_destroy_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_first_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_first_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_first_args)
mc_ecmp_get_first_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_ecmp_get_first_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_first_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_first_result)
mc_ecmp_get_first_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_count_args)
mc_ecmp_get_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_ecmp_get_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_count_result)
mc_ecmp_get_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_next_i_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_next_i_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 4)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_next_i_args)
mc_ecmp_get_next_i_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
    (4, TType.I32, 'n', None, None, ),  # 4
)


class mc_ecmp_get_next_i_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI32()
                        self.success.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_next_i_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter34 in self.success:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_next_i_result)
mc_ecmp_get_next_i_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_mbr_add_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl
     - l1_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None, l1_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl
        self.l1_hdl = l1_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_mbr_add_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 4)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_mbr_add_args)
mc_ecmp_mbr_add_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
    (4, TType.I32, 'l1_hdl', None, None, ),  # 4
)


class mc_ecmp_mbr_add_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_mbr_add_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_mbr_add_result)
mc_ecmp_mbr_add_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_mbr_rem_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl
     - l1_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None, l1_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl
        self.l1_hdl = l1_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_mbr_rem_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 4)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_mbr_rem_args)
mc_ecmp_mbr_rem_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
    (4, TType.I32, 'l1_hdl', None, None, ),  # 4
)


class mc_ecmp_mbr_rem_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_mbr_rem_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_mbr_rem_result)
mc_ecmp_mbr_rem_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_first_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_first_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_first_mbr_args)
mc_ecmp_get_first_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
)


class mc_ecmp_get_first_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_first_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_first_mbr_result)
mc_ecmp_get_first_mbr_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_mbr_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_mbr_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_mbr_count_args)
mc_ecmp_get_mbr_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
)


class mc_ecmp_get_mbr_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_mbr_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_mbr_count_result)
mc_ecmp_get_mbr_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_next_i_mbr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl
     - node_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None, node_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl
        self.node_hdl = node_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.node_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_next_i_mbr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.node_hdl is not None:
            oprot.writeFieldBegin('node_hdl', TType.I32, 4)
            oprot.writeI32(self.node_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 5)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_next_i_mbr_args)
mc_ecmp_get_next_i_mbr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
    (4, TType.I32, 'node_hdl', None, None, ),  # 4
    (5, TType.I32, 'n', None, None, ),  # 5
)


class mc_ecmp_get_next_i_mbr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readI32()
                        self.success.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_next_i_mbr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter41 in self.success:
                oprot.writeI32(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_next_i_mbr_result)
mc_ecmp_get_next_i_mbr_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_associate_ecmp_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - grp_hdl
     - ecmp_hdl
     - xid
     - xid_valid

    """


    def __init__(self, sess_hdl=None, dev_id=None, grp_hdl=None, ecmp_hdl=None, xid=None, xid_valid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.grp_hdl = grp_hdl
        self.ecmp_hdl = ecmp_hdl
        self.xid = xid
        self.xid_valid = xid_valid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.xid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.xid_valid = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_associate_ecmp_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 3)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 4)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.xid is not None:
            oprot.writeFieldBegin('xid', TType.I16, 5)
            oprot.writeI16(self.xid)
            oprot.writeFieldEnd()
        if self.xid_valid is not None:
            oprot.writeFieldBegin('xid_valid', TType.BYTE, 6)
            oprot.writeByte(self.xid_valid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_associate_ecmp_args)
mc_associate_ecmp_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'ecmp_hdl', None, None, ),  # 4
    (5, TType.I16, 'xid', None, None, ),  # 5
    (6, TType.BYTE, 'xid_valid', None, None, ),  # 6
)


class mc_associate_ecmp_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_associate_ecmp_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_associate_ecmp_result)
mc_associate_ecmp_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_assoc_attr_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - grp_hdl
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, grp_hdl=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.grp_hdl = grp_hdl
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_assoc_attr_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 3)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 4)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_assoc_attr_args)
mc_ecmp_get_assoc_attr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'ecmp_hdl', None, None, ),  # 4
)


class mc_ecmp_get_assoc_attr_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_ecmp_assoc_attr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_assoc_attr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_assoc_attr_result)
mc_ecmp_get_assoc_attr_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_ecmp_assoc_attr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_dissociate_ecmp_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - grp_hdl
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, grp_hdl=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.grp_hdl = grp_hdl
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.grp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_dissociate_ecmp_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.grp_hdl is not None:
            oprot.writeFieldBegin('grp_hdl', TType.I32, 3)
            oprot.writeI32(self.grp_hdl)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 4)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_dissociate_ecmp_args)
mc_dissociate_ecmp_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'grp_hdl', None, None, ),  # 3
    (4, TType.I32, 'ecmp_hdl', None, None, ),  # 4
)


class mc_dissociate_ecmp_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_dissociate_ecmp_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_dissociate_ecmp_result)
mc_dissociate_ecmp_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_first_assoc_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_first_assoc_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_first_assoc_args)
mc_ecmp_get_first_assoc_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
)


class mc_ecmp_get_first_assoc_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_first_assoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_first_assoc_result)
mc_ecmp_get_first_assoc_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_assoc_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_assoc_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_assoc_count_args)
mc_ecmp_get_assoc_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
)


class mc_ecmp_get_assoc_count_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_assoc_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_assoc_count_result)
mc_ecmp_get_assoc_count_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_ecmp_get_next_i_assoc_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - ecmp_hdl
     - mgrp_hdl
     - n

    """


    def __init__(self, sess_hdl=None, dev_id=None, ecmp_hdl=None, mgrp_hdl=None, n=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.ecmp_hdl = ecmp_hdl
        self.mgrp_hdl = mgrp_hdl
        self.n = n

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ecmp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mgrp_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.n = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_next_i_assoc_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.ecmp_hdl is not None:
            oprot.writeFieldBegin('ecmp_hdl', TType.I32, 3)
            oprot.writeI32(self.ecmp_hdl)
            oprot.writeFieldEnd()
        if self.mgrp_hdl is not None:
            oprot.writeFieldBegin('mgrp_hdl', TType.I32, 4)
            oprot.writeI32(self.mgrp_hdl)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin('n', TType.I32, 5)
            oprot.writeI32(self.n)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_next_i_assoc_args)
mc_ecmp_get_next_i_assoc_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'ecmp_hdl', None, None, ),  # 3
    (4, TType.I32, 'mgrp_hdl', None, None, ),  # 4
    (5, TType.I32, 'n', None, None, ),  # 5
)


class mc_ecmp_get_next_i_assoc_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readI32()
                        self.success.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_ecmp_get_next_i_assoc_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter48 in self.success:
                oprot.writeI32(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_ecmp_get_next_i_assoc_result)
mc_ecmp_get_next_i_assoc_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_lag_membership_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - lag_index
     - port_map

    """


    def __init__(self, sess_hdl=None, dev_id=None, lag_index=None, port_map=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.lag_index = lag_index
        self.port_map = port_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.lag_index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.port_map = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_lag_membership_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.lag_index is not None:
            oprot.writeFieldBegin('lag_index', TType.BYTE, 3)
            oprot.writeByte(self.lag_index)
            oprot.writeFieldEnd()
        if self.port_map is not None:
            oprot.writeFieldBegin('port_map', TType.STRING, 4)
            oprot.writeBinary(self.port_map)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_lag_membership_args)
mc_set_lag_membership_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.BYTE, 'lag_index', None, None, ),  # 3
    (4, TType.STRING, 'port_map', 'BINARY', None, ),  # 4
)


class mc_set_lag_membership_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_lag_membership_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_lag_membership_result)
mc_set_lag_membership_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_get_lag_membership_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - lag_index

    """


    def __init__(self, sess_hdl=None, dev_id=None, lag_index=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.lag_index = lag_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.lag_index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_lag_membership_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.lag_index is not None:
            oprot.writeFieldBegin('lag_index', TType.BYTE, 3)
            oprot.writeByte(self.lag_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_lag_membership_args)
mc_get_lag_membership_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.BYTE, 'lag_index', None, None, ),  # 3
)


class mc_get_lag_membership_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_lag_membership_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_lag_membership_result)
mc_get_lag_membership_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_get_lag_member_from_hash_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - l1_hdl
     - lag_index
     - level2_mcast_hash
     - pkt_xid
     - pkt_yid
     - pkt_rid

    """


    def __init__(self, sess_hdl=None, dev_id=None, l1_hdl=None, lag_index=None, level2_mcast_hash=None, pkt_xid=None, pkt_yid=None, pkt_rid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.l1_hdl = l1_hdl
        self.lag_index = lag_index
        self.level2_mcast_hash = level2_mcast_hash
        self.pkt_xid = pkt_xid
        self.pkt_yid = pkt_yid
        self.pkt_rid = pkt_rid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.l1_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.lag_index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I16:
                    self.level2_mcast_hash = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I16:
                    self.pkt_xid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I16:
                    self.pkt_yid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I16:
                    self.pkt_rid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_lag_member_from_hash_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.l1_hdl is not None:
            oprot.writeFieldBegin('l1_hdl', TType.I32, 3)
            oprot.writeI32(self.l1_hdl)
            oprot.writeFieldEnd()
        if self.lag_index is not None:
            oprot.writeFieldBegin('lag_index', TType.BYTE, 4)
            oprot.writeByte(self.lag_index)
            oprot.writeFieldEnd()
        if self.level2_mcast_hash is not None:
            oprot.writeFieldBegin('level2_mcast_hash', TType.I16, 5)
            oprot.writeI16(self.level2_mcast_hash)
            oprot.writeFieldEnd()
        if self.pkt_xid is not None:
            oprot.writeFieldBegin('pkt_xid', TType.I16, 6)
            oprot.writeI16(self.pkt_xid)
            oprot.writeFieldEnd()
        if self.pkt_yid is not None:
            oprot.writeFieldBegin('pkt_yid', TType.I16, 7)
            oprot.writeI16(self.pkt_yid)
            oprot.writeFieldEnd()
        if self.pkt_rid is not None:
            oprot.writeFieldBegin('pkt_rid', TType.I16, 8)
            oprot.writeI16(self.pkt_rid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_lag_member_from_hash_args)
mc_get_lag_member_from_hash_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'l1_hdl', None, None, ),  # 3
    (4, TType.BYTE, 'lag_index', None, None, ),  # 4
    (5, TType.I16, 'level2_mcast_hash', None, None, ),  # 5
    (6, TType.I16, 'pkt_xid', None, None, ),  # 6
    (7, TType.I16, 'pkt_yid', None, None, ),  # 7
    (8, TType.I16, 'pkt_rid', None, None, ),  # 8
)


class mc_get_lag_member_from_hash_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = mc_lag_mbr()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_lag_member_from_hash_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_lag_member_from_hash_result)
mc_get_lag_member_from_hash_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [mc_lag_mbr, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_remote_lag_member_count_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - lag_index
     - left
     - right

    """


    def __init__(self, sess_hdl=None, dev_id=None, lag_index=None, left=None, right=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.lag_index = lag_index
        self.left = left
        self.right = right

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.lag_index = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.left = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.right = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_remote_lag_member_count_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.lag_index is not None:
            oprot.writeFieldBegin('lag_index', TType.BYTE, 3)
            oprot.writeByte(self.lag_index)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.I32, 4)
            oprot.writeI32(self.left)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.I32, 5)
            oprot.writeI32(self.right)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_remote_lag_member_count_args)
mc_set_remote_lag_member_count_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.BYTE, 'lag_index', None, None, ),  # 3
    (4, TType.I32, 'left', None, None, ),  # 4
    (5, TType.I32, 'right', None, None, ),  # 5
)


class mc_set_remote_lag_member_count_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_remote_lag_member_count_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_remote_lag_member_count_result)
mc_set_remote_lag_member_count_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_update_port_prune_table_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - yid
     - port_map

    """


    def __init__(self, sess_hdl=None, dev_id=None, yid=None, port_map=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.yid = yid
        self.port_map = port_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.yid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.port_map = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_update_port_prune_table_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.yid is not None:
            oprot.writeFieldBegin('yid', TType.I16, 3)
            oprot.writeI16(self.yid)
            oprot.writeFieldEnd()
        if self.port_map is not None:
            oprot.writeFieldBegin('port_map', TType.STRING, 4)
            oprot.writeBinary(self.port_map)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_update_port_prune_table_args)
mc_update_port_prune_table_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'yid', None, None, ),  # 3
    (4, TType.STRING, 'port_map', 'BINARY', None, ),  # 4
)


class mc_update_port_prune_table_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_update_port_prune_table_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_update_port_prune_table_result)
mc_update_port_prune_table_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_get_port_prune_table_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - yid
     - from_hw

    """


    def __init__(self, sess_hdl=None, dev_id=None, yid=None, from_hw=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.yid = yid
        self.from_hw = from_hw

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.yid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.from_hw = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_port_prune_table_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.yid is not None:
            oprot.writeFieldBegin('yid', TType.I16, 3)
            oprot.writeI16(self.yid)
            oprot.writeFieldEnd()
        if self.from_hw is not None:
            oprot.writeFieldBegin('from_hw', TType.BOOL, 4)
            oprot.writeBool(self.from_hw)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_port_prune_table_args)
mc_get_port_prune_table_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'yid', None, None, ),  # 3
    (4, TType.BOOL, 'from_hw', None, None, ),  # 4
)


class mc_get_port_prune_table_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_port_prune_table_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_port_prune_table_result)
mc_get_port_prune_table_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_global_rid_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - rid

    """


    def __init__(self, sess_hdl=None, dev_id=None, rid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.rid = rid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.rid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_global_rid_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.rid is not None:
            oprot.writeFieldBegin('rid', TType.I16, 3)
            oprot.writeI16(self.rid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_global_rid_args)
mc_set_global_rid_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'rid', None, None, ),  # 3
)


class mc_set_global_rid_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_global_rid_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_global_rid_result)
mc_set_global_rid_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_port_mc_fwd_state_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - port
     - is_active

    """


    def __init__(self, sess_hdl=None, dev_id=None, port=None, is_active=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.port = port
        self.is_active = is_active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.is_active = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_port_mc_fwd_state_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I16, 3)
            oprot.writeI16(self.port)
            oprot.writeFieldEnd()
        if self.is_active is not None:
            oprot.writeFieldBegin('is_active', TType.BYTE, 4)
            oprot.writeByte(self.is_active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_port_mc_fwd_state_args)
mc_set_port_mc_fwd_state_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'port', None, None, ),  # 3
    (4, TType.BYTE, 'is_active', None, None, ),  # 4
)


class mc_set_port_mc_fwd_state_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_port_mc_fwd_state_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_port_mc_fwd_state_result)
mc_set_port_mc_fwd_state_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_enable_port_ff_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_enable_port_ff_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_enable_port_ff_args)
mc_enable_port_ff_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_enable_port_ff_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_enable_port_ff_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_enable_port_ff_result)
mc_enable_port_ff_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_disable_port_ff_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_disable_port_ff_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_disable_port_ff_args)
mc_disable_port_ff_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_disable_port_ff_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_disable_port_ff_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_disable_port_ff_result)
mc_disable_port_ff_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_clr_port_ff_state_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - port

    """


    def __init__(self, sess_hdl=None, dev_id=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.port = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_clr_port_ff_state_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I16, 3)
            oprot.writeI16(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_clr_port_ff_state_args)
mc_clr_port_ff_state_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'port', None, None, ),  # 3
)


class mc_clr_port_ff_state_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_clr_port_ff_state_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_clr_port_ff_state_result)
mc_clr_port_ff_state_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_enable_port_protection_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_enable_port_protection_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_enable_port_protection_args)
mc_enable_port_protection_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_enable_port_protection_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_enable_port_protection_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_enable_port_protection_result)
mc_enable_port_protection_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_disable_port_protection_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id

    """


    def __init__(self, sess_hdl=None, dev_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_disable_port_protection_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_disable_port_protection_args)
mc_disable_port_protection_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
)


class mc_disable_port_protection_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_disable_port_protection_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_disable_port_protection_result)
mc_disable_port_protection_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_port_protection_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - pport
     - bport

    """


    def __init__(self, sess_hdl=None, dev_id=None, pport=None, bport=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.pport = pport
        self.bport = bport

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.pport = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.bport = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_port_protection_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.pport is not None:
            oprot.writeFieldBegin('pport', TType.I16, 3)
            oprot.writeI16(self.pport)
            oprot.writeFieldEnd()
        if self.bport is not None:
            oprot.writeFieldBegin('bport', TType.I16, 4)
            oprot.writeI16(self.bport)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_port_protection_args)
mc_set_port_protection_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'pport', None, None, ),  # 3
    (4, TType.I16, 'bport', None, None, ),  # 4
)


class mc_set_port_protection_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_port_protection_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_port_protection_result)
mc_set_port_protection_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_clear_port_protection_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - pport

    """


    def __init__(self, sess_hdl=None, dev_id=None, pport=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.pport = pport

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.pport = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_clear_port_protection_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.pport is not None:
            oprot.writeFieldBegin('pport', TType.I16, 3)
            oprot.writeI16(self.pport)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_clear_port_protection_args)
mc_clear_port_protection_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'pport', None, None, ),  # 3
)


class mc_clear_port_protection_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_clear_port_protection_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_clear_port_protection_result)
mc_clear_port_protection_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_max_nodes_before_yield_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - count

    """


    def __init__(self, sess_hdl=None, dev_id=None, count=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_max_nodes_before_yield_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 3)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_max_nodes_before_yield_args)
mc_set_max_nodes_before_yield_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
)


class mc_set_max_nodes_before_yield_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_max_nodes_before_yield_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_max_nodes_before_yield_result)
mc_set_max_nodes_before_yield_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_set_max_node_threshold_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - node_count
     - lag_count

    """


    def __init__(self, sess_hdl=None, dev_id=None, node_count=None, lag_count=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.node_count = node_count
        self.lag_count = lag_count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.node_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.lag_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_max_node_threshold_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.node_count is not None:
            oprot.writeFieldBegin('node_count', TType.I32, 3)
            oprot.writeI32(self.node_count)
            oprot.writeFieldEnd()
        if self.lag_count is not None:
            oprot.writeFieldBegin('lag_count', TType.I32, 4)
            oprot.writeI32(self.lag_count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_max_node_threshold_args)
mc_set_max_node_threshold_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I32, 'node_count', None, None, ),  # 3
    (4, TType.I32, 'lag_count', None, None, ),  # 4
)


class mc_set_max_node_threshold_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_set_max_node_threshold_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_set_max_node_threshold_result)
mc_set_max_node_threshold_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)


class mc_get_pipe_vec_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_id
     - mgid

    """


    def __init__(self, sess_hdl=None, dev_id=None, mgid=None,):
        self.sess_hdl = sess_hdl
        self.dev_id = dev_id
        self.mgid = mgid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.mgid = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_pipe_vec_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_id is not None:
            oprot.writeFieldBegin('dev_id', TType.I32, 2)
            oprot.writeI32(self.dev_id)
            oprot.writeFieldEnd()
        if self.mgid is not None:
            oprot.writeFieldBegin('mgid', TType.I16, 3)
            oprot.writeI16(self.mgid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_pipe_vec_args)
mc_get_pipe_vec_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev_id', None, None, ),  # 2
    (3, TType.I16, 'mgid', None, None, ),  # 3
)


class mc_get_pipe_vec_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidMcOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('mc_get_pipe_vec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(mc_get_pipe_vec_result)
mc_get_pipe_vec_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidMcOperation, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
