#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import controller.thrift_api.res_pd_rpc.ttypes

from thrift.transport import TTransport
all_structs = []


class PktGenTriggerType_t(object):
    TIMER_ONE_SHOT = 0
    TIMER_PERIODIC = 1
    PORT_DOWN = 2
    RECIRC_PATTERN = 3
    DPRSR = 4
    PFC = 5

    _VALUES_TO_NAMES = {
        0: "TIMER_ONE_SHOT",
        1: "TIMER_PERIODIC",
        2: "PORT_DOWN",
        3: "RECIRC_PATTERN",
        4: "DPRSR",
        5: "PFC",
    }

    _NAMES_TO_VALUES = {
        "TIMER_ONE_SHOT": 0,
        "TIMER_PERIODIC": 1,
        "PORT_DOWN": 2,
        "RECIRC_PATTERN": 3,
        "DPRSR": 4,
        "PFC": 5,
    }


class PktGenPortDownReplay_t(object):
    REPLAY_NONE = 0
    REPLAY_ALL = 1
    REPLAY_MISSED = 2

    _VALUES_TO_NAMES = {
        0: "REPLAY_NONE",
        1: "REPLAY_ALL",
        2: "REPLAY_MISSED",
    }

    _NAMES_TO_VALUES = {
        "REPLAY_NONE": 0,
        "REPLAY_ALL": 1,
        "REPLAY_MISSED": 2,
    }


class PktGenAppCfg_t(object):
    """
    Attributes:
     - trigger_type
     - batch_count
     - pkt_count
     - pattern_key
     - pattern_msk
     - timer
     - ibg
     - ibg_jitter
     - ipg
     - ipg_jitter
     - src_port
     - src_port_inc
     - buffer_offset
     - length

    """


    def __init__(self, trigger_type=None, batch_count=None, pkt_count=None, pattern_key=None, pattern_msk=None, timer=None, ibg=None, ibg_jitter=None, ipg=None, ipg_jitter=None, src_port=None, src_port_inc=None, buffer_offset=None, length=None,):
        self.trigger_type = trigger_type
        self.batch_count = batch_count
        self.pkt_count = pkt_count
        self.pattern_key = pattern_key
        self.pattern_msk = pattern_msk
        self.timer = timer
        self.ibg = ibg
        self.ibg_jitter = ibg_jitter
        self.ipg = ipg
        self.ipg_jitter = ipg_jitter
        self.src_port = src_port
        self.src_port_inc = src_port_inc
        self.buffer_offset = buffer_offset
        self.length = length

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.trigger_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.batch_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pkt_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.pattern_key = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.pattern_msk = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.timer = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.ibg = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.ibg_jitter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.ipg = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.ipg_jitter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.src_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.src_port_inc = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.buffer_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PktGenAppCfg_t')
        if self.trigger_type is not None:
            oprot.writeFieldBegin('trigger_type', TType.I32, 1)
            oprot.writeI32(self.trigger_type)
            oprot.writeFieldEnd()
        if self.batch_count is not None:
            oprot.writeFieldBegin('batch_count', TType.I32, 2)
            oprot.writeI32(self.batch_count)
            oprot.writeFieldEnd()
        if self.pkt_count is not None:
            oprot.writeFieldBegin('pkt_count', TType.I32, 3)
            oprot.writeI32(self.pkt_count)
            oprot.writeFieldEnd()
        if self.pattern_key is not None:
            oprot.writeFieldBegin('pattern_key', TType.I32, 4)
            oprot.writeI32(self.pattern_key)
            oprot.writeFieldEnd()
        if self.pattern_msk is not None:
            oprot.writeFieldBegin('pattern_msk', TType.I32, 5)
            oprot.writeI32(self.pattern_msk)
            oprot.writeFieldEnd()
        if self.timer is not None:
            oprot.writeFieldBegin('timer', TType.I32, 6)
            oprot.writeI32(self.timer)
            oprot.writeFieldEnd()
        if self.ibg is not None:
            oprot.writeFieldBegin('ibg', TType.I32, 7)
            oprot.writeI32(self.ibg)
            oprot.writeFieldEnd()
        if self.ibg_jitter is not None:
            oprot.writeFieldBegin('ibg_jitter', TType.I32, 8)
            oprot.writeI32(self.ibg_jitter)
            oprot.writeFieldEnd()
        if self.ipg is not None:
            oprot.writeFieldBegin('ipg', TType.I32, 9)
            oprot.writeI32(self.ipg)
            oprot.writeFieldEnd()
        if self.ipg_jitter is not None:
            oprot.writeFieldBegin('ipg_jitter', TType.I32, 10)
            oprot.writeI32(self.ipg_jitter)
            oprot.writeFieldEnd()
        if self.src_port is not None:
            oprot.writeFieldBegin('src_port', TType.I32, 11)
            oprot.writeI32(self.src_port)
            oprot.writeFieldEnd()
        if self.src_port_inc is not None:
            oprot.writeFieldBegin('src_port_inc', TType.I32, 12)
            oprot.writeI32(self.src_port_inc)
            oprot.writeFieldEnd()
        if self.buffer_offset is not None:
            oprot.writeFieldBegin('buffer_offset', TType.I32, 13)
            oprot.writeI32(self.buffer_offset)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 14)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.trigger_type is None:
            raise TProtocolException(message='Required field trigger_type is unset!')
        if self.length is None:
            raise TProtocolException(message='Required field length is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PktGenAppCfg_tof2_t(object):
    """
    Attributes:
     - trigger_type
     - batch_count
     - pkt_count
     - pattern_key
     - pattern_msk
     - pfc_hdr
     - pfc_timer_en
     - pfc_timer
     - pfc_max_msgs
     - timer
     - ibg
     - ibg_jitter
     - ipg
     - ipg_jitter
     - src_port
     - src_port_inc
     - buffer_offset
     - length
     - port_mask_sel
     - source_port_wrap_max
     - assigned_chnl_id
     - offset_len_from_recir_pkt

    """


    def __init__(self, trigger_type=None, batch_count=None, pkt_count=None, pattern_key=None, pattern_msk=None, pfc_hdr=None, pfc_timer_en=None, pfc_timer=None, pfc_max_msgs=None, timer=None, ibg=None, ibg_jitter=None, ipg=None, ipg_jitter=None, src_port=None, src_port_inc=None, buffer_offset=None, length=None, port_mask_sel=None, source_port_wrap_max=None, assigned_chnl_id=None, offset_len_from_recir_pkt=None,):
        self.trigger_type = trigger_type
        self.batch_count = batch_count
        self.pkt_count = pkt_count
        self.pattern_key = pattern_key
        self.pattern_msk = pattern_msk
        self.pfc_hdr = pfc_hdr
        self.pfc_timer_en = pfc_timer_en
        self.pfc_timer = pfc_timer
        self.pfc_max_msgs = pfc_max_msgs
        self.timer = timer
        self.ibg = ibg
        self.ibg_jitter = ibg_jitter
        self.ipg = ipg
        self.ipg_jitter = ipg_jitter
        self.src_port = src_port
        self.src_port_inc = src_port_inc
        self.buffer_offset = buffer_offset
        self.length = length
        self.port_mask_sel = port_mask_sel
        self.source_port_wrap_max = source_port_wrap_max
        self.assigned_chnl_id = assigned_chnl_id
        self.offset_len_from_recir_pkt = offset_len_from_recir_pkt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.trigger_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.batch_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pkt_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.pattern_key = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readByte()
                        self.pattern_key.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.pattern_msk = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readByte()
                        self.pattern_msk.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.pfc_hdr = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readByte()
                        self.pfc_hdr.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.pfc_timer_en = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I16:
                    self.pfc_timer = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I16:
                    self.pfc_max_msgs = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.timer = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.ibg = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.ibg_jitter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.ipg = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.ipg_jitter = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.src_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.src_port_inc = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.buffer_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.length = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I16:
                    self.port_mask_sel = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I16:
                    self.source_port_wrap_max = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I16:
                    self.assigned_chnl_id = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.BOOL:
                    self.offset_len_from_recir_pkt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PktGenAppCfg_tof2_t')
        if self.trigger_type is not None:
            oprot.writeFieldBegin('trigger_type', TType.I32, 1)
            oprot.writeI32(self.trigger_type)
            oprot.writeFieldEnd()
        if self.batch_count is not None:
            oprot.writeFieldBegin('batch_count', TType.I32, 2)
            oprot.writeI32(self.batch_count)
            oprot.writeFieldEnd()
        if self.pkt_count is not None:
            oprot.writeFieldBegin('pkt_count', TType.I32, 3)
            oprot.writeI32(self.pkt_count)
            oprot.writeFieldEnd()
        if self.pattern_key is not None:
            oprot.writeFieldBegin('pattern_key', TType.LIST, 4)
            oprot.writeListBegin(TType.BYTE, len(self.pattern_key))
            for iter18 in self.pattern_key:
                oprot.writeByte(iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pattern_msk is not None:
            oprot.writeFieldBegin('pattern_msk', TType.LIST, 5)
            oprot.writeListBegin(TType.BYTE, len(self.pattern_msk))
            for iter19 in self.pattern_msk:
                oprot.writeByte(iter19)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pfc_hdr is not None:
            oprot.writeFieldBegin('pfc_hdr', TType.LIST, 6)
            oprot.writeListBegin(TType.BYTE, len(self.pfc_hdr))
            for iter20 in self.pfc_hdr:
                oprot.writeByte(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pfc_timer_en is not None:
            oprot.writeFieldBegin('pfc_timer_en', TType.BOOL, 7)
            oprot.writeBool(self.pfc_timer_en)
            oprot.writeFieldEnd()
        if self.pfc_timer is not None:
            oprot.writeFieldBegin('pfc_timer', TType.I16, 8)
            oprot.writeI16(self.pfc_timer)
            oprot.writeFieldEnd()
        if self.pfc_max_msgs is not None:
            oprot.writeFieldBegin('pfc_max_msgs', TType.I16, 9)
            oprot.writeI16(self.pfc_max_msgs)
            oprot.writeFieldEnd()
        if self.timer is not None:
            oprot.writeFieldBegin('timer', TType.I32, 10)
            oprot.writeI32(self.timer)
            oprot.writeFieldEnd()
        if self.ibg is not None:
            oprot.writeFieldBegin('ibg', TType.I32, 11)
            oprot.writeI32(self.ibg)
            oprot.writeFieldEnd()
        if self.ibg_jitter is not None:
            oprot.writeFieldBegin('ibg_jitter', TType.I32, 12)
            oprot.writeI32(self.ibg_jitter)
            oprot.writeFieldEnd()
        if self.ipg is not None:
            oprot.writeFieldBegin('ipg', TType.I32, 13)
            oprot.writeI32(self.ipg)
            oprot.writeFieldEnd()
        if self.ipg_jitter is not None:
            oprot.writeFieldBegin('ipg_jitter', TType.I32, 14)
            oprot.writeI32(self.ipg_jitter)
            oprot.writeFieldEnd()
        if self.src_port is not None:
            oprot.writeFieldBegin('src_port', TType.I32, 15)
            oprot.writeI32(self.src_port)
            oprot.writeFieldEnd()
        if self.src_port_inc is not None:
            oprot.writeFieldBegin('src_port_inc', TType.I32, 16)
            oprot.writeI32(self.src_port_inc)
            oprot.writeFieldEnd()
        if self.buffer_offset is not None:
            oprot.writeFieldBegin('buffer_offset', TType.I32, 17)
            oprot.writeI32(self.buffer_offset)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I32, 18)
            oprot.writeI32(self.length)
            oprot.writeFieldEnd()
        if self.port_mask_sel is not None:
            oprot.writeFieldBegin('port_mask_sel', TType.I16, 19)
            oprot.writeI16(self.port_mask_sel)
            oprot.writeFieldEnd()
        if self.source_port_wrap_max is not None:
            oprot.writeFieldBegin('source_port_wrap_max', TType.I16, 20)
            oprot.writeI16(self.source_port_wrap_max)
            oprot.writeFieldEnd()
        if self.assigned_chnl_id is not None:
            oprot.writeFieldBegin('assigned_chnl_id', TType.I16, 21)
            oprot.writeI16(self.assigned_chnl_id)
            oprot.writeFieldEnd()
        if self.offset_len_from_recir_pkt is not None:
            oprot.writeFieldBegin('offset_len_from_recir_pkt', TType.BOOL, 22)
            oprot.writeBool(self.offset_len_from_recir_pkt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.trigger_type is None:
            raise TProtocolException(message='Required field trigger_type is unset!')
        if self.length is None:
            raise TProtocolException(message='Required field length is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PortMask_t(object):
    """
    Attributes:
     - mask

    """


    def __init__(self, mask=None,):
        self.mask = mask

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.mask = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readByte()
                        self.mask.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PortMask_t')
        if self.mask is not None:
            oprot.writeFieldBegin('mask', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.mask))
            for iter27 in self.mask:
                oprot.writeByte(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class indirect_reg_data_t(object):
    """
    Attributes:
     - hi
     - lo

    """


    def __init__(self, hi=None, lo=None,):
        self.hi = hi
        self.lo = lo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.hi = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.lo = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('indirect_reg_data_t')
        if self.hi is not None:
            oprot.writeFieldBegin('hi', TType.I64, 1)
            oprot.writeI64(self.hi)
            oprot.writeFieldEnd()
        if self.lo is not None:
            oprot.writeFieldBegin('lo', TType.I64, 2)
            oprot.writeI64(self.lo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hi is None:
            raise TProtocolException(message='Required field hi is unset!')
        if self.lo is None:
            raise TProtocolException(message='Required field lo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidConnMgrOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidConnMgrOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidConnMgrOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidPktGenOperation(TException):
    """
    Attributes:
     - code

    """


    def __init__(self, code=None,):
        super(InvalidPktGenOperation, self).__setattr__('code', code)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidPktGenOperation')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PktGenAppCfg_t)
PktGenAppCfg_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'trigger_type', None, None, ),  # 1
    (2, TType.I32, 'batch_count', None, None, ),  # 2
    (3, TType.I32, 'pkt_count', None, None, ),  # 3
    (4, TType.I32, 'pattern_key', None, None, ),  # 4
    (5, TType.I32, 'pattern_msk', None, None, ),  # 5
    (6, TType.I32, 'timer', None, None, ),  # 6
    (7, TType.I32, 'ibg', None, None, ),  # 7
    (8, TType.I32, 'ibg_jitter', None, None, ),  # 8
    (9, TType.I32, 'ipg', None, None, ),  # 9
    (10, TType.I32, 'ipg_jitter', None, None, ),  # 10
    (11, TType.I32, 'src_port', None, None, ),  # 11
    (12, TType.I32, 'src_port_inc', None, None, ),  # 12
    (13, TType.I32, 'buffer_offset', None, None, ),  # 13
    (14, TType.I32, 'length', None, None, ),  # 14
)
all_structs.append(PktGenAppCfg_tof2_t)
PktGenAppCfg_tof2_t.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'trigger_type', None, None, ),  # 1
    (2, TType.I32, 'batch_count', None, None, ),  # 2
    (3, TType.I32, 'pkt_count', None, None, ),  # 3
    (4, TType.LIST, 'pattern_key', (TType.BYTE, None, False), None, ),  # 4
    (5, TType.LIST, 'pattern_msk', (TType.BYTE, None, False), None, ),  # 5
    (6, TType.LIST, 'pfc_hdr', (TType.BYTE, None, False), None, ),  # 6
    (7, TType.BOOL, 'pfc_timer_en', None, None, ),  # 7
    (8, TType.I16, 'pfc_timer', None, None, ),  # 8
    (9, TType.I16, 'pfc_max_msgs', None, None, ),  # 9
    (10, TType.I32, 'timer', None, None, ),  # 10
    (11, TType.I32, 'ibg', None, None, ),  # 11
    (12, TType.I32, 'ibg_jitter', None, None, ),  # 12
    (13, TType.I32, 'ipg', None, None, ),  # 13
    (14, TType.I32, 'ipg_jitter', None, None, ),  # 14
    (15, TType.I32, 'src_port', None, None, ),  # 15
    (16, TType.I32, 'src_port_inc', None, None, ),  # 16
    (17, TType.I32, 'buffer_offset', None, None, ),  # 17
    (18, TType.I32, 'length', None, None, ),  # 18
    (19, TType.I16, 'port_mask_sel', None, None, ),  # 19
    (20, TType.I16, 'source_port_wrap_max', None, None, ),  # 20
    (21, TType.I16, 'assigned_chnl_id', None, None, ),  # 21
    (22, TType.BOOL, 'offset_len_from_recir_pkt', None, None, ),  # 22
)
all_structs.append(PortMask_t)
PortMask_t.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'mask', (TType.BYTE, None, False), None, ),  # 1
)
all_structs.append(indirect_reg_data_t)
indirect_reg_data_t.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'hi', None, None, ),  # 1
    (2, TType.I64, 'lo', None, None, ),  # 2
)
all_structs.append(InvalidConnMgrOperation)
InvalidConnMgrOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
all_structs.append(InvalidPktGenOperation)
InvalidPktGenOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
)
fix_spec(all_structs)
del all_structs
