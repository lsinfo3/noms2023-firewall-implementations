#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def echo(self, s):
        """
        Parameters:
         - s

        """
        pass

    def init(self):
        pass

    def cleanup(self):
        pass

    def client_init(self):
        pass

    def client_cleanup(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def begin_txn(self, sess_hdl, isAtomic):
        """
        Parameters:
         - sess_hdl
         - isAtomic

        """
        pass

    def verify_txn(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def abort_txn(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def commit_txn(self, sess_hdl, hwSynchronous):
        """
        Parameters:
         - sess_hdl
         - hwSynchronous

        """
        pass

    def complete_operations(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def begin_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def flush_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        pass

    def end_batch(self, sess_hdl, hwSynchronous):
        """
        Parameters:
         - sess_hdl
         - hwSynchronous

        """
        pass

    def log_state(self, device_id, filepath):
        """
        Parameters:
         - device_id
         - filepath

        """
        pass

    def restore_state(self, device_id, filepath):
        """
        Parameters:
         - device_id
         - filepath

        """
        pass

    def advance_model_time(self, sess_hdl, device_id, tick_time):
        """
        Parameters:
         - sess_hdl
         - device_id
         - tick_time

        """
        pass

    def recirculation_enable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def recirculation_disable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def pktgen_enable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def pktgen_disable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def pktgen_enable_recirc_pattern_matching(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def pktgen_disable_recirc_pattern_matching(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def pktgen_clear_port_down(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        pass

    def pktgen_cfg_app(self, sess_hdl, dev_tgt, app_id, cfg):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - cfg

        """
        pass

    def pktgen_cfg_app_tof2(self, sess_hdl, dev_tgt, app_id, cfg):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - cfg

        """
        pass

    def pktgen_cfg_port_mask_tof2(self, sess_hdl, dev_tgt, sel, mask_in):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - sel
         - mask_in

        """
        pass

    def pktgen_app_enable(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        pass

    def pktgen_app_disable(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        pass

    def pktgen_write_pkt_buffer(self, sess_hdl, dev_tgt, offset, size, buf):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - offset
         - size
         - buf

        """
        pass

    def pktgen_get_batch_counter(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        pass

    def pktgen_get_pkt_counter(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        pass

    def pktgen_get_trigger_counter(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        pass

    def pktgen_set_batch_counter(self, sess_hdl, dev_tgt, app_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - count

        """
        pass

    def pktgen_set_pkt_counter(self, sess_hdl, dev_tgt, app_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - count

        """
        pass

    def pktgen_set_trigger_counter(self, sess_hdl, dev_tgt, app_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - count

        """
        pass

    def pktgen_port_down_replay_mode_set(self, sess_hdl, dev_tgt, mode):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - mode

        """
        pass

    def pktgen_port_down_replay_mode_get(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        pass

    def reg_wr(self, dev, addr, data):
        """
        Parameters:
         - dev
         - addr
         - data

        """
        pass

    def reg_rd(self, dev, addr):
        """
        Parameters:
         - dev
         - addr

        """
        pass

    def ind_reg_wr(self, dev, addr, data):
        """
        Parameters:
         - dev
         - addr
         - data

        """
        pass

    def ind_reg_rd(self, dev, addr):
        """
        Parameters:
         - dev
         - addr

        """
        pass

    def tcam_scrub_timer_set(self, dev, msec_timer):
        """
        Parameters:
         - dev
         - msec_timer

        """
        pass

    def tcam_scrub_timer_get(self, dev):
        """
        Parameters:
         - dev

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def echo(self, s):
        """
        Parameters:
         - s

        """
        self.send_echo(s)
        self.recv_echo()

    def send_echo(self, s):
        self._oprot.writeMessageBegin('echo', TMessageType.CALL, self._seqid)
        args = echo_args()
        args.s = s
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_echo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = echo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def init(self):
        self.send_init()
        self.recv_init()

    def send_init(self):
        self._oprot.writeMessageBegin('init', TMessageType.CALL, self._seqid)
        args = init_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_init(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = init_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def cleanup(self):
        self.send_cleanup()
        self.recv_cleanup()

    def send_cleanup(self):
        self._oprot.writeMessageBegin('cleanup', TMessageType.CALL, self._seqid)
        args = cleanup_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cleanup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cleanup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def client_init(self):
        self.send_client_init()
        return self.recv_client_init()

    def send_client_init(self):
        self._oprot.writeMessageBegin('client_init', TMessageType.CALL, self._seqid)
        args = client_init_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_client_init(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = client_init_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "client_init failed: unknown result")

    def client_cleanup(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_client_cleanup(sess_hdl)
        self.recv_client_cleanup()

    def send_client_cleanup(self, sess_hdl):
        self._oprot.writeMessageBegin('client_cleanup', TMessageType.CALL, self._seqid)
        args = client_cleanup_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_client_cleanup(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = client_cleanup_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def begin_txn(self, sess_hdl, isAtomic):
        """
        Parameters:
         - sess_hdl
         - isAtomic

        """
        self.send_begin_txn(sess_hdl, isAtomic)
        self.recv_begin_txn()

    def send_begin_txn(self, sess_hdl, isAtomic):
        self._oprot.writeMessageBegin('begin_txn', TMessageType.CALL, self._seqid)
        args = begin_txn_args()
        args.sess_hdl = sess_hdl
        args.isAtomic = isAtomic
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_begin_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = begin_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def verify_txn(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_verify_txn(sess_hdl)
        self.recv_verify_txn()

    def send_verify_txn(self, sess_hdl):
        self._oprot.writeMessageBegin('verify_txn', TMessageType.CALL, self._seqid)
        args = verify_txn_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verify_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verify_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def abort_txn(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_abort_txn(sess_hdl)
        self.recv_abort_txn()

    def send_abort_txn(self, sess_hdl):
        self._oprot.writeMessageBegin('abort_txn', TMessageType.CALL, self._seqid)
        args = abort_txn_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def commit_txn(self, sess_hdl, hwSynchronous):
        """
        Parameters:
         - sess_hdl
         - hwSynchronous

        """
        self.send_commit_txn(sess_hdl, hwSynchronous)
        self.recv_commit_txn()

    def send_commit_txn(self, sess_hdl, hwSynchronous):
        self._oprot.writeMessageBegin('commit_txn', TMessageType.CALL, self._seqid)
        args = commit_txn_args()
        args.sess_hdl = sess_hdl
        args.hwSynchronous = hwSynchronous
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def complete_operations(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_complete_operations(sess_hdl)
        self.recv_complete_operations()

    def send_complete_operations(self, sess_hdl):
        self._oprot.writeMessageBegin('complete_operations', TMessageType.CALL, self._seqid)
        args = complete_operations_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_complete_operations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = complete_operations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def begin_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_begin_batch(sess_hdl)
        self.recv_begin_batch()

    def send_begin_batch(self, sess_hdl):
        self._oprot.writeMessageBegin('begin_batch', TMessageType.CALL, self._seqid)
        args = begin_batch_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_begin_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = begin_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def flush_batch(self, sess_hdl):
        """
        Parameters:
         - sess_hdl

        """
        self.send_flush_batch(sess_hdl)
        self.recv_flush_batch()

    def send_flush_batch(self, sess_hdl):
        self._oprot.writeMessageBegin('flush_batch', TMessageType.CALL, self._seqid)
        args = flush_batch_args()
        args.sess_hdl = sess_hdl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_flush_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = flush_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def end_batch(self, sess_hdl, hwSynchronous):
        """
        Parameters:
         - sess_hdl
         - hwSynchronous

        """
        self.send_end_batch(sess_hdl, hwSynchronous)
        self.recv_end_batch()

    def send_end_batch(self, sess_hdl, hwSynchronous):
        self._oprot.writeMessageBegin('end_batch', TMessageType.CALL, self._seqid)
        args = end_batch_args()
        args.sess_hdl = sess_hdl
        args.hwSynchronous = hwSynchronous
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_end_batch(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = end_batch_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def log_state(self, device_id, filepath):
        """
        Parameters:
         - device_id
         - filepath

        """
        self.send_log_state(device_id, filepath)
        self.recv_log_state()

    def send_log_state(self, device_id, filepath):
        self._oprot.writeMessageBegin('log_state', TMessageType.CALL, self._seqid)
        args = log_state_args()
        args.device_id = device_id
        args.filepath = filepath
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_log_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = log_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def restore_state(self, device_id, filepath):
        """
        Parameters:
         - device_id
         - filepath

        """
        self.send_restore_state(device_id, filepath)
        self.recv_restore_state()

    def send_restore_state(self, device_id, filepath):
        self._oprot.writeMessageBegin('restore_state', TMessageType.CALL, self._seqid)
        args = restore_state_args()
        args.device_id = device_id
        args.filepath = filepath
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restore_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restore_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def advance_model_time(self, sess_hdl, device_id, tick_time):
        """
        Parameters:
         - sess_hdl
         - device_id
         - tick_time

        """
        self.send_advance_model_time(sess_hdl, device_id, tick_time)
        self.recv_advance_model_time()

    def send_advance_model_time(self, sess_hdl, device_id, tick_time):
        self._oprot.writeMessageBegin('advance_model_time', TMessageType.CALL, self._seqid)
        args = advance_model_time_args()
        args.sess_hdl = sess_hdl
        args.device_id = device_id
        args.tick_time = tick_time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_advance_model_time(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = advance_model_time_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def recirculation_enable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_recirculation_enable(sess_hdl, dev, port)
        self.recv_recirculation_enable()

    def send_recirculation_enable(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('recirculation_enable', TMessageType.CALL, self._seqid)
        args = recirculation_enable_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_recirculation_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = recirculation_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def recirculation_disable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_recirculation_disable(sess_hdl, dev, port)
        self.recv_recirculation_disable()

    def send_recirculation_disable(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('recirculation_disable', TMessageType.CALL, self._seqid)
        args = recirculation_disable_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_recirculation_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = recirculation_disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_enable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_pktgen_enable(sess_hdl, dev, port)
        self.recv_pktgen_enable()

    def send_pktgen_enable(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('pktgen_enable', TMessageType.CALL, self._seqid)
        args = pktgen_enable_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_disable(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_pktgen_disable(sess_hdl, dev, port)
        self.recv_pktgen_disable()

    def send_pktgen_disable(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('pktgen_disable', TMessageType.CALL, self._seqid)
        args = pktgen_disable_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_enable_recirc_pattern_matching(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_pktgen_enable_recirc_pattern_matching(sess_hdl, dev, port)
        self.recv_pktgen_enable_recirc_pattern_matching()

    def send_pktgen_enable_recirc_pattern_matching(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('pktgen_enable_recirc_pattern_matching', TMessageType.CALL, self._seqid)
        args = pktgen_enable_recirc_pattern_matching_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_enable_recirc_pattern_matching(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_enable_recirc_pattern_matching_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_disable_recirc_pattern_matching(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_pktgen_disable_recirc_pattern_matching(sess_hdl, dev, port)
        self.recv_pktgen_disable_recirc_pattern_matching()

    def send_pktgen_disable_recirc_pattern_matching(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('pktgen_disable_recirc_pattern_matching', TMessageType.CALL, self._seqid)
        args = pktgen_disable_recirc_pattern_matching_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_disable_recirc_pattern_matching(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_disable_recirc_pattern_matching_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_clear_port_down(self, sess_hdl, dev, port):
        """
        Parameters:
         - sess_hdl
         - dev
         - port

        """
        self.send_pktgen_clear_port_down(sess_hdl, dev, port)
        self.recv_pktgen_clear_port_down()

    def send_pktgen_clear_port_down(self, sess_hdl, dev, port):
        self._oprot.writeMessageBegin('pktgen_clear_port_down', TMessageType.CALL, self._seqid)
        args = pktgen_clear_port_down_args()
        args.sess_hdl = sess_hdl
        args.dev = dev
        args.port = port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_clear_port_down(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_clear_port_down_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_cfg_app(self, sess_hdl, dev_tgt, app_id, cfg):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - cfg

        """
        self.send_pktgen_cfg_app(sess_hdl, dev_tgt, app_id, cfg)
        self.recv_pktgen_cfg_app()

    def send_pktgen_cfg_app(self, sess_hdl, dev_tgt, app_id, cfg):
        self._oprot.writeMessageBegin('pktgen_cfg_app', TMessageType.CALL, self._seqid)
        args = pktgen_cfg_app_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.cfg = cfg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_cfg_app(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_cfg_app_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_cfg_app_tof2(self, sess_hdl, dev_tgt, app_id, cfg):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - cfg

        """
        self.send_pktgen_cfg_app_tof2(sess_hdl, dev_tgt, app_id, cfg)
        self.recv_pktgen_cfg_app_tof2()

    def send_pktgen_cfg_app_tof2(self, sess_hdl, dev_tgt, app_id, cfg):
        self._oprot.writeMessageBegin('pktgen_cfg_app_tof2', TMessageType.CALL, self._seqid)
        args = pktgen_cfg_app_tof2_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.cfg = cfg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_cfg_app_tof2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_cfg_app_tof2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_cfg_port_mask_tof2(self, sess_hdl, dev_tgt, sel, mask_in):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - sel
         - mask_in

        """
        self.send_pktgen_cfg_port_mask_tof2(sess_hdl, dev_tgt, sel, mask_in)
        self.recv_pktgen_cfg_port_mask_tof2()

    def send_pktgen_cfg_port_mask_tof2(self, sess_hdl, dev_tgt, sel, mask_in):
        self._oprot.writeMessageBegin('pktgen_cfg_port_mask_tof2', TMessageType.CALL, self._seqid)
        args = pktgen_cfg_port_mask_tof2_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.sel = sel
        args.mask_in = mask_in
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_cfg_port_mask_tof2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_cfg_port_mask_tof2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_app_enable(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        self.send_pktgen_app_enable(sess_hdl, dev_tgt, app_id)
        self.recv_pktgen_app_enable()

    def send_pktgen_app_enable(self, sess_hdl, dev_tgt, app_id):
        self._oprot.writeMessageBegin('pktgen_app_enable', TMessageType.CALL, self._seqid)
        args = pktgen_app_enable_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_app_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_app_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_app_disable(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        self.send_pktgen_app_disable(sess_hdl, dev_tgt, app_id)
        self.recv_pktgen_app_disable()

    def send_pktgen_app_disable(self, sess_hdl, dev_tgt, app_id):
        self._oprot.writeMessageBegin('pktgen_app_disable', TMessageType.CALL, self._seqid)
        args = pktgen_app_disable_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_app_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_app_disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_write_pkt_buffer(self, sess_hdl, dev_tgt, offset, size, buf):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - offset
         - size
         - buf

        """
        self.send_pktgen_write_pkt_buffer(sess_hdl, dev_tgt, offset, size, buf)
        self.recv_pktgen_write_pkt_buffer()

    def send_pktgen_write_pkt_buffer(self, sess_hdl, dev_tgt, offset, size, buf):
        self._oprot.writeMessageBegin('pktgen_write_pkt_buffer', TMessageType.CALL, self._seqid)
        args = pktgen_write_pkt_buffer_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.offset = offset
        args.size = size
        args.buf = buf
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_write_pkt_buffer(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_write_pkt_buffer_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_get_batch_counter(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        self.send_pktgen_get_batch_counter(sess_hdl, dev_tgt, app_id)
        return self.recv_pktgen_get_batch_counter()

    def send_pktgen_get_batch_counter(self, sess_hdl, dev_tgt, app_id):
        self._oprot.writeMessageBegin('pktgen_get_batch_counter', TMessageType.CALL, self._seqid)
        args = pktgen_get_batch_counter_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_get_batch_counter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_get_batch_counter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pktgen_get_batch_counter failed: unknown result")

    def pktgen_get_pkt_counter(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        self.send_pktgen_get_pkt_counter(sess_hdl, dev_tgt, app_id)
        return self.recv_pktgen_get_pkt_counter()

    def send_pktgen_get_pkt_counter(self, sess_hdl, dev_tgt, app_id):
        self._oprot.writeMessageBegin('pktgen_get_pkt_counter', TMessageType.CALL, self._seqid)
        args = pktgen_get_pkt_counter_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_get_pkt_counter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_get_pkt_counter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pktgen_get_pkt_counter failed: unknown result")

    def pktgen_get_trigger_counter(self, sess_hdl, dev_tgt, app_id):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id

        """
        self.send_pktgen_get_trigger_counter(sess_hdl, dev_tgt, app_id)
        return self.recv_pktgen_get_trigger_counter()

    def send_pktgen_get_trigger_counter(self, sess_hdl, dev_tgt, app_id):
        self._oprot.writeMessageBegin('pktgen_get_trigger_counter', TMessageType.CALL, self._seqid)
        args = pktgen_get_trigger_counter_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_get_trigger_counter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_get_trigger_counter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pktgen_get_trigger_counter failed: unknown result")

    def pktgen_set_batch_counter(self, sess_hdl, dev_tgt, app_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - count

        """
        self.send_pktgen_set_batch_counter(sess_hdl, dev_tgt, app_id, count)
        self.recv_pktgen_set_batch_counter()

    def send_pktgen_set_batch_counter(self, sess_hdl, dev_tgt, app_id, count):
        self._oprot.writeMessageBegin('pktgen_set_batch_counter', TMessageType.CALL, self._seqid)
        args = pktgen_set_batch_counter_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_set_batch_counter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_set_batch_counter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_set_pkt_counter(self, sess_hdl, dev_tgt, app_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - count

        """
        self.send_pktgen_set_pkt_counter(sess_hdl, dev_tgt, app_id, count)
        self.recv_pktgen_set_pkt_counter()

    def send_pktgen_set_pkt_counter(self, sess_hdl, dev_tgt, app_id, count):
        self._oprot.writeMessageBegin('pktgen_set_pkt_counter', TMessageType.CALL, self._seqid)
        args = pktgen_set_pkt_counter_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_set_pkt_counter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_set_pkt_counter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_set_trigger_counter(self, sess_hdl, dev_tgt, app_id, count):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - app_id
         - count

        """
        self.send_pktgen_set_trigger_counter(sess_hdl, dev_tgt, app_id, count)
        self.recv_pktgen_set_trigger_counter()

    def send_pktgen_set_trigger_counter(self, sess_hdl, dev_tgt, app_id, count):
        self._oprot.writeMessageBegin('pktgen_set_trigger_counter', TMessageType.CALL, self._seqid)
        args = pktgen_set_trigger_counter_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.app_id = app_id
        args.count = count
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_set_trigger_counter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_set_trigger_counter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_port_down_replay_mode_set(self, sess_hdl, dev_tgt, mode):
        """
        Parameters:
         - sess_hdl
         - dev_tgt
         - mode

        """
        self.send_pktgen_port_down_replay_mode_set(sess_hdl, dev_tgt, mode)
        self.recv_pktgen_port_down_replay_mode_set()

    def send_pktgen_port_down_replay_mode_set(self, sess_hdl, dev_tgt, mode):
        self._oprot.writeMessageBegin('pktgen_port_down_replay_mode_set', TMessageType.CALL, self._seqid)
        args = pktgen_port_down_replay_mode_set_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_port_down_replay_mode_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_port_down_replay_mode_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def pktgen_port_down_replay_mode_get(self, sess_hdl, dev_tgt):
        """
        Parameters:
         - sess_hdl
         - dev_tgt

        """
        self.send_pktgen_port_down_replay_mode_get(sess_hdl, dev_tgt)
        return self.recv_pktgen_port_down_replay_mode_get()

    def send_pktgen_port_down_replay_mode_get(self, sess_hdl, dev_tgt):
        self._oprot.writeMessageBegin('pktgen_port_down_replay_mode_get', TMessageType.CALL, self._seqid)
        args = pktgen_port_down_replay_mode_get_args()
        args.sess_hdl = sess_hdl
        args.dev_tgt = dev_tgt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pktgen_port_down_replay_mode_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pktgen_port_down_replay_mode_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pktgen_port_down_replay_mode_get failed: unknown result")

    def reg_wr(self, dev, addr, data):
        """
        Parameters:
         - dev
         - addr
         - data

        """
        self.send_reg_wr(dev, addr, data)
        self.recv_reg_wr()

    def send_reg_wr(self, dev, addr, data):
        self._oprot.writeMessageBegin('reg_wr', TMessageType.CALL, self._seqid)
        args = reg_wr_args()
        args.dev = dev
        args.addr = addr
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reg_wr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reg_wr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def reg_rd(self, dev, addr):
        """
        Parameters:
         - dev
         - addr

        """
        self.send_reg_rd(dev, addr)
        return self.recv_reg_rd()

    def send_reg_rd(self, dev, addr):
        self._oprot.writeMessageBegin('reg_rd', TMessageType.CALL, self._seqid)
        args = reg_rd_args()
        args.dev = dev
        args.addr = addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reg_rd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reg_rd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "reg_rd failed: unknown result")

    def ind_reg_wr(self, dev, addr, data):
        """
        Parameters:
         - dev
         - addr
         - data

        """
        self.send_ind_reg_wr(dev, addr, data)
        self.recv_ind_reg_wr()

    def send_ind_reg_wr(self, dev, addr, data):
        self._oprot.writeMessageBegin('ind_reg_wr', TMessageType.CALL, self._seqid)
        args = ind_reg_wr_args()
        args.dev = dev
        args.addr = addr
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ind_reg_wr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ind_reg_wr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def ind_reg_rd(self, dev, addr):
        """
        Parameters:
         - dev
         - addr

        """
        self.send_ind_reg_rd(dev, addr)
        return self.recv_ind_reg_rd()

    def send_ind_reg_rd(self, dev, addr):
        self._oprot.writeMessageBegin('ind_reg_rd', TMessageType.CALL, self._seqid)
        args = ind_reg_rd_args()
        args.dev = dev
        args.addr = addr
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ind_reg_rd(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ind_reg_rd_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ind_reg_rd failed: unknown result")

    def tcam_scrub_timer_set(self, dev, msec_timer):
        """
        Parameters:
         - dev
         - msec_timer

        """
        self.send_tcam_scrub_timer_set(dev, msec_timer)
        self.recv_tcam_scrub_timer_set()

    def send_tcam_scrub_timer_set(self, dev, msec_timer):
        self._oprot.writeMessageBegin('tcam_scrub_timer_set', TMessageType.CALL, self._seqid)
        args = tcam_scrub_timer_set_args()
        args.dev = dev
        args.msec_timer = msec_timer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tcam_scrub_timer_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tcam_scrub_timer_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.ouch is not None:
            raise result.ouch
        return

    def tcam_scrub_timer_get(self, dev):
        """
        Parameters:
         - dev

        """
        self.send_tcam_scrub_timer_get(dev)
        return self.recv_tcam_scrub_timer_get()

    def send_tcam_scrub_timer_get(self, dev):
        self._oprot.writeMessageBegin('tcam_scrub_timer_get', TMessageType.CALL, self._seqid)
        args = tcam_scrub_timer_get_args()
        args.dev = dev
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tcam_scrub_timer_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tcam_scrub_timer_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tcam_scrub_timer_get failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["echo"] = Processor.process_echo
        self._processMap["init"] = Processor.process_init
        self._processMap["cleanup"] = Processor.process_cleanup
        self._processMap["client_init"] = Processor.process_client_init
        self._processMap["client_cleanup"] = Processor.process_client_cleanup
        self._processMap["begin_txn"] = Processor.process_begin_txn
        self._processMap["verify_txn"] = Processor.process_verify_txn
        self._processMap["abort_txn"] = Processor.process_abort_txn
        self._processMap["commit_txn"] = Processor.process_commit_txn
        self._processMap["complete_operations"] = Processor.process_complete_operations
        self._processMap["begin_batch"] = Processor.process_begin_batch
        self._processMap["flush_batch"] = Processor.process_flush_batch
        self._processMap["end_batch"] = Processor.process_end_batch
        self._processMap["log_state"] = Processor.process_log_state
        self._processMap["restore_state"] = Processor.process_restore_state
        self._processMap["advance_model_time"] = Processor.process_advance_model_time
        self._processMap["recirculation_enable"] = Processor.process_recirculation_enable
        self._processMap["recirculation_disable"] = Processor.process_recirculation_disable
        self._processMap["pktgen_enable"] = Processor.process_pktgen_enable
        self._processMap["pktgen_disable"] = Processor.process_pktgen_disable
        self._processMap["pktgen_enable_recirc_pattern_matching"] = Processor.process_pktgen_enable_recirc_pattern_matching
        self._processMap["pktgen_disable_recirc_pattern_matching"] = Processor.process_pktgen_disable_recirc_pattern_matching
        self._processMap["pktgen_clear_port_down"] = Processor.process_pktgen_clear_port_down
        self._processMap["pktgen_cfg_app"] = Processor.process_pktgen_cfg_app
        self._processMap["pktgen_cfg_app_tof2"] = Processor.process_pktgen_cfg_app_tof2
        self._processMap["pktgen_cfg_port_mask_tof2"] = Processor.process_pktgen_cfg_port_mask_tof2
        self._processMap["pktgen_app_enable"] = Processor.process_pktgen_app_enable
        self._processMap["pktgen_app_disable"] = Processor.process_pktgen_app_disable
        self._processMap["pktgen_write_pkt_buffer"] = Processor.process_pktgen_write_pkt_buffer
        self._processMap["pktgen_get_batch_counter"] = Processor.process_pktgen_get_batch_counter
        self._processMap["pktgen_get_pkt_counter"] = Processor.process_pktgen_get_pkt_counter
        self._processMap["pktgen_get_trigger_counter"] = Processor.process_pktgen_get_trigger_counter
        self._processMap["pktgen_set_batch_counter"] = Processor.process_pktgen_set_batch_counter
        self._processMap["pktgen_set_pkt_counter"] = Processor.process_pktgen_set_pkt_counter
        self._processMap["pktgen_set_trigger_counter"] = Processor.process_pktgen_set_trigger_counter
        self._processMap["pktgen_port_down_replay_mode_set"] = Processor.process_pktgen_port_down_replay_mode_set
        self._processMap["pktgen_port_down_replay_mode_get"] = Processor.process_pktgen_port_down_replay_mode_get
        self._processMap["reg_wr"] = Processor.process_reg_wr
        self._processMap["reg_rd"] = Processor.process_reg_rd
        self._processMap["ind_reg_wr"] = Processor.process_ind_reg_wr
        self._processMap["ind_reg_rd"] = Processor.process_ind_reg_rd
        self._processMap["tcam_scrub_timer_set"] = Processor.process_tcam_scrub_timer_set
        self._processMap["tcam_scrub_timer_get"] = Processor.process_tcam_scrub_timer_get
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_echo(self, seqid, iprot, oprot):
        args = echo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = echo_result()
        try:
            self._handler.echo(args.s)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("echo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_init(self, seqid, iprot, oprot):
        args = init_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = init_result()
        try:
            self._handler.init()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("init", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cleanup(self, seqid, iprot, oprot):
        args = cleanup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cleanup_result()
        try:
            self._handler.cleanup()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cleanup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_client_init(self, seqid, iprot, oprot):
        args = client_init_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = client_init_result()
        try:
            result.success = self._handler.client_init()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("client_init", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_client_cleanup(self, seqid, iprot, oprot):
        args = client_cleanup_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = client_cleanup_result()
        try:
            self._handler.client_cleanup(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("client_cleanup", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_begin_txn(self, seqid, iprot, oprot):
        args = begin_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = begin_txn_result()
        try:
            self._handler.begin_txn(args.sess_hdl, args.isAtomic)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("begin_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_verify_txn(self, seqid, iprot, oprot):
        args = verify_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verify_txn_result()
        try:
            self._handler.verify_txn(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verify_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort_txn(self, seqid, iprot, oprot):
        args = abort_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_txn_result()
        try:
            self._handler.abort_txn(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abort_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_txn(self, seqid, iprot, oprot):
        args = commit_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_txn_result()
        try:
            self._handler.commit_txn(args.sess_hdl, args.hwSynchronous)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_complete_operations(self, seqid, iprot, oprot):
        args = complete_operations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = complete_operations_result()
        try:
            self._handler.complete_operations(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("complete_operations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_begin_batch(self, seqid, iprot, oprot):
        args = begin_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = begin_batch_result()
        try:
            self._handler.begin_batch(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("begin_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_flush_batch(self, seqid, iprot, oprot):
        args = flush_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = flush_batch_result()
        try:
            self._handler.flush_batch(args.sess_hdl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("flush_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_end_batch(self, seqid, iprot, oprot):
        args = end_batch_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = end_batch_result()
        try:
            self._handler.end_batch(args.sess_hdl, args.hwSynchronous)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("end_batch", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_log_state(self, seqid, iprot, oprot):
        args = log_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = log_state_result()
        try:
            self._handler.log_state(args.device_id, args.filepath)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("log_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restore_state(self, seqid, iprot, oprot):
        args = restore_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restore_state_result()
        try:
            self._handler.restore_state(args.device_id, args.filepath)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restore_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_advance_model_time(self, seqid, iprot, oprot):
        args = advance_model_time_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = advance_model_time_result()
        try:
            self._handler.advance_model_time(args.sess_hdl, args.device_id, args.tick_time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("advance_model_time", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_recirculation_enable(self, seqid, iprot, oprot):
        args = recirculation_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = recirculation_enable_result()
        try:
            self._handler.recirculation_enable(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("recirculation_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_recirculation_disable(self, seqid, iprot, oprot):
        args = recirculation_disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = recirculation_disable_result()
        try:
            self._handler.recirculation_disable(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("recirculation_disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_enable(self, seqid, iprot, oprot):
        args = pktgen_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_enable_result()
        try:
            self._handler.pktgen_enable(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_disable(self, seqid, iprot, oprot):
        args = pktgen_disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_disable_result()
        try:
            self._handler.pktgen_disable(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_enable_recirc_pattern_matching(self, seqid, iprot, oprot):
        args = pktgen_enable_recirc_pattern_matching_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_enable_recirc_pattern_matching_result()
        try:
            self._handler.pktgen_enable_recirc_pattern_matching(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_enable_recirc_pattern_matching", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_disable_recirc_pattern_matching(self, seqid, iprot, oprot):
        args = pktgen_disable_recirc_pattern_matching_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_disable_recirc_pattern_matching_result()
        try:
            self._handler.pktgen_disable_recirc_pattern_matching(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_disable_recirc_pattern_matching", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_clear_port_down(self, seqid, iprot, oprot):
        args = pktgen_clear_port_down_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_clear_port_down_result()
        try:
            self._handler.pktgen_clear_port_down(args.sess_hdl, args.dev, args.port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_clear_port_down", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_cfg_app(self, seqid, iprot, oprot):
        args = pktgen_cfg_app_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_cfg_app_result()
        try:
            self._handler.pktgen_cfg_app(args.sess_hdl, args.dev_tgt, args.app_id, args.cfg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_cfg_app", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_cfg_app_tof2(self, seqid, iprot, oprot):
        args = pktgen_cfg_app_tof2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_cfg_app_tof2_result()
        try:
            self._handler.pktgen_cfg_app_tof2(args.sess_hdl, args.dev_tgt, args.app_id, args.cfg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_cfg_app_tof2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_cfg_port_mask_tof2(self, seqid, iprot, oprot):
        args = pktgen_cfg_port_mask_tof2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_cfg_port_mask_tof2_result()
        try:
            self._handler.pktgen_cfg_port_mask_tof2(args.sess_hdl, args.dev_tgt, args.sel, args.mask_in)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_cfg_port_mask_tof2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_app_enable(self, seqid, iprot, oprot):
        args = pktgen_app_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_app_enable_result()
        try:
            self._handler.pktgen_app_enable(args.sess_hdl, args.dev_tgt, args.app_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_app_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_app_disable(self, seqid, iprot, oprot):
        args = pktgen_app_disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_app_disable_result()
        try:
            self._handler.pktgen_app_disable(args.sess_hdl, args.dev_tgt, args.app_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_app_disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_write_pkt_buffer(self, seqid, iprot, oprot):
        args = pktgen_write_pkt_buffer_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_write_pkt_buffer_result()
        try:
            self._handler.pktgen_write_pkt_buffer(args.sess_hdl, args.dev_tgt, args.offset, args.size, args.buf)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_write_pkt_buffer", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_get_batch_counter(self, seqid, iprot, oprot):
        args = pktgen_get_batch_counter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_get_batch_counter_result()
        try:
            result.success = self._handler.pktgen_get_batch_counter(args.sess_hdl, args.dev_tgt, args.app_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_get_batch_counter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_get_pkt_counter(self, seqid, iprot, oprot):
        args = pktgen_get_pkt_counter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_get_pkt_counter_result()
        try:
            result.success = self._handler.pktgen_get_pkt_counter(args.sess_hdl, args.dev_tgt, args.app_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_get_pkt_counter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_get_trigger_counter(self, seqid, iprot, oprot):
        args = pktgen_get_trigger_counter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_get_trigger_counter_result()
        try:
            result.success = self._handler.pktgen_get_trigger_counter(args.sess_hdl, args.dev_tgt, args.app_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_get_trigger_counter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_set_batch_counter(self, seqid, iprot, oprot):
        args = pktgen_set_batch_counter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_set_batch_counter_result()
        try:
            self._handler.pktgen_set_batch_counter(args.sess_hdl, args.dev_tgt, args.app_id, args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_set_batch_counter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_set_pkt_counter(self, seqid, iprot, oprot):
        args = pktgen_set_pkt_counter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_set_pkt_counter_result()
        try:
            self._handler.pktgen_set_pkt_counter(args.sess_hdl, args.dev_tgt, args.app_id, args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_set_pkt_counter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_set_trigger_counter(self, seqid, iprot, oprot):
        args = pktgen_set_trigger_counter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_set_trigger_counter_result()
        try:
            self._handler.pktgen_set_trigger_counter(args.sess_hdl, args.dev_tgt, args.app_id, args.count)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_set_trigger_counter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_port_down_replay_mode_set(self, seqid, iprot, oprot):
        args = pktgen_port_down_replay_mode_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_port_down_replay_mode_set_result()
        try:
            self._handler.pktgen_port_down_replay_mode_set(args.sess_hdl, args.dev_tgt, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_port_down_replay_mode_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pktgen_port_down_replay_mode_get(self, seqid, iprot, oprot):
        args = pktgen_port_down_replay_mode_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pktgen_port_down_replay_mode_get_result()
        try:
            result.success = self._handler.pktgen_port_down_replay_mode_get(args.sess_hdl, args.dev_tgt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPktGenOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pktgen_port_down_replay_mode_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reg_wr(self, seqid, iprot, oprot):
        args = reg_wr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reg_wr_result()
        try:
            self._handler.reg_wr(args.dev, args.addr, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reg_wr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reg_rd(self, seqid, iprot, oprot):
        args = reg_rd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reg_rd_result()
        try:
            result.success = self._handler.reg_rd(args.dev, args.addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reg_rd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ind_reg_wr(self, seqid, iprot, oprot):
        args = ind_reg_wr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ind_reg_wr_result()
        try:
            self._handler.ind_reg_wr(args.dev, args.addr, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ind_reg_wr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ind_reg_rd(self, seqid, iprot, oprot):
        args = ind_reg_rd_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ind_reg_rd_result()
        try:
            result.success = self._handler.ind_reg_rd(args.dev, args.addr)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ind_reg_rd", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tcam_scrub_timer_set(self, seqid, iprot, oprot):
        args = tcam_scrub_timer_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tcam_scrub_timer_set_result()
        try:
            self._handler.tcam_scrub_timer_set(args.dev, args.msec_timer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tcam_scrub_timer_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tcam_scrub_timer_get(self, seqid, iprot, oprot):
        args = tcam_scrub_timer_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tcam_scrub_timer_get_result()
        try:
            result.success = self._handler.tcam_scrub_timer_get(args.dev)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidConnMgrOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tcam_scrub_timer_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class echo_args(object):
    """
    Attributes:
     - s

    """


    def __init__(self, s=None,):
        self.s = s

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.s = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('echo_args')
        if self.s is not None:
            oprot.writeFieldBegin('s', TType.STRING, 1)
            oprot.writeString(self.s.encode('utf-8') if sys.version_info[0] == 2 else self.s)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(echo_args)
echo_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 's', 'UTF8', None, ),  # 1
)


class echo_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('echo_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(echo_result)
echo_result.thrift_spec = (
)


class init_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_args)
init_args.thrift_spec = (
)


class init_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('init_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(init_result)
init_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class cleanup_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cleanup_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cleanup_args)
cleanup_args.thrift_spec = (
)


class cleanup_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cleanup_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cleanup_result)
cleanup_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class client_init_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_init_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_init_args)
client_init_args.thrift_spec = (
)


class client_init_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_init_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_init_result)
client_init_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class client_cleanup_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_cleanup_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_cleanup_args)
client_cleanup_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class client_cleanup_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('client_cleanup_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(client_cleanup_result)
client_cleanup_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class begin_txn_args(object):
    """
    Attributes:
     - sess_hdl
     - isAtomic

    """


    def __init__(self, sess_hdl=None, isAtomic=None,):
        self.sess_hdl = sess_hdl
        self.isAtomic = isAtomic

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.isAtomic = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('begin_txn_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.isAtomic is not None:
            oprot.writeFieldBegin('isAtomic', TType.BOOL, 2)
            oprot.writeBool(self.isAtomic)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(begin_txn_args)
begin_txn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BOOL, 'isAtomic', None, None, ),  # 2
)


class begin_txn_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('begin_txn_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(begin_txn_result)
begin_txn_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class verify_txn_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_txn_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_txn_args)
verify_txn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class verify_txn_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_txn_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_txn_result)
verify_txn_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class abort_txn_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_txn_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_txn_args)
abort_txn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class abort_txn_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_txn_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_txn_result)
abort_txn_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class commit_txn_args(object):
    """
    Attributes:
     - sess_hdl
     - hwSynchronous

    """


    def __init__(self, sess_hdl=None, hwSynchronous=None,):
        self.sess_hdl = sess_hdl
        self.hwSynchronous = hwSynchronous

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hwSynchronous = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_txn_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.hwSynchronous is not None:
            oprot.writeFieldBegin('hwSynchronous', TType.BOOL, 2)
            oprot.writeBool(self.hwSynchronous)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_txn_args)
commit_txn_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BOOL, 'hwSynchronous', None, None, ),  # 2
)


class commit_txn_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('commit_txn_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(commit_txn_result)
commit_txn_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class complete_operations_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('complete_operations_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(complete_operations_args)
complete_operations_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class complete_operations_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('complete_operations_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(complete_operations_result)
complete_operations_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class begin_batch_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('begin_batch_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(begin_batch_args)
begin_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class begin_batch_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('begin_batch_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(begin_batch_result)
begin_batch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class flush_batch_args(object):
    """
    Attributes:
     - sess_hdl

    """


    def __init__(self, sess_hdl=None,):
        self.sess_hdl = sess_hdl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_batch_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_batch_args)
flush_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
)


class flush_batch_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('flush_batch_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(flush_batch_result)
flush_batch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class end_batch_args(object):
    """
    Attributes:
     - sess_hdl
     - hwSynchronous

    """


    def __init__(self, sess_hdl=None, hwSynchronous=None,):
        self.sess_hdl = sess_hdl
        self.hwSynchronous = hwSynchronous

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hwSynchronous = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_batch_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.hwSynchronous is not None:
            oprot.writeFieldBegin('hwSynchronous', TType.BOOL, 2)
            oprot.writeBool(self.hwSynchronous)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_batch_args)
end_batch_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.BOOL, 'hwSynchronous', None, None, ),  # 2
)


class end_batch_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_batch_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_batch_result)
end_batch_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class log_state_args(object):
    """
    Attributes:
     - device_id
     - filepath

    """


    def __init__(self, device_id=None, filepath=None,):
        self.device_id = device_id
        self.filepath = filepath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filepath = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_state_args')
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 1)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        if self.filepath is not None:
            oprot.writeFieldBegin('filepath', TType.STRING, 2)
            oprot.writeBinary(self.filepath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_state_args)
log_state_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'device_id', None, None, ),  # 1
    (2, TType.STRING, 'filepath', 'BINARY', None, ),  # 2
)


class log_state_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_state_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_state_result)
log_state_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class restore_state_args(object):
    """
    Attributes:
     - device_id
     - filepath

    """


    def __init__(self, device_id=None, filepath=None,):
        self.device_id = device_id
        self.filepath = filepath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filepath = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restore_state_args')
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 1)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        if self.filepath is not None:
            oprot.writeFieldBegin('filepath', TType.STRING, 2)
            oprot.writeBinary(self.filepath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restore_state_args)
restore_state_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'device_id', None, None, ),  # 1
    (2, TType.STRING, 'filepath', 'BINARY', None, ),  # 2
)


class restore_state_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restore_state_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restore_state_result)
restore_state_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class advance_model_time_args(object):
    """
    Attributes:
     - sess_hdl
     - device_id
     - tick_time

    """


    def __init__(self, sess_hdl=None, device_id=None, tick_time=None,):
        self.sess_hdl = sess_hdl
        self.device_id = device_id
        self.tick_time = tick_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.device_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.tick_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('advance_model_time_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.device_id is not None:
            oprot.writeFieldBegin('device_id', TType.I32, 2)
            oprot.writeI32(self.device_id)
            oprot.writeFieldEnd()
        if self.tick_time is not None:
            oprot.writeFieldBegin('tick_time', TType.I64, 3)
            oprot.writeI64(self.tick_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(advance_model_time_args)
advance_model_time_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'device_id', None, None, ),  # 2
    (3, TType.I64, 'tick_time', None, None, ),  # 3
)


class advance_model_time_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('advance_model_time_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(advance_model_time_result)
advance_model_time_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class recirculation_enable_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recirculation_enable_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recirculation_enable_args)
recirculation_enable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class recirculation_enable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recirculation_enable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recirculation_enable_result)
recirculation_enable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class recirculation_disable_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recirculation_disable_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recirculation_disable_args)
recirculation_disable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class recirculation_disable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('recirculation_disable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(recirculation_disable_result)
recirculation_disable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class pktgen_enable_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_enable_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_enable_args)
pktgen_enable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class pktgen_enable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_enable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_enable_result)
pktgen_enable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_disable_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_disable_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_disable_args)
pktgen_disable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class pktgen_disable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_disable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_disable_result)
pktgen_disable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_enable_recirc_pattern_matching_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_enable_recirc_pattern_matching_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_enable_recirc_pattern_matching_args)
pktgen_enable_recirc_pattern_matching_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class pktgen_enable_recirc_pattern_matching_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_enable_recirc_pattern_matching_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_enable_recirc_pattern_matching_result)
pktgen_enable_recirc_pattern_matching_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_disable_recirc_pattern_matching_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_disable_recirc_pattern_matching_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_disable_recirc_pattern_matching_args)
pktgen_disable_recirc_pattern_matching_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class pktgen_disable_recirc_pattern_matching_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_disable_recirc_pattern_matching_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_disable_recirc_pattern_matching_result)
pktgen_disable_recirc_pattern_matching_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_clear_port_down_args(object):
    """
    Attributes:
     - sess_hdl
     - dev
     - port

    """


    def __init__(self, sess_hdl=None, dev=None, port=None,):
        self.sess_hdl = sess_hdl
        self.dev = dev
        self.port = port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_clear_port_down_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 2)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_clear_port_down_args)
pktgen_clear_port_down_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.I32, 'dev', None, None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
)


class pktgen_clear_port_down_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_clear_port_down_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_clear_port_down_result)
pktgen_clear_port_down_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_cfg_app_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id
     - cfg

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None, cfg=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id
        self.cfg = cfg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cfg = PktGenAppCfg_t()
                    self.cfg.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_cfg_app_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        if self.cfg is not None:
            oprot.writeFieldBegin('cfg', TType.STRUCT, 4)
            self.cfg.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_cfg_app_args)
pktgen_cfg_app_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
    (4, TType.STRUCT, 'cfg', [PktGenAppCfg_t, None], None, ),  # 4
)


class pktgen_cfg_app_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_cfg_app_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_cfg_app_result)
pktgen_cfg_app_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_cfg_app_tof2_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id
     - cfg

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None, cfg=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id
        self.cfg = cfg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.cfg = PktGenAppCfg_tof2_t()
                    self.cfg.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_cfg_app_tof2_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        if self.cfg is not None:
            oprot.writeFieldBegin('cfg', TType.STRUCT, 4)
            self.cfg.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_cfg_app_tof2_args)
pktgen_cfg_app_tof2_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
    (4, TType.STRUCT, 'cfg', [PktGenAppCfg_tof2_t, None], None, ),  # 4
)


class pktgen_cfg_app_tof2_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_cfg_app_tof2_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_cfg_app_tof2_result)
pktgen_cfg_app_tof2_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_cfg_port_mask_tof2_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - sel
     - mask_in

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, sel=None, mask_in=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.sel = sel
        self.mask_in = mask_in

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.sel = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.mask_in = PortMask_t()
                    self.mask_in.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_cfg_port_mask_tof2_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.sel is not None:
            oprot.writeFieldBegin('sel', TType.I32, 3)
            oprot.writeI32(self.sel)
            oprot.writeFieldEnd()
        if self.mask_in is not None:
            oprot.writeFieldBegin('mask_in', TType.STRUCT, 4)
            self.mask_in.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_cfg_port_mask_tof2_args)
pktgen_cfg_port_mask_tof2_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'sel', None, None, ),  # 3
    (4, TType.STRUCT, 'mask_in', [PortMask_t, None], None, ),  # 4
)


class pktgen_cfg_port_mask_tof2_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_cfg_port_mask_tof2_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_cfg_port_mask_tof2_result)
pktgen_cfg_port_mask_tof2_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_app_enable_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_app_enable_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_app_enable_args)
pktgen_app_enable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
)


class pktgen_app_enable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_app_enable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_app_enable_result)
pktgen_app_enable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_app_disable_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_app_disable_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_app_disable_args)
pktgen_app_disable_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
)


class pktgen_app_disable_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_app_disable_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_app_disable_result)
pktgen_app_disable_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_write_pkt_buffer_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - offset
     - size
     - buf

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, offset=None, size=None, buf=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.offset = offset
        self.size = size
        self.buf = buf

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.buf = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_write_pkt_buffer_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I32, 3)
            oprot.writeI32(self.offset)
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 4)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.buf is not None:
            oprot.writeFieldBegin('buf', TType.STRING, 5)
            oprot.writeBinary(self.buf)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_write_pkt_buffer_args)
pktgen_write_pkt_buffer_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'offset', None, None, ),  # 3
    (4, TType.I32, 'size', None, None, ),  # 4
    (5, TType.STRING, 'buf', 'BINARY', None, ),  # 5
)


class pktgen_write_pkt_buffer_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_write_pkt_buffer_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_write_pkt_buffer_result)
pktgen_write_pkt_buffer_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_get_batch_counter_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_get_batch_counter_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_get_batch_counter_args)
pktgen_get_batch_counter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
)


class pktgen_get_batch_counter_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_get_batch_counter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_get_batch_counter_result)
pktgen_get_batch_counter_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_get_pkt_counter_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_get_pkt_counter_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_get_pkt_counter_args)
pktgen_get_pkt_counter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
)


class pktgen_get_pkt_counter_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_get_pkt_counter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_get_pkt_counter_result)
pktgen_get_pkt_counter_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_get_trigger_counter_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_get_trigger_counter_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_get_trigger_counter_args)
pktgen_get_trigger_counter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
)


class pktgen_get_trigger_counter_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_get_trigger_counter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_get_trigger_counter_result)
pktgen_get_trigger_counter_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_set_batch_counter_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id
     - count

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None, count=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_set_batch_counter_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 4)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_set_batch_counter_args)
pktgen_set_batch_counter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
    (4, TType.I64, 'count', None, None, ),  # 4
)


class pktgen_set_batch_counter_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_set_batch_counter_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_set_batch_counter_result)
pktgen_set_batch_counter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_set_pkt_counter_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id
     - count

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None, count=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_set_pkt_counter_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 4)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_set_pkt_counter_args)
pktgen_set_pkt_counter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
    (4, TType.I64, 'count', None, None, ),  # 4
)


class pktgen_set_pkt_counter_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_set_pkt_counter_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_set_pkt_counter_result)
pktgen_set_pkt_counter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_set_trigger_counter_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - app_id
     - count

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, app_id=None, count=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.app_id = app_id
        self.count = count

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.app_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_set_trigger_counter_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.app_id is not None:
            oprot.writeFieldBegin('app_id', TType.I32, 3)
            oprot.writeI32(self.app_id)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I64, 4)
            oprot.writeI64(self.count)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_set_trigger_counter_args)
pktgen_set_trigger_counter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'app_id', None, None, ),  # 3
    (4, TType.I64, 'count', None, None, ),  # 4
)


class pktgen_set_trigger_counter_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_set_trigger_counter_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_set_trigger_counter_result)
pktgen_set_trigger_counter_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_port_down_replay_mode_set_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt
     - mode

    """


    def __init__(self, sess_hdl=None, dev_tgt=None, mode=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_port_down_replay_mode_set_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 3)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_port_down_replay_mode_set_args)
pktgen_port_down_replay_mode_set_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
    (3, TType.I32, 'mode', None, None, ),  # 3
)


class pktgen_port_down_replay_mode_set_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_port_down_replay_mode_set_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_port_down_replay_mode_set_result)
pktgen_port_down_replay_mode_set_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class pktgen_port_down_replay_mode_get_args(object):
    """
    Attributes:
     - sess_hdl
     - dev_tgt

    """


    def __init__(self, sess_hdl=None, dev_tgt=None,):
        self.sess_hdl = sess_hdl
        self.dev_tgt = dev_tgt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.sess_hdl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dev_tgt = controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t()
                    self.dev_tgt.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_port_down_replay_mode_get_args')
        if self.sess_hdl is not None:
            oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
            oprot.writeI32(self.sess_hdl)
            oprot.writeFieldEnd()
        if self.dev_tgt is not None:
            oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
            self.dev_tgt.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_port_down_replay_mode_get_args)
pktgen_port_down_replay_mode_get_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'sess_hdl', None, None, ),  # 1
    (2, TType.STRUCT, 'dev_tgt', [controller.thrift_api.res_pd_rpc.ttypes.DevTarget_t, None], None, ),  # 2
)


class pktgen_port_down_replay_mode_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPktGenOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pktgen_port_down_replay_mode_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pktgen_port_down_replay_mode_get_result)
pktgen_port_down_replay_mode_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPktGenOperation, None], None, ),  # 1
)


class reg_wr_args(object):
    """
    Attributes:
     - dev
     - addr
     - data

    """


    def __init__(self, dev=None, addr=None, data=None,):
        self.dev = dev
        self.addr = addr
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.data = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reg_wr_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 1)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I32, 2)
            oprot.writeI32(self.addr)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.I32, 3)
            oprot.writeI32(self.data)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reg_wr_args)
reg_wr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev', None, None, ),  # 1
    (2, TType.I32, 'addr', None, None, ),  # 2
    (3, TType.I32, 'data', None, None, ),  # 3
)


class reg_wr_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reg_wr_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reg_wr_result)
reg_wr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class reg_rd_args(object):
    """
    Attributes:
     - dev
     - addr

    """


    def __init__(self, dev=None, addr=None,):
        self.dev = dev
        self.addr = addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.addr = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reg_rd_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 1)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I32, 2)
            oprot.writeI32(self.addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reg_rd_args)
reg_rd_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev', None, None, ),  # 1
    (2, TType.I32, 'addr', None, None, ),  # 2
)


class reg_rd_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reg_rd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reg_rd_result)
reg_rd_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class ind_reg_wr_args(object):
    """
    Attributes:
     - dev
     - addr
     - data

    """


    def __init__(self, dev=None, addr=None, data=None,):
        self.dev = dev
        self.addr = addr
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.data = indirect_reg_data_t()
                    self.data.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ind_reg_wr_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 1)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I64, 2)
            oprot.writeI64(self.addr)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRUCT, 3)
            self.data.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ind_reg_wr_args)
ind_reg_wr_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev', None, None, ),  # 1
    (2, TType.I64, 'addr', None, None, ),  # 2
    (3, TType.STRUCT, 'data', [indirect_reg_data_t, None], None, ),  # 3
)


class ind_reg_wr_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ind_reg_wr_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ind_reg_wr_result)
ind_reg_wr_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class ind_reg_rd_args(object):
    """
    Attributes:
     - dev
     - addr

    """


    def __init__(self, dev=None, addr=None,):
        self.dev = dev
        self.addr = addr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.addr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ind_reg_rd_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 1)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.addr is not None:
            oprot.writeFieldBegin('addr', TType.I64, 2)
            oprot.writeI64(self.addr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ind_reg_rd_args)
ind_reg_rd_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev', None, None, ),  # 1
    (2, TType.I64, 'addr', None, None, ),  # 2
)


class ind_reg_rd_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = indirect_reg_data_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ind_reg_rd_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ind_reg_rd_result)
ind_reg_rd_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [indirect_reg_data_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class tcam_scrub_timer_set_args(object):
    """
    Attributes:
     - dev
     - msec_timer

    """


    def __init__(self, dev=None, msec_timer=None,):
        self.dev = dev
        self.msec_timer = msec_timer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.msec_timer = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcam_scrub_timer_set_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 1)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        if self.msec_timer is not None:
            oprot.writeFieldBegin('msec_timer', TType.I32, 2)
            oprot.writeI32(self.msec_timer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcam_scrub_timer_set_args)
tcam_scrub_timer_set_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev', None, None, ),  # 1
    (2, TType.I32, 'msec_timer', None, None, ),  # 2
)


class tcam_scrub_timer_set_result(object):
    """
    Attributes:
     - ouch

    """


    def __init__(self, ouch=None,):
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcam_scrub_timer_set_result')
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcam_scrub_timer_set_result)
tcam_scrub_timer_set_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)


class tcam_scrub_timer_get_args(object):
    """
    Attributes:
     - dev

    """


    def __init__(self, dev=None,):
        self.dev = dev

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.dev = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcam_scrub_timer_get_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.I32, 1)
            oprot.writeI32(self.dev)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcam_scrub_timer_get_args)
tcam_scrub_timer_get_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'dev', None, None, ),  # 1
)


class tcam_scrub_timer_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidConnMgrOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcam_scrub_timer_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcam_scrub_timer_get_result)
tcam_scrub_timer_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidConnMgrOperation, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
