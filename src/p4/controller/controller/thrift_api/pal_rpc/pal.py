#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:package_prefix=controller.thrift_api.
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def pal_port_add(self, device, dev_port, ps, fec):
        """
        Parameters:
         - device
         - dev_port
         - ps
         - fec

        """
        pass

    def pal_port_add_all(self, device, ps, fec):
        """
        Parameters:
         - device
         - ps
         - fec

        """
        pass

    def pal_port_del(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_del_all(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_port_enable(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_enable_all(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_port_dis(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_oper_status_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_is_valid(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_an_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_an_set(self, device, dev_port, an):
        """
        Parameters:
         - device
         - dev_port
         - an

        """
        pass

    def pal_port_an_set_all(self, device, an):
        """
        Parameters:
         - device
         - an

        """
        pass

    def pal_port_get_first(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_port_get_next(self, device, curr_dev_port):
        """
        Parameters:
         - device
         - curr_dev_port

        """
        pass

    def pal_port_stats_direct_get(self, device, dev_port, ctr_type):
        """
        Parameters:
         - device
         - dev_port
         - ctr_type

        """
        pass

    def pal_port_all_stats_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_all_stats_get_with_ts(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_this_stat_get(self, device, dev_port, ctr_type):
        """
        Parameters:
         - device
         - dev_port
         - ctr_type

        """
        pass

    def pal_port_this_stat_id_to_str(self, ctr_type):
        """
        Parameters:
         - ctr_type

        """
        pass

    def pal_port_this_stat_clear(self, device, dev_port, ctr_type):
        """
        Parameters:
         - device
         - dev_port
         - ctr_type

        """
        pass

    def pal_port_all_stats_clear(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_stats_poll_intvl_get(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_port_stats_poll_intvl_set(self, device, poll_intvl_ms):
        """
        Parameters:
         - device
         - poll_intvl_ms

        """
        pass

    def pal_port_all_stats_update(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_num_lanes_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_mtu_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_mtu_set(self, device, dev_port, tx_mtu, rx_mtu):
        """
        Parameters:
         - device
         - dev_port
         - tx_mtu
         - rx_mtu

        """
        pass

    def pal_port_flow_control_pfc_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_flow_control_pfc_set(self, device, dev_port, tx_en_map, rx_en_map):
        """
        Parameters:
         - device
         - dev_port
         - tx_en_map
         - rx_en_map

        """
        pass

    def pal_port_flow_control_link_pause_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_flow_control_link_pause_set(self, device, dev_port, tx_en, rx_en):
        """
        Parameters:
         - device
         - dev_port
         - tx_en
         - rx_en

        """
        pass

    def pal_port_fec_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_fec_set(self, device, dev_port, fec):
        """
        Parameters:
         - device
         - dev_port
         - fec

        """
        pass

    def pal_port_media_type_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_cut_through_enable(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_cut_through_disable(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_port_cut_through_enable_status_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass

    def pal_num_pipes_get(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_port_loopback_mode_get(self, dev, dev_port):
        """
        Parameters:
         - dev
         - dev_port

        """
        pass

    def pal_port_loopback_mode_set(self, dev, dev_port, mode):
        """
        Parameters:
         - dev
         - dev_port
         - mode

        """
        pass

    def pal_port_front_panel_port_to_dev_port_get(self, dev, front_port, front_chnl):
        """
        Parameters:
         - dev
         - front_port
         - front_chnl

        """
        pass

    def pal_port_dev_port_to_front_panel_port_get(self, dev, dev_port):
        """
        Parameters:
         - dev
         - dev_port

        """
        pass

    def pal_max_ports_get(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_fp_idx_to_dev_port_map(self, device, fp_idx):
        """
        Parameters:
         - device
         - fp_idx

        """
        pass

    def pal_recirc_port_to_dev_port_map(self, device, recirc_port):
        """
        Parameters:
         - device
         - recirc_port

        """
        pass

    def pal_recirc_port_range_get(self, device):
        """
        Parameters:
         - device

        """
        pass

    def pal_is_port_internal(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def pal_port_add(self, device, dev_port, ps, fec):
        """
        Parameters:
         - device
         - dev_port
         - ps
         - fec

        """
        self.send_pal_port_add(device, dev_port, ps, fec)
        return self.recv_pal_port_add()

    def send_pal_port_add(self, device, dev_port, ps, fec):
        self._oprot.writeMessageBegin('pal_port_add', TMessageType.CALL, self._seqid)
        args = pal_port_add_args()
        args.device = device
        args.dev_port = dev_port
        args.ps = ps
        args.fec = fec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_add(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_add_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_add failed: unknown result")

    def pal_port_add_all(self, device, ps, fec):
        """
        Parameters:
         - device
         - ps
         - fec

        """
        self.send_pal_port_add_all(device, ps, fec)
        return self.recv_pal_port_add_all()

    def send_pal_port_add_all(self, device, ps, fec):
        self._oprot.writeMessageBegin('pal_port_add_all', TMessageType.CALL, self._seqid)
        args = pal_port_add_all_args()
        args.device = device
        args.ps = ps
        args.fec = fec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_add_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_add_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_add_all failed: unknown result")

    def pal_port_del(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_del(device, dev_port)
        return self.recv_pal_port_del()

    def send_pal_port_del(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_del', TMessageType.CALL, self._seqid)
        args = pal_port_del_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_del(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_del_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_del failed: unknown result")

    def pal_port_del_all(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_port_del_all(device)
        return self.recv_pal_port_del_all()

    def send_pal_port_del_all(self, device):
        self._oprot.writeMessageBegin('pal_port_del_all', TMessageType.CALL, self._seqid)
        args = pal_port_del_all_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_del_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_del_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_del_all failed: unknown result")

    def pal_port_enable(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_enable(device, dev_port)
        return self.recv_pal_port_enable()

    def send_pal_port_enable(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_enable', TMessageType.CALL, self._seqid)
        args = pal_port_enable_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_enable failed: unknown result")

    def pal_port_enable_all(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_port_enable_all(device)
        return self.recv_pal_port_enable_all()

    def send_pal_port_enable_all(self, device):
        self._oprot.writeMessageBegin('pal_port_enable_all', TMessageType.CALL, self._seqid)
        args = pal_port_enable_all_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_enable_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_enable_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_enable_all failed: unknown result")

    def pal_port_dis(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_dis(device, dev_port)
        return self.recv_pal_port_dis()

    def send_pal_port_dis(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_dis', TMessageType.CALL, self._seqid)
        args = pal_port_dis_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_dis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_dis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_dis failed: unknown result")

    def pal_port_oper_status_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_oper_status_get(device, dev_port)
        return self.recv_pal_port_oper_status_get()

    def send_pal_port_oper_status_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_oper_status_get', TMessageType.CALL, self._seqid)
        args = pal_port_oper_status_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_oper_status_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_oper_status_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_oper_status_get failed: unknown result")

    def pal_port_is_valid(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_is_valid(device, dev_port)
        return self.recv_pal_port_is_valid()

    def send_pal_port_is_valid(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_is_valid', TMessageType.CALL, self._seqid)
        args = pal_port_is_valid_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_is_valid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_is_valid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_is_valid failed: unknown result")

    def pal_port_an_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_an_get(device, dev_port)
        return self.recv_pal_port_an_get()

    def send_pal_port_an_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_an_get', TMessageType.CALL, self._seqid)
        args = pal_port_an_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_an_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_an_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_an_get failed: unknown result")

    def pal_port_an_set(self, device, dev_port, an):
        """
        Parameters:
         - device
         - dev_port
         - an

        """
        self.send_pal_port_an_set(device, dev_port, an)
        return self.recv_pal_port_an_set()

    def send_pal_port_an_set(self, device, dev_port, an):
        self._oprot.writeMessageBegin('pal_port_an_set', TMessageType.CALL, self._seqid)
        args = pal_port_an_set_args()
        args.device = device
        args.dev_port = dev_port
        args.an = an
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_an_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_an_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_an_set failed: unknown result")

    def pal_port_an_set_all(self, device, an):
        """
        Parameters:
         - device
         - an

        """
        self.send_pal_port_an_set_all(device, an)
        return self.recv_pal_port_an_set_all()

    def send_pal_port_an_set_all(self, device, an):
        self._oprot.writeMessageBegin('pal_port_an_set_all', TMessageType.CALL, self._seqid)
        args = pal_port_an_set_all_args()
        args.device = device
        args.an = an
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_an_set_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_an_set_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_an_set_all failed: unknown result")

    def pal_port_get_first(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_port_get_first(device)
        return self.recv_pal_port_get_first()

    def send_pal_port_get_first(self, device):
        self._oprot.writeMessageBegin('pal_port_get_first', TMessageType.CALL, self._seqid)
        args = pal_port_get_first_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_get_first(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_get_first_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_get_first failed: unknown result")

    def pal_port_get_next(self, device, curr_dev_port):
        """
        Parameters:
         - device
         - curr_dev_port

        """
        self.send_pal_port_get_next(device, curr_dev_port)
        return self.recv_pal_port_get_next()

    def send_pal_port_get_next(self, device, curr_dev_port):
        self._oprot.writeMessageBegin('pal_port_get_next', TMessageType.CALL, self._seqid)
        args = pal_port_get_next_args()
        args.device = device
        args.curr_dev_port = curr_dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_get_next(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_get_next_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_get_next failed: unknown result")

    def pal_port_stats_direct_get(self, device, dev_port, ctr_type):
        """
        Parameters:
         - device
         - dev_port
         - ctr_type

        """
        self.send_pal_port_stats_direct_get(device, dev_port, ctr_type)
        return self.recv_pal_port_stats_direct_get()

    def send_pal_port_stats_direct_get(self, device, dev_port, ctr_type):
        self._oprot.writeMessageBegin('pal_port_stats_direct_get', TMessageType.CALL, self._seqid)
        args = pal_port_stats_direct_get_args()
        args.device = device
        args.dev_port = dev_port
        args.ctr_type = ctr_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_stats_direct_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_stats_direct_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_stats_direct_get failed: unknown result")

    def pal_port_all_stats_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_all_stats_get(device, dev_port)
        return self.recv_pal_port_all_stats_get()

    def send_pal_port_all_stats_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_all_stats_get', TMessageType.CALL, self._seqid)
        args = pal_port_all_stats_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_all_stats_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_all_stats_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_all_stats_get failed: unknown result")

    def pal_port_all_stats_get_with_ts(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_all_stats_get_with_ts(device, dev_port)
        return self.recv_pal_port_all_stats_get_with_ts()

    def send_pal_port_all_stats_get_with_ts(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_all_stats_get_with_ts', TMessageType.CALL, self._seqid)
        args = pal_port_all_stats_get_with_ts_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_all_stats_get_with_ts(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_all_stats_get_with_ts_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_all_stats_get_with_ts failed: unknown result")

    def pal_port_this_stat_get(self, device, dev_port, ctr_type):
        """
        Parameters:
         - device
         - dev_port
         - ctr_type

        """
        self.send_pal_port_this_stat_get(device, dev_port, ctr_type)
        return self.recv_pal_port_this_stat_get()

    def send_pal_port_this_stat_get(self, device, dev_port, ctr_type):
        self._oprot.writeMessageBegin('pal_port_this_stat_get', TMessageType.CALL, self._seqid)
        args = pal_port_this_stat_get_args()
        args.device = device
        args.dev_port = dev_port
        args.ctr_type = ctr_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_this_stat_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_this_stat_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_this_stat_get failed: unknown result")

    def pal_port_this_stat_id_to_str(self, ctr_type):
        """
        Parameters:
         - ctr_type

        """
        self.send_pal_port_this_stat_id_to_str(ctr_type)
        return self.recv_pal_port_this_stat_id_to_str()

    def send_pal_port_this_stat_id_to_str(self, ctr_type):
        self._oprot.writeMessageBegin('pal_port_this_stat_id_to_str', TMessageType.CALL, self._seqid)
        args = pal_port_this_stat_id_to_str_args()
        args.ctr_type = ctr_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_this_stat_id_to_str(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_this_stat_id_to_str_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_this_stat_id_to_str failed: unknown result")

    def pal_port_this_stat_clear(self, device, dev_port, ctr_type):
        """
        Parameters:
         - device
         - dev_port
         - ctr_type

        """
        self.send_pal_port_this_stat_clear(device, dev_port, ctr_type)
        return self.recv_pal_port_this_stat_clear()

    def send_pal_port_this_stat_clear(self, device, dev_port, ctr_type):
        self._oprot.writeMessageBegin('pal_port_this_stat_clear', TMessageType.CALL, self._seqid)
        args = pal_port_this_stat_clear_args()
        args.device = device
        args.dev_port = dev_port
        args.ctr_type = ctr_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_this_stat_clear(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_this_stat_clear_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_this_stat_clear failed: unknown result")

    def pal_port_all_stats_clear(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_all_stats_clear(device, dev_port)
        return self.recv_pal_port_all_stats_clear()

    def send_pal_port_all_stats_clear(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_all_stats_clear', TMessageType.CALL, self._seqid)
        args = pal_port_all_stats_clear_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_all_stats_clear(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_all_stats_clear_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_all_stats_clear failed: unknown result")

    def pal_port_stats_poll_intvl_get(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_port_stats_poll_intvl_get(device)
        return self.recv_pal_port_stats_poll_intvl_get()

    def send_pal_port_stats_poll_intvl_get(self, device):
        self._oprot.writeMessageBegin('pal_port_stats_poll_intvl_get', TMessageType.CALL, self._seqid)
        args = pal_port_stats_poll_intvl_get_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_stats_poll_intvl_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_stats_poll_intvl_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_stats_poll_intvl_get failed: unknown result")

    def pal_port_stats_poll_intvl_set(self, device, poll_intvl_ms):
        """
        Parameters:
         - device
         - poll_intvl_ms

        """
        self.send_pal_port_stats_poll_intvl_set(device, poll_intvl_ms)
        return self.recv_pal_port_stats_poll_intvl_set()

    def send_pal_port_stats_poll_intvl_set(self, device, poll_intvl_ms):
        self._oprot.writeMessageBegin('pal_port_stats_poll_intvl_set', TMessageType.CALL, self._seqid)
        args = pal_port_stats_poll_intvl_set_args()
        args.device = device
        args.poll_intvl_ms = poll_intvl_ms
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_stats_poll_intvl_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_stats_poll_intvl_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_stats_poll_intvl_set failed: unknown result")

    def pal_port_all_stats_update(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_all_stats_update(device, dev_port)
        return self.recv_pal_port_all_stats_update()

    def send_pal_port_all_stats_update(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_all_stats_update', TMessageType.CALL, self._seqid)
        args = pal_port_all_stats_update_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_all_stats_update(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_all_stats_update_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_all_stats_update failed: unknown result")

    def pal_port_num_lanes_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_num_lanes_get(device, dev_port)
        return self.recv_pal_port_num_lanes_get()

    def send_pal_port_num_lanes_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_num_lanes_get', TMessageType.CALL, self._seqid)
        args = pal_port_num_lanes_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_num_lanes_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_num_lanes_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_num_lanes_get failed: unknown result")

    def pal_port_mtu_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_mtu_get(device, dev_port)
        return self.recv_pal_port_mtu_get()

    def send_pal_port_mtu_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_mtu_get', TMessageType.CALL, self._seqid)
        args = pal_port_mtu_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_mtu_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_mtu_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_mtu_get failed: unknown result")

    def pal_port_mtu_set(self, device, dev_port, tx_mtu, rx_mtu):
        """
        Parameters:
         - device
         - dev_port
         - tx_mtu
         - rx_mtu

        """
        self.send_pal_port_mtu_set(device, dev_port, tx_mtu, rx_mtu)
        return self.recv_pal_port_mtu_set()

    def send_pal_port_mtu_set(self, device, dev_port, tx_mtu, rx_mtu):
        self._oprot.writeMessageBegin('pal_port_mtu_set', TMessageType.CALL, self._seqid)
        args = pal_port_mtu_set_args()
        args.device = device
        args.dev_port = dev_port
        args.tx_mtu = tx_mtu
        args.rx_mtu = rx_mtu
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_mtu_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_mtu_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_mtu_set failed: unknown result")

    def pal_port_flow_control_pfc_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_flow_control_pfc_get(device, dev_port)
        return self.recv_pal_port_flow_control_pfc_get()

    def send_pal_port_flow_control_pfc_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_flow_control_pfc_get', TMessageType.CALL, self._seqid)
        args = pal_port_flow_control_pfc_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_flow_control_pfc_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_flow_control_pfc_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_flow_control_pfc_get failed: unknown result")

    def pal_port_flow_control_pfc_set(self, device, dev_port, tx_en_map, rx_en_map):
        """
        Parameters:
         - device
         - dev_port
         - tx_en_map
         - rx_en_map

        """
        self.send_pal_port_flow_control_pfc_set(device, dev_port, tx_en_map, rx_en_map)
        return self.recv_pal_port_flow_control_pfc_set()

    def send_pal_port_flow_control_pfc_set(self, device, dev_port, tx_en_map, rx_en_map):
        self._oprot.writeMessageBegin('pal_port_flow_control_pfc_set', TMessageType.CALL, self._seqid)
        args = pal_port_flow_control_pfc_set_args()
        args.device = device
        args.dev_port = dev_port
        args.tx_en_map = tx_en_map
        args.rx_en_map = rx_en_map
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_flow_control_pfc_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_flow_control_pfc_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_flow_control_pfc_set failed: unknown result")

    def pal_port_flow_control_link_pause_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_flow_control_link_pause_get(device, dev_port)
        return self.recv_pal_port_flow_control_link_pause_get()

    def send_pal_port_flow_control_link_pause_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_flow_control_link_pause_get', TMessageType.CALL, self._seqid)
        args = pal_port_flow_control_link_pause_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_flow_control_link_pause_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_flow_control_link_pause_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_flow_control_link_pause_get failed: unknown result")

    def pal_port_flow_control_link_pause_set(self, device, dev_port, tx_en, rx_en):
        """
        Parameters:
         - device
         - dev_port
         - tx_en
         - rx_en

        """
        self.send_pal_port_flow_control_link_pause_set(device, dev_port, tx_en, rx_en)
        return self.recv_pal_port_flow_control_link_pause_set()

    def send_pal_port_flow_control_link_pause_set(self, device, dev_port, tx_en, rx_en):
        self._oprot.writeMessageBegin('pal_port_flow_control_link_pause_set', TMessageType.CALL, self._seqid)
        args = pal_port_flow_control_link_pause_set_args()
        args.device = device
        args.dev_port = dev_port
        args.tx_en = tx_en
        args.rx_en = rx_en
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_flow_control_link_pause_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_flow_control_link_pause_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_flow_control_link_pause_set failed: unknown result")

    def pal_port_fec_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_fec_get(device, dev_port)
        return self.recv_pal_port_fec_get()

    def send_pal_port_fec_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_fec_get', TMessageType.CALL, self._seqid)
        args = pal_port_fec_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_fec_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_fec_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_fec_get failed: unknown result")

    def pal_port_fec_set(self, device, dev_port, fec):
        """
        Parameters:
         - device
         - dev_port
         - fec

        """
        self.send_pal_port_fec_set(device, dev_port, fec)
        return self.recv_pal_port_fec_set()

    def send_pal_port_fec_set(self, device, dev_port, fec):
        self._oprot.writeMessageBegin('pal_port_fec_set', TMessageType.CALL, self._seqid)
        args = pal_port_fec_set_args()
        args.device = device
        args.dev_port = dev_port
        args.fec = fec
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_fec_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_fec_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_fec_set failed: unknown result")

    def pal_port_media_type_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_media_type_get(device, dev_port)
        return self.recv_pal_port_media_type_get()

    def send_pal_port_media_type_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_media_type_get', TMessageType.CALL, self._seqid)
        args = pal_port_media_type_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_media_type_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_media_type_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_media_type_get failed: unknown result")

    def pal_port_cut_through_enable(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_cut_through_enable(device, dev_port)
        return self.recv_pal_port_cut_through_enable()

    def send_pal_port_cut_through_enable(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_cut_through_enable', TMessageType.CALL, self._seqid)
        args = pal_port_cut_through_enable_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_cut_through_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_cut_through_enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_cut_through_enable failed: unknown result")

    def pal_port_cut_through_disable(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_cut_through_disable(device, dev_port)
        return self.recv_pal_port_cut_through_disable()

    def send_pal_port_cut_through_disable(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_cut_through_disable', TMessageType.CALL, self._seqid)
        args = pal_port_cut_through_disable_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_cut_through_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_cut_through_disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_cut_through_disable failed: unknown result")

    def pal_port_cut_through_enable_status_get(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_port_cut_through_enable_status_get(device, dev_port)
        return self.recv_pal_port_cut_through_enable_status_get()

    def send_pal_port_cut_through_enable_status_get(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_port_cut_through_enable_status_get', TMessageType.CALL, self._seqid)
        args = pal_port_cut_through_enable_status_get_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_cut_through_enable_status_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_cut_through_enable_status_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_cut_through_enable_status_get failed: unknown result")

    def pal_num_pipes_get(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_num_pipes_get(device)
        return self.recv_pal_num_pipes_get()

    def send_pal_num_pipes_get(self, device):
        self._oprot.writeMessageBegin('pal_num_pipes_get', TMessageType.CALL, self._seqid)
        args = pal_num_pipes_get_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_num_pipes_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_num_pipes_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_num_pipes_get failed: unknown result")

    def pal_port_loopback_mode_get(self, dev, dev_port):
        """
        Parameters:
         - dev
         - dev_port

        """
        self.send_pal_port_loopback_mode_get(dev, dev_port)
        return self.recv_pal_port_loopback_mode_get()

    def send_pal_port_loopback_mode_get(self, dev, dev_port):
        self._oprot.writeMessageBegin('pal_port_loopback_mode_get', TMessageType.CALL, self._seqid)
        args = pal_port_loopback_mode_get_args()
        args.dev = dev
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_loopback_mode_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_loopback_mode_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_loopback_mode_get failed: unknown result")

    def pal_port_loopback_mode_set(self, dev, dev_port, mode):
        """
        Parameters:
         - dev
         - dev_port
         - mode

        """
        self.send_pal_port_loopback_mode_set(dev, dev_port, mode)
        return self.recv_pal_port_loopback_mode_set()

    def send_pal_port_loopback_mode_set(self, dev, dev_port, mode):
        self._oprot.writeMessageBegin('pal_port_loopback_mode_set', TMessageType.CALL, self._seqid)
        args = pal_port_loopback_mode_set_args()
        args.dev = dev
        args.dev_port = dev_port
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_loopback_mode_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_loopback_mode_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_loopback_mode_set failed: unknown result")

    def pal_port_front_panel_port_to_dev_port_get(self, dev, front_port, front_chnl):
        """
        Parameters:
         - dev
         - front_port
         - front_chnl

        """
        self.send_pal_port_front_panel_port_to_dev_port_get(dev, front_port, front_chnl)
        return self.recv_pal_port_front_panel_port_to_dev_port_get()

    def send_pal_port_front_panel_port_to_dev_port_get(self, dev, front_port, front_chnl):
        self._oprot.writeMessageBegin('pal_port_front_panel_port_to_dev_port_get', TMessageType.CALL, self._seqid)
        args = pal_port_front_panel_port_to_dev_port_get_args()
        args.dev = dev
        args.front_port = front_port
        args.front_chnl = front_chnl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_front_panel_port_to_dev_port_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_front_panel_port_to_dev_port_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_front_panel_port_to_dev_port_get failed: unknown result")

    def pal_port_dev_port_to_front_panel_port_get(self, dev, dev_port):
        """
        Parameters:
         - dev
         - dev_port

        """
        self.send_pal_port_dev_port_to_front_panel_port_get(dev, dev_port)
        return self.recv_pal_port_dev_port_to_front_panel_port_get()

    def send_pal_port_dev_port_to_front_panel_port_get(self, dev, dev_port):
        self._oprot.writeMessageBegin('pal_port_dev_port_to_front_panel_port_get', TMessageType.CALL, self._seqid)
        args = pal_port_dev_port_to_front_panel_port_get_args()
        args.dev = dev
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_port_dev_port_to_front_panel_port_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_port_dev_port_to_front_panel_port_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_port_dev_port_to_front_panel_port_get failed: unknown result")

    def pal_max_ports_get(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_max_ports_get(device)
        return self.recv_pal_max_ports_get()

    def send_pal_max_ports_get(self, device):
        self._oprot.writeMessageBegin('pal_max_ports_get', TMessageType.CALL, self._seqid)
        args = pal_max_ports_get_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_max_ports_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_max_ports_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_max_ports_get failed: unknown result")

    def pal_fp_idx_to_dev_port_map(self, device, fp_idx):
        """
        Parameters:
         - device
         - fp_idx

        """
        self.send_pal_fp_idx_to_dev_port_map(device, fp_idx)
        return self.recv_pal_fp_idx_to_dev_port_map()

    def send_pal_fp_idx_to_dev_port_map(self, device, fp_idx):
        self._oprot.writeMessageBegin('pal_fp_idx_to_dev_port_map', TMessageType.CALL, self._seqid)
        args = pal_fp_idx_to_dev_port_map_args()
        args.device = device
        args.fp_idx = fp_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_fp_idx_to_dev_port_map(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_fp_idx_to_dev_port_map_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_fp_idx_to_dev_port_map failed: unknown result")

    def pal_recirc_port_to_dev_port_map(self, device, recirc_port):
        """
        Parameters:
         - device
         - recirc_port

        """
        self.send_pal_recirc_port_to_dev_port_map(device, recirc_port)
        return self.recv_pal_recirc_port_to_dev_port_map()

    def send_pal_recirc_port_to_dev_port_map(self, device, recirc_port):
        self._oprot.writeMessageBegin('pal_recirc_port_to_dev_port_map', TMessageType.CALL, self._seqid)
        args = pal_recirc_port_to_dev_port_map_args()
        args.device = device
        args.recirc_port = recirc_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_recirc_port_to_dev_port_map(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_recirc_port_to_dev_port_map_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_recirc_port_to_dev_port_map failed: unknown result")

    def pal_recirc_port_range_get(self, device):
        """
        Parameters:
         - device

        """
        self.send_pal_recirc_port_range_get(device)
        return self.recv_pal_recirc_port_range_get()

    def send_pal_recirc_port_range_get(self, device):
        self._oprot.writeMessageBegin('pal_recirc_port_range_get', TMessageType.CALL, self._seqid)
        args = pal_recirc_port_range_get_args()
        args.device = device
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_recirc_port_range_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_recirc_port_range_get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_recirc_port_range_get failed: unknown result")

    def pal_is_port_internal(self, device, dev_port):
        """
        Parameters:
         - device
         - dev_port

        """
        self.send_pal_is_port_internal(device, dev_port)
        return self.recv_pal_is_port_internal()

    def send_pal_is_port_internal(self, device, dev_port):
        self._oprot.writeMessageBegin('pal_is_port_internal', TMessageType.CALL, self._seqid)
        args = pal_is_port_internal_args()
        args.device = device
        args.dev_port = dev_port
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pal_is_port_internal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pal_is_port_internal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ouch is not None:
            raise result.ouch
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pal_is_port_internal failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["pal_port_add"] = Processor.process_pal_port_add
        self._processMap["pal_port_add_all"] = Processor.process_pal_port_add_all
        self._processMap["pal_port_del"] = Processor.process_pal_port_del
        self._processMap["pal_port_del_all"] = Processor.process_pal_port_del_all
        self._processMap["pal_port_enable"] = Processor.process_pal_port_enable
        self._processMap["pal_port_enable_all"] = Processor.process_pal_port_enable_all
        self._processMap["pal_port_dis"] = Processor.process_pal_port_dis
        self._processMap["pal_port_oper_status_get"] = Processor.process_pal_port_oper_status_get
        self._processMap["pal_port_is_valid"] = Processor.process_pal_port_is_valid
        self._processMap["pal_port_an_get"] = Processor.process_pal_port_an_get
        self._processMap["pal_port_an_set"] = Processor.process_pal_port_an_set
        self._processMap["pal_port_an_set_all"] = Processor.process_pal_port_an_set_all
        self._processMap["pal_port_get_first"] = Processor.process_pal_port_get_first
        self._processMap["pal_port_get_next"] = Processor.process_pal_port_get_next
        self._processMap["pal_port_stats_direct_get"] = Processor.process_pal_port_stats_direct_get
        self._processMap["pal_port_all_stats_get"] = Processor.process_pal_port_all_stats_get
        self._processMap["pal_port_all_stats_get_with_ts"] = Processor.process_pal_port_all_stats_get_with_ts
        self._processMap["pal_port_this_stat_get"] = Processor.process_pal_port_this_stat_get
        self._processMap["pal_port_this_stat_id_to_str"] = Processor.process_pal_port_this_stat_id_to_str
        self._processMap["pal_port_this_stat_clear"] = Processor.process_pal_port_this_stat_clear
        self._processMap["pal_port_all_stats_clear"] = Processor.process_pal_port_all_stats_clear
        self._processMap["pal_port_stats_poll_intvl_get"] = Processor.process_pal_port_stats_poll_intvl_get
        self._processMap["pal_port_stats_poll_intvl_set"] = Processor.process_pal_port_stats_poll_intvl_set
        self._processMap["pal_port_all_stats_update"] = Processor.process_pal_port_all_stats_update
        self._processMap["pal_port_num_lanes_get"] = Processor.process_pal_port_num_lanes_get
        self._processMap["pal_port_mtu_get"] = Processor.process_pal_port_mtu_get
        self._processMap["pal_port_mtu_set"] = Processor.process_pal_port_mtu_set
        self._processMap["pal_port_flow_control_pfc_get"] = Processor.process_pal_port_flow_control_pfc_get
        self._processMap["pal_port_flow_control_pfc_set"] = Processor.process_pal_port_flow_control_pfc_set
        self._processMap["pal_port_flow_control_link_pause_get"] = Processor.process_pal_port_flow_control_link_pause_get
        self._processMap["pal_port_flow_control_link_pause_set"] = Processor.process_pal_port_flow_control_link_pause_set
        self._processMap["pal_port_fec_get"] = Processor.process_pal_port_fec_get
        self._processMap["pal_port_fec_set"] = Processor.process_pal_port_fec_set
        self._processMap["pal_port_media_type_get"] = Processor.process_pal_port_media_type_get
        self._processMap["pal_port_cut_through_enable"] = Processor.process_pal_port_cut_through_enable
        self._processMap["pal_port_cut_through_disable"] = Processor.process_pal_port_cut_through_disable
        self._processMap["pal_port_cut_through_enable_status_get"] = Processor.process_pal_port_cut_through_enable_status_get
        self._processMap["pal_num_pipes_get"] = Processor.process_pal_num_pipes_get
        self._processMap["pal_port_loopback_mode_get"] = Processor.process_pal_port_loopback_mode_get
        self._processMap["pal_port_loopback_mode_set"] = Processor.process_pal_port_loopback_mode_set
        self._processMap["pal_port_front_panel_port_to_dev_port_get"] = Processor.process_pal_port_front_panel_port_to_dev_port_get
        self._processMap["pal_port_dev_port_to_front_panel_port_get"] = Processor.process_pal_port_dev_port_to_front_panel_port_get
        self._processMap["pal_max_ports_get"] = Processor.process_pal_max_ports_get
        self._processMap["pal_fp_idx_to_dev_port_map"] = Processor.process_pal_fp_idx_to_dev_port_map
        self._processMap["pal_recirc_port_to_dev_port_map"] = Processor.process_pal_recirc_port_to_dev_port_map
        self._processMap["pal_recirc_port_range_get"] = Processor.process_pal_recirc_port_range_get
        self._processMap["pal_is_port_internal"] = Processor.process_pal_is_port_internal
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_pal_port_add(self, seqid, iprot, oprot):
        args = pal_port_add_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_add_result()
        try:
            result.success = self._handler.pal_port_add(args.device, args.dev_port, args.ps, args.fec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_add", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_add_all(self, seqid, iprot, oprot):
        args = pal_port_add_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_add_all_result()
        try:
            result.success = self._handler.pal_port_add_all(args.device, args.ps, args.fec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_add_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_del(self, seqid, iprot, oprot):
        args = pal_port_del_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_del_result()
        try:
            result.success = self._handler.pal_port_del(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_del", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_del_all(self, seqid, iprot, oprot):
        args = pal_port_del_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_del_all_result()
        try:
            result.success = self._handler.pal_port_del_all(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_del_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_enable(self, seqid, iprot, oprot):
        args = pal_port_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_enable_result()
        try:
            result.success = self._handler.pal_port_enable(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_enable_all(self, seqid, iprot, oprot):
        args = pal_port_enable_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_enable_all_result()
        try:
            result.success = self._handler.pal_port_enable_all(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_enable_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_dis(self, seqid, iprot, oprot):
        args = pal_port_dis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_dis_result()
        try:
            result.success = self._handler.pal_port_dis(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_dis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_oper_status_get(self, seqid, iprot, oprot):
        args = pal_port_oper_status_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_oper_status_get_result()
        try:
            result.success = self._handler.pal_port_oper_status_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_oper_status_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_is_valid(self, seqid, iprot, oprot):
        args = pal_port_is_valid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_is_valid_result()
        try:
            result.success = self._handler.pal_port_is_valid(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_is_valid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_an_get(self, seqid, iprot, oprot):
        args = pal_port_an_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_an_get_result()
        try:
            result.success = self._handler.pal_port_an_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_an_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_an_set(self, seqid, iprot, oprot):
        args = pal_port_an_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_an_set_result()
        try:
            result.success = self._handler.pal_port_an_set(args.device, args.dev_port, args.an)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_an_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_an_set_all(self, seqid, iprot, oprot):
        args = pal_port_an_set_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_an_set_all_result()
        try:
            result.success = self._handler.pal_port_an_set_all(args.device, args.an)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_an_set_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_get_first(self, seqid, iprot, oprot):
        args = pal_port_get_first_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_get_first_result()
        try:
            result.success = self._handler.pal_port_get_first(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_get_first", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_get_next(self, seqid, iprot, oprot):
        args = pal_port_get_next_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_get_next_result()
        try:
            result.success = self._handler.pal_port_get_next(args.device, args.curr_dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_get_next", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_stats_direct_get(self, seqid, iprot, oprot):
        args = pal_port_stats_direct_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_stats_direct_get_result()
        try:
            result.success = self._handler.pal_port_stats_direct_get(args.device, args.dev_port, args.ctr_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_stats_direct_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_all_stats_get(self, seqid, iprot, oprot):
        args = pal_port_all_stats_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_all_stats_get_result()
        try:
            result.success = self._handler.pal_port_all_stats_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_all_stats_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_all_stats_get_with_ts(self, seqid, iprot, oprot):
        args = pal_port_all_stats_get_with_ts_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_all_stats_get_with_ts_result()
        try:
            result.success = self._handler.pal_port_all_stats_get_with_ts(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_all_stats_get_with_ts", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_this_stat_get(self, seqid, iprot, oprot):
        args = pal_port_this_stat_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_this_stat_get_result()
        try:
            result.success = self._handler.pal_port_this_stat_get(args.device, args.dev_port, args.ctr_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_this_stat_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_this_stat_id_to_str(self, seqid, iprot, oprot):
        args = pal_port_this_stat_id_to_str_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_this_stat_id_to_str_result()
        try:
            result.success = self._handler.pal_port_this_stat_id_to_str(args.ctr_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_this_stat_id_to_str", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_this_stat_clear(self, seqid, iprot, oprot):
        args = pal_port_this_stat_clear_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_this_stat_clear_result()
        try:
            result.success = self._handler.pal_port_this_stat_clear(args.device, args.dev_port, args.ctr_type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_this_stat_clear", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_all_stats_clear(self, seqid, iprot, oprot):
        args = pal_port_all_stats_clear_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_all_stats_clear_result()
        try:
            result.success = self._handler.pal_port_all_stats_clear(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_all_stats_clear", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_stats_poll_intvl_get(self, seqid, iprot, oprot):
        args = pal_port_stats_poll_intvl_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_stats_poll_intvl_get_result()
        try:
            result.success = self._handler.pal_port_stats_poll_intvl_get(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_stats_poll_intvl_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_stats_poll_intvl_set(self, seqid, iprot, oprot):
        args = pal_port_stats_poll_intvl_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_stats_poll_intvl_set_result()
        try:
            result.success = self._handler.pal_port_stats_poll_intvl_set(args.device, args.poll_intvl_ms)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_stats_poll_intvl_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_all_stats_update(self, seqid, iprot, oprot):
        args = pal_port_all_stats_update_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_all_stats_update_result()
        try:
            result.success = self._handler.pal_port_all_stats_update(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_all_stats_update", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_num_lanes_get(self, seqid, iprot, oprot):
        args = pal_port_num_lanes_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_num_lanes_get_result()
        try:
            result.success = self._handler.pal_port_num_lanes_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_num_lanes_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_mtu_get(self, seqid, iprot, oprot):
        args = pal_port_mtu_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_mtu_get_result()
        try:
            result.success = self._handler.pal_port_mtu_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_mtu_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_mtu_set(self, seqid, iprot, oprot):
        args = pal_port_mtu_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_mtu_set_result()
        try:
            result.success = self._handler.pal_port_mtu_set(args.device, args.dev_port, args.tx_mtu, args.rx_mtu)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_mtu_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_flow_control_pfc_get(self, seqid, iprot, oprot):
        args = pal_port_flow_control_pfc_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_flow_control_pfc_get_result()
        try:
            result.success = self._handler.pal_port_flow_control_pfc_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_flow_control_pfc_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_flow_control_pfc_set(self, seqid, iprot, oprot):
        args = pal_port_flow_control_pfc_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_flow_control_pfc_set_result()
        try:
            result.success = self._handler.pal_port_flow_control_pfc_set(args.device, args.dev_port, args.tx_en_map, args.rx_en_map)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_flow_control_pfc_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_flow_control_link_pause_get(self, seqid, iprot, oprot):
        args = pal_port_flow_control_link_pause_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_flow_control_link_pause_get_result()
        try:
            result.success = self._handler.pal_port_flow_control_link_pause_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_flow_control_link_pause_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_flow_control_link_pause_set(self, seqid, iprot, oprot):
        args = pal_port_flow_control_link_pause_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_flow_control_link_pause_set_result()
        try:
            result.success = self._handler.pal_port_flow_control_link_pause_set(args.device, args.dev_port, args.tx_en, args.rx_en)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_flow_control_link_pause_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_fec_get(self, seqid, iprot, oprot):
        args = pal_port_fec_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_fec_get_result()
        try:
            result.success = self._handler.pal_port_fec_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_fec_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_fec_set(self, seqid, iprot, oprot):
        args = pal_port_fec_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_fec_set_result()
        try:
            result.success = self._handler.pal_port_fec_set(args.device, args.dev_port, args.fec)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_fec_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_media_type_get(self, seqid, iprot, oprot):
        args = pal_port_media_type_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_media_type_get_result()
        try:
            result.success = self._handler.pal_port_media_type_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_media_type_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_cut_through_enable(self, seqid, iprot, oprot):
        args = pal_port_cut_through_enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_cut_through_enable_result()
        try:
            result.success = self._handler.pal_port_cut_through_enable(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_cut_through_enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_cut_through_disable(self, seqid, iprot, oprot):
        args = pal_port_cut_through_disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_cut_through_disable_result()
        try:
            result.success = self._handler.pal_port_cut_through_disable(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_cut_through_disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_cut_through_enable_status_get(self, seqid, iprot, oprot):
        args = pal_port_cut_through_enable_status_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_cut_through_enable_status_get_result()
        try:
            result.success = self._handler.pal_port_cut_through_enable_status_get(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_cut_through_enable_status_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_num_pipes_get(self, seqid, iprot, oprot):
        args = pal_num_pipes_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_num_pipes_get_result()
        try:
            result.success = self._handler.pal_num_pipes_get(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_num_pipes_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_loopback_mode_get(self, seqid, iprot, oprot):
        args = pal_port_loopback_mode_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_loopback_mode_get_result()
        try:
            result.success = self._handler.pal_port_loopback_mode_get(args.dev, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_loopback_mode_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_loopback_mode_set(self, seqid, iprot, oprot):
        args = pal_port_loopback_mode_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_loopback_mode_set_result()
        try:
            result.success = self._handler.pal_port_loopback_mode_set(args.dev, args.dev_port, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_loopback_mode_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_front_panel_port_to_dev_port_get(self, seqid, iprot, oprot):
        args = pal_port_front_panel_port_to_dev_port_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_front_panel_port_to_dev_port_get_result()
        try:
            result.success = self._handler.pal_port_front_panel_port_to_dev_port_get(args.dev, args.front_port, args.front_chnl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_front_panel_port_to_dev_port_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_port_dev_port_to_front_panel_port_get(self, seqid, iprot, oprot):
        args = pal_port_dev_port_to_front_panel_port_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_port_dev_port_to_front_panel_port_get_result()
        try:
            result.success = self._handler.pal_port_dev_port_to_front_panel_port_get(args.dev, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_port_dev_port_to_front_panel_port_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_max_ports_get(self, seqid, iprot, oprot):
        args = pal_max_ports_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_max_ports_get_result()
        try:
            result.success = self._handler.pal_max_ports_get(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_max_ports_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_fp_idx_to_dev_port_map(self, seqid, iprot, oprot):
        args = pal_fp_idx_to_dev_port_map_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_fp_idx_to_dev_port_map_result()
        try:
            result.success = self._handler.pal_fp_idx_to_dev_port_map(args.device, args.fp_idx)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_fp_idx_to_dev_port_map", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_recirc_port_to_dev_port_map(self, seqid, iprot, oprot):
        args = pal_recirc_port_to_dev_port_map_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_recirc_port_to_dev_port_map_result()
        try:
            result.success = self._handler.pal_recirc_port_to_dev_port_map(args.device, args.recirc_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_recirc_port_to_dev_port_map", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_recirc_port_range_get(self, seqid, iprot, oprot):
        args = pal_recirc_port_range_get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_recirc_port_range_get_result()
        try:
            result.success = self._handler.pal_recirc_port_range_get(args.device)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_recirc_port_range_get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pal_is_port_internal(self, seqid, iprot, oprot):
        args = pal_is_port_internal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pal_is_port_internal_result()
        try:
            result.success = self._handler.pal_is_port_internal(args.device, args.dev_port)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except InvalidPalOperation as ouch:
            msg_type = TMessageType.REPLY
            result.ouch = ouch
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pal_is_port_internal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class pal_port_add_args(object):
    """
    Attributes:
     - device
     - dev_port
     - ps
     - fec

    """


    def __init__(self, device=None, dev_port=None, ps=None, fec=None,):
        self.device = device
        self.dev_port = dev_port
        self.ps = ps
        self.fec = fec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.fec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_add_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.ps is not None:
            oprot.writeFieldBegin('ps', TType.I32, 3)
            oprot.writeI32(self.ps)
            oprot.writeFieldEnd()
        if self.fec is not None:
            oprot.writeFieldBegin('fec', TType.I32, 4)
            oprot.writeI32(self.fec)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_add_args)
pal_port_add_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'ps', None, None, ),  # 3
    (4, TType.I32, 'fec', None, None, ),  # 4
)


class pal_port_add_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_add_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_add_result)
pal_port_add_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_add_all_args(object):
    """
    Attributes:
     - device
     - ps
     - fec

    """


    def __init__(self, device=None, ps=None, fec=None,):
        self.device = device
        self.ps = ps
        self.fec = fec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.ps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_add_all_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.ps is not None:
            oprot.writeFieldBegin('ps', TType.I32, 2)
            oprot.writeI32(self.ps)
            oprot.writeFieldEnd()
        if self.fec is not None:
            oprot.writeFieldBegin('fec', TType.I32, 3)
            oprot.writeI32(self.fec)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_add_all_args)
pal_port_add_all_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'ps', None, None, ),  # 2
    (3, TType.I32, 'fec', None, None, ),  # 3
)


class pal_port_add_all_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_add_all_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_add_all_result)
pal_port_add_all_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_del_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_del_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_del_args)
pal_port_del_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_del_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_del_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_del_result)
pal_port_del_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_del_all_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_del_all_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_del_all_args)
pal_port_del_all_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_port_del_all_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_del_all_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_del_all_result)
pal_port_del_all_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_enable_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_enable_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_enable_args)
pal_port_enable_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_enable_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_enable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_enable_result)
pal_port_enable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_enable_all_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_enable_all_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_enable_all_args)
pal_port_enable_all_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_port_enable_all_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_enable_all_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_enable_all_result)
pal_port_enable_all_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_dis_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_dis_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_dis_args)
pal_port_dis_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_dis_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_dis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_dis_result)
pal_port_dis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_oper_status_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_oper_status_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_oper_status_get_args)
pal_port_oper_status_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_oper_status_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_oper_status_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_oper_status_get_result)
pal_port_oper_status_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_is_valid_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_is_valid_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_is_valid_args)
pal_port_is_valid_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_is_valid_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_is_valid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_is_valid_result)
pal_port_is_valid_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_an_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_an_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_an_get_args)
pal_port_an_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_an_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_an_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_an_get_result)
pal_port_an_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_an_set_args(object):
    """
    Attributes:
     - device
     - dev_port
     - an

    """


    def __init__(self, device=None, dev_port=None, an=None,):
        self.device = device
        self.dev_port = dev_port
        self.an = an

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.an = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_an_set_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.an is not None:
            oprot.writeFieldBegin('an', TType.I32, 3)
            oprot.writeI32(self.an)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_an_set_args)
pal_port_an_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'an', None, None, ),  # 3
)


class pal_port_an_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_an_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_an_set_result)
pal_port_an_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_an_set_all_args(object):
    """
    Attributes:
     - device
     - an

    """


    def __init__(self, device=None, an=None,):
        self.device = device
        self.an = an

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.an = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_an_set_all_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.an is not None:
            oprot.writeFieldBegin('an', TType.I32, 2)
            oprot.writeI32(self.an)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_an_set_all_args)
pal_port_an_set_all_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'an', None, None, ),  # 2
)


class pal_port_an_set_all_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_an_set_all_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_an_set_all_result)
pal_port_an_set_all_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_get_first_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_get_first_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_get_first_args)
pal_port_get_first_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_port_get_first_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_get_first_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_get_first_result)
pal_port_get_first_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_get_next_args(object):
    """
    Attributes:
     - device
     - curr_dev_port

    """


    def __init__(self, device=None, curr_dev_port=None,):
        self.device = device
        self.curr_dev_port = curr_dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.curr_dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_get_next_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.curr_dev_port is not None:
            oprot.writeFieldBegin('curr_dev_port', TType.I32, 2)
            oprot.writeI32(self.curr_dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_get_next_args)
pal_port_get_next_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'curr_dev_port', None, None, ),  # 2
)


class pal_port_get_next_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_get_next_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_get_next_result)
pal_port_get_next_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_stats_direct_get_args(object):
    """
    Attributes:
     - device
     - dev_port
     - ctr_type

    """


    def __init__(self, device=None, dev_port=None, ctr_type=None,):
        self.device = device
        self.dev_port = dev_port
        self.ctr_type = ctr_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ctr_type = pal_rmon_counters_array_t()
                    self.ctr_type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_stats_direct_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.ctr_type is not None:
            oprot.writeFieldBegin('ctr_type', TType.STRUCT, 3)
            self.ctr_type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_stats_direct_get_args)
pal_port_stats_direct_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.STRUCT, 'ctr_type', [pal_rmon_counters_array_t, None], None, ),  # 3
)


class pal_port_stats_direct_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_stats_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_stats_direct_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_stats_direct_get_result)
pal_port_stats_direct_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_stats_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_all_stats_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_get_args)
pal_port_all_stats_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_all_stats_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_stats_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_get_result)
pal_port_all_stats_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_stats_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_all_stats_get_with_ts_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_get_with_ts_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_get_with_ts_args)
pal_port_all_stats_get_with_ts_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_all_stats_get_with_ts_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_stats_with_ts_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_get_with_ts_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_get_with_ts_result)
pal_port_all_stats_get_with_ts_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_stats_with_ts_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_this_stat_get_args(object):
    """
    Attributes:
     - device
     - dev_port
     - ctr_type

    """


    def __init__(self, device=None, dev_port=None, ctr_type=None,):
        self.device = device
        self.dev_port = dev_port
        self.ctr_type = ctr_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ctr_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_this_stat_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.ctr_type is not None:
            oprot.writeFieldBegin('ctr_type', TType.I32, 3)
            oprot.writeI32(self.ctr_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_this_stat_get_args)
pal_port_this_stat_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'ctr_type', None, None, ),  # 3
)


class pal_port_this_stat_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_this_stat_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_this_stat_get_result)
pal_port_this_stat_get_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_this_stat_id_to_str_args(object):
    """
    Attributes:
     - ctr_type

    """


    def __init__(self, ctr_type=None,):
        self.ctr_type = ctr_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.ctr_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_this_stat_id_to_str_args')
        if self.ctr_type is not None:
            oprot.writeFieldBegin('ctr_type', TType.I32, 1)
            oprot.writeI32(self.ctr_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_this_stat_id_to_str_args)
pal_port_this_stat_id_to_str_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'ctr_type', None, None, ),  # 1
)


class pal_port_this_stat_id_to_str_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_string_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_this_stat_id_to_str_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_this_stat_id_to_str_result)
pal_port_this_stat_id_to_str_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_string_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_this_stat_clear_args(object):
    """
    Attributes:
     - device
     - dev_port
     - ctr_type

    """


    def __init__(self, device=None, dev_port=None, ctr_type=None,):
        self.device = device
        self.dev_port = dev_port
        self.ctr_type = ctr_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ctr_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_this_stat_clear_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.ctr_type is not None:
            oprot.writeFieldBegin('ctr_type', TType.I32, 3)
            oprot.writeI32(self.ctr_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_this_stat_clear_args)
pal_port_this_stat_clear_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'ctr_type', None, None, ),  # 3
)


class pal_port_this_stat_clear_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_this_stat_clear_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_this_stat_clear_result)
pal_port_this_stat_clear_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_all_stats_clear_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_clear_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_clear_args)
pal_port_all_stats_clear_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_all_stats_clear_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_clear_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_clear_result)
pal_port_all_stats_clear_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_stats_poll_intvl_get_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_stats_poll_intvl_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_stats_poll_intvl_get_args)
pal_port_stats_poll_intvl_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_port_stats_poll_intvl_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_stats_poll_intvl_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_stats_poll_intvl_get_result)
pal_port_stats_poll_intvl_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_stats_poll_intvl_set_args(object):
    """
    Attributes:
     - device
     - poll_intvl_ms

    """


    def __init__(self, device=None, poll_intvl_ms=None,):
        self.device = device
        self.poll_intvl_ms = poll_intvl_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.poll_intvl_ms = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_stats_poll_intvl_set_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.poll_intvl_ms is not None:
            oprot.writeFieldBegin('poll_intvl_ms', TType.I32, 2)
            oprot.writeI32(self.poll_intvl_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_stats_poll_intvl_set_args)
pal_port_stats_poll_intvl_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'poll_intvl_ms', None, None, ),  # 2
)


class pal_port_stats_poll_intvl_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_stats_poll_intvl_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_stats_poll_intvl_set_result)
pal_port_stats_poll_intvl_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_all_stats_update_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_update_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_update_args)
pal_port_all_stats_update_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_all_stats_update_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_all_stats_update_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_all_stats_update_result)
pal_port_all_stats_update_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_num_lanes_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_num_lanes_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_num_lanes_get_args)
pal_port_num_lanes_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_num_lanes_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_num_lanes_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_num_lanes_get_result)
pal_port_num_lanes_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_mtu_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_mtu_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_mtu_get_args)
pal_port_mtu_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_mtu_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_mtu_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_mtu_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_mtu_get_result)
pal_port_mtu_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_mtu_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_mtu_set_args(object):
    """
    Attributes:
     - device
     - dev_port
     - tx_mtu
     - rx_mtu

    """


    def __init__(self, device=None, dev_port=None, tx_mtu=None, rx_mtu=None,):
        self.device = device
        self.dev_port = dev_port
        self.tx_mtu = tx_mtu
        self.rx_mtu = rx_mtu

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tx_mtu = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.rx_mtu = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_mtu_set_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.tx_mtu is not None:
            oprot.writeFieldBegin('tx_mtu', TType.I32, 3)
            oprot.writeI32(self.tx_mtu)
            oprot.writeFieldEnd()
        if self.rx_mtu is not None:
            oprot.writeFieldBegin('rx_mtu', TType.I32, 4)
            oprot.writeI32(self.rx_mtu)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_mtu_set_args)
pal_port_mtu_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'tx_mtu', None, None, ),  # 3
    (4, TType.I32, 'rx_mtu', None, None, ),  # 4
)


class pal_port_mtu_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_mtu_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_mtu_set_result)
pal_port_mtu_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_flow_control_pfc_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_pfc_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_pfc_get_args)
pal_port_flow_control_pfc_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_flow_control_pfc_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_pfc_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_pfc_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_pfc_get_result)
pal_port_flow_control_pfc_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_pfc_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_flow_control_pfc_set_args(object):
    """
    Attributes:
     - device
     - dev_port
     - tx_en_map
     - rx_en_map

    """


    def __init__(self, device=None, dev_port=None, tx_en_map=None, rx_en_map=None,):
        self.device = device
        self.dev_port = dev_port
        self.tx_en_map = tx_en_map
        self.rx_en_map = rx_en_map

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tx_en_map = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.rx_en_map = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_pfc_set_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.tx_en_map is not None:
            oprot.writeFieldBegin('tx_en_map', TType.I32, 3)
            oprot.writeI32(self.tx_en_map)
            oprot.writeFieldEnd()
        if self.rx_en_map is not None:
            oprot.writeFieldBegin('rx_en_map', TType.I32, 4)
            oprot.writeI32(self.rx_en_map)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_pfc_set_args)
pal_port_flow_control_pfc_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'tx_en_map', None, None, ),  # 3
    (4, TType.I32, 'rx_en_map', None, None, ),  # 4
)


class pal_port_flow_control_pfc_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_pfc_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_pfc_set_result)
pal_port_flow_control_pfc_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_flow_control_link_pause_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_link_pause_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_link_pause_get_args)
pal_port_flow_control_link_pause_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_flow_control_link_pause_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_link_pause_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_link_pause_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_link_pause_get_result)
pal_port_flow_control_link_pause_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_link_pause_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_flow_control_link_pause_set_args(object):
    """
    Attributes:
     - device
     - dev_port
     - tx_en
     - rx_en

    """


    def __init__(self, device=None, dev_port=None, tx_en=None, rx_en=None,):
        self.device = device
        self.dev_port = dev_port
        self.tx_en = tx_en
        self.rx_en = rx_en

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.tx_en = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.rx_en = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_link_pause_set_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.tx_en is not None:
            oprot.writeFieldBegin('tx_en', TType.BOOL, 3)
            oprot.writeBool(self.tx_en)
            oprot.writeFieldEnd()
        if self.rx_en is not None:
            oprot.writeFieldBegin('rx_en', TType.BOOL, 4)
            oprot.writeBool(self.rx_en)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_link_pause_set_args)
pal_port_flow_control_link_pause_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.BOOL, 'tx_en', None, None, ),  # 3
    (4, TType.BOOL, 'rx_en', None, None, ),  # 4
)


class pal_port_flow_control_link_pause_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_flow_control_link_pause_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_flow_control_link_pause_set_result)
pal_port_flow_control_link_pause_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_fec_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_fec_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_fec_get_args)
pal_port_fec_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_fec_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_fec_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_fec_get_result)
pal_port_fec_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_fec_set_args(object):
    """
    Attributes:
     - device
     - dev_port
     - fec

    """


    def __init__(self, device=None, dev_port=None, fec=None,):
        self.device = device
        self.dev_port = dev_port
        self.fec = fec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_fec_set_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.fec is not None:
            oprot.writeFieldBegin('fec', TType.I32, 3)
            oprot.writeI32(self.fec)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_fec_set_args)
pal_port_fec_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'fec', None, None, ),  # 3
)


class pal_port_fec_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_fec_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_fec_set_result)
pal_port_fec_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_media_type_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_media_type_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_media_type_get_args)
pal_port_media_type_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_media_type_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_media_type_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_media_type_get_result)
pal_port_media_type_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_cut_through_enable_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_cut_through_enable_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_cut_through_enable_args)
pal_port_cut_through_enable_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_cut_through_enable_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_cut_through_enable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_cut_through_enable_result)
pal_port_cut_through_enable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_cut_through_disable_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_cut_through_disable_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_cut_through_disable_args)
pal_port_cut_through_disable_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_cut_through_disable_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_cut_through_disable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_cut_through_disable_result)
pal_port_cut_through_disable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_cut_through_enable_status_get_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_cut_through_enable_status_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_cut_through_enable_status_get_args)
pal_port_cut_through_enable_status_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_cut_through_enable_status_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_cut_through_enable_status_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_cut_through_enable_status_get_result)
pal_port_cut_through_enable_status_get_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_num_pipes_get_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_num_pipes_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_num_pipes_get_args)
pal_num_pipes_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_num_pipes_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_num_pipes_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_num_pipes_get_result)
pal_num_pipes_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_loopback_mode_get_args(object):
    """
    Attributes:
     - dev
     - dev_port

    """


    def __init__(self, dev=None, dev_port=None,):
        self.dev = dev
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.dev = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_loopback_mode_get_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.BYTE, 1)
            oprot.writeByte(self.dev)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_loopback_mode_get_args)
pal_port_loopback_mode_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'dev', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_loopback_mode_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_loopback_mode_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_loopback_mode_get_result)
pal_port_loopback_mode_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_loopback_mode_set_args(object):
    """
    Attributes:
     - dev
     - dev_port
     - mode

    """


    def __init__(self, dev=None, dev_port=None, mode=None,):
        self.dev = dev
        self.dev_port = dev_port
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.dev = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_loopback_mode_set_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.BYTE, 1)
            oprot.writeByte(self.dev)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 3)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_loopback_mode_set_args)
pal_port_loopback_mode_set_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'dev', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
    (3, TType.I32, 'mode', None, None, ),  # 3
)


class pal_port_loopback_mode_set_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_loopback_mode_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_loopback_mode_set_result)
pal_port_loopback_mode_set_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_front_panel_port_to_dev_port_get_args(object):
    """
    Attributes:
     - dev
     - front_port
     - front_chnl

    """


    def __init__(self, dev=None, front_port=None, front_chnl=None,):
        self.dev = dev
        self.front_port = front_port
        self.front_chnl = front_chnl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.dev = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.front_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.front_chnl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_front_panel_port_to_dev_port_get_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.BYTE, 1)
            oprot.writeByte(self.dev)
            oprot.writeFieldEnd()
        if self.front_port is not None:
            oprot.writeFieldBegin('front_port', TType.I32, 2)
            oprot.writeI32(self.front_port)
            oprot.writeFieldEnd()
        if self.front_chnl is not None:
            oprot.writeFieldBegin('front_chnl', TType.I32, 3)
            oprot.writeI32(self.front_chnl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_front_panel_port_to_dev_port_get_args)
pal_port_front_panel_port_to_dev_port_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'dev', None, None, ),  # 1
    (2, TType.I32, 'front_port', None, None, ),  # 2
    (3, TType.I32, 'front_chnl', None, None, ),  # 3
)


class pal_port_front_panel_port_to_dev_port_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_front_panel_port_to_dev_port_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_front_panel_port_to_dev_port_get_result)
pal_port_front_panel_port_to_dev_port_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_port_dev_port_to_front_panel_port_get_args(object):
    """
    Attributes:
     - dev
     - dev_port

    """


    def __init__(self, dev=None, dev_port=None,):
        self.dev = dev
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.dev = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_dev_port_to_front_panel_port_get_args')
        if self.dev is not None:
            oprot.writeFieldBegin('dev', TType.BYTE, 1)
            oprot.writeByte(self.dev)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_dev_port_to_front_panel_port_get_args)
pal_port_dev_port_to_front_panel_port_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'dev', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_port_dev_port_to_front_panel_port_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_front_panel_port_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_port_dev_port_to_front_panel_port_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_port_dev_port_to_front_panel_port_get_result)
pal_port_dev_port_to_front_panel_port_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_front_panel_port_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_max_ports_get_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_max_ports_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_max_ports_get_args)
pal_max_ports_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_max_ports_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_max_ports_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_max_ports_get_result)
pal_max_ports_get_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_fp_idx_to_dev_port_map_args(object):
    """
    Attributes:
     - device
     - fp_idx

    """


    def __init__(self, device=None, fp_idx=None,):
        self.device = device
        self.fp_idx = fp_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.fp_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_fp_idx_to_dev_port_map_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.fp_idx is not None:
            oprot.writeFieldBegin('fp_idx', TType.I32, 2)
            oprot.writeI32(self.fp_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_fp_idx_to_dev_port_map_args)
pal_fp_idx_to_dev_port_map_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'fp_idx', None, None, ),  # 2
)


class pal_fp_idx_to_dev_port_map_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_fp_idx_to_dev_port_map_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_fp_idx_to_dev_port_map_result)
pal_fp_idx_to_dev_port_map_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_recirc_port_to_dev_port_map_args(object):
    """
    Attributes:
     - device
     - recirc_port

    """


    def __init__(self, device=None, recirc_port=None,):
        self.device = device
        self.recirc_port = recirc_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.recirc_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_recirc_port_to_dev_port_map_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.recirc_port is not None:
            oprot.writeFieldBegin('recirc_port', TType.I32, 2)
            oprot.writeI32(self.recirc_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_recirc_port_to_dev_port_map_args)
pal_recirc_port_to_dev_port_map_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'recirc_port', None, None, ),  # 2
)


class pal_recirc_port_to_dev_port_map_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_recirc_port_to_dev_port_map_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_recirc_port_to_dev_port_map_result)
pal_recirc_port_to_dev_port_map_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_recirc_port_range_get_args(object):
    """
    Attributes:
     - device

    """


    def __init__(self, device=None,):
        self.device = device

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_recirc_port_range_get_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_recirc_port_range_get_args)
pal_recirc_port_range_get_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
)


class pal_recirc_port_range_get_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = pal_recirc_ports_t()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_recirc_port_range_get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_recirc_port_range_get_result)
pal_recirc_port_range_get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [pal_recirc_ports_t, None], None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)


class pal_is_port_internal_args(object):
    """
    Attributes:
     - device
     - dev_port

    """


    def __init__(self, device=None, dev_port=None,):
        self.device = device
        self.dev_port = dev_port

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.device = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dev_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_is_port_internal_args')
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.BYTE, 1)
            oprot.writeByte(self.device)
            oprot.writeFieldEnd()
        if self.dev_port is not None:
            oprot.writeFieldBegin('dev_port', TType.I32, 2)
            oprot.writeI32(self.dev_port)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_is_port_internal_args)
pal_is_port_internal_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'device', None, None, ),  # 1
    (2, TType.I32, 'dev_port', None, None, ),  # 2
)


class pal_is_port_internal_result(object):
    """
    Attributes:
     - success
     - ouch

    """


    def __init__(self, success=None, ouch=None,):
        self.success = success
        self.ouch = ouch

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ouch = InvalidPalOperation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pal_is_port_internal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.ouch is not None:
            oprot.writeFieldBegin('ouch', TType.STRUCT, 1)
            self.ouch.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pal_is_port_internal_result)
pal_is_port_internal_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'ouch', [InvalidPalOperation, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
